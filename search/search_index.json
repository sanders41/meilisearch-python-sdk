{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Meilisearch Python SDK","text":"<p>Meilisearch Python SDK provides both an async and sync client for the Meilisearch API.</p> <p>The focus of this documentation is on the Meilisearch Python SDK API. More information of Meilisearch itself and how to use it can be found at https://www.meilisearch.com/docs.</p>"},{"location":"#which-client-to-chose","title":"Which client to chose","text":"<p>If the code base you are working with uses asyncio, for example if you are using FastAPI, chose the <code>AsyncClint</code> otherwise chose the <code>Client</code>. The functionality of the two clients is the same, the difference being the <code>AsyncClient</code> provides async methods and uses the <code>AsyncIndex</code>, which also provides async methods, while the <code>Client</code> provides blocking methods and uses the <code>Index</code>, which also provides blocking methods.</p>"},{"location":"async_client_api/","title":"AsyncClient","text":""},{"location":"async_client_api/#asyncclient-usage","title":"<code>AsyncClient</code> Usage","text":""},{"location":"async_client_api/#create-a-client-with-a-context-manager","title":"Create a client with a context manager","text":"<p>This client runs in a context manager which ensures that everything is cleaned up after the use of the client is done. To create a client:</p> <pre><code>from meilisearch-python-sdk import AsyncClient\n\n\nasync with AsyncClient(\"http://localhost:7700\", \"masterKey\") as client:\n    index = client.index(\"movies\")\n    ...\n</code></pre>"},{"location":"async_client_api/#custom-headers","title":"Custom headers","text":"<p>Custom headers can be added to the client by adding them to <code>custom_headers</code> when creating the client.</p> <pre><code>from meilisearch_python_sdk import AsyncClient\n\nasync with AsyncClient(\n    \"http://127.0.0.1:7700\",\n    \"masterKey\",\n    custom_headers={\"header_key_1\": \"header_value_1\", \"header_key_2\": \"header_value_2\"}\n) as client:\n    index = client.index(\"movies\")\n    ...\n</code></pre>"},{"location":"async_client_api/#create-a-client-without-a-context-manager","title":"Create a client without a context manager","text":"<p>It is also possible to call the client without using a context manager, but in doing so you will need to make sure to do the cleanup yourself:</p> <pre><code>from meilisearch-python-sdk import AsyncClient\n\n\ntry:\n    client = AsyncClient(\"http://localhost:7700\", \"masterKey\")\n    ...\nfinally:\n    await client.aclose()\n\n</code></pre>"},{"location":"async_client_api/#asyncclient-api","title":"<code>AsyncClient</code> API","text":"<p>               Bases: <code>BaseClient</code></p> <p>Async client to connect to the Meilisearch API.</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>class AsyncClient(BaseClient):\n    \"\"\"Async client to connect to the Meilisearch API.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        api_key: str | None = None,\n        *,\n        timeout: int | None = None,\n        verify: bool | SSLContext = True,\n        custom_headers: dict[str, str] | None = None,\n        json_handler: BuiltinHandler | OrjsonHandler | None = None,\n        http2: bool = False,\n    ) -&gt; None:\n        \"\"\"Class initializer.\n\n        Args:\n            url: The url to the Meilisearch API (ex: http://localhost:7700)\n            api_key: The optional API key for Meilisearch. Defaults to None.\n            timeout: The amount of time in seconds that the client will wait for a response before\n                timing out. Defaults to None.\n            verify: SSL certificates (a.k.a CA bundle) used to\n                verify the identity of requested hosts. Either `True` (default CA bundle),\n                a path to an SSL certificate file, or `False` (disable verification)\n            custom_headers: Custom headers to add when sending data to Meilisearch. Defaults to\n                None.\n            json_handler: The module to use for json operations. The options are BuiltinHandler\n                (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n                Note that in order use orjson the corresponding extra needs to be included.\n                Default: BuiltinHandler.\n            http2: Whether or not to use HTTP/2. Defaults to False.\n        \"\"\"\n        super().__init__(api_key, custom_headers, json_handler)\n\n        self.http_client = HttpxAsyncClient(\n            base_url=url, timeout=timeout, headers=self._headers, verify=verify, http2=http2\n        )\n        self._http_requests = AsyncHttpRequests(self.http_client, json_handler=self.json_handler)\n\n    async def __aenter__(self) -&gt; Self:\n        return self\n\n    async def __aexit__(\n        self,\n        et: type[BaseException] | None,\n        ev: type[BaseException] | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        await self.aclose()\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Closes the client.\n\n        This only needs to be used if the client was not created with a context manager.\n        \"\"\"\n        await self.http_client.aclose()\n\n    async def add_or_update_networks(self, *, network: Network) -&gt; Network:\n        \"\"\"Set or update remote networks.\n\n        Args:\n            network: Information to use for the networks.\n\n        Returns:\n            An instance of Network containing the network information.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.client import Network, Remote\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; network = Network(\n            &gt;&gt;&gt; self_=\"remote_1\",\n            &gt;&gt;&gt;     remotes={\n            &gt;&gt;&gt;         \"remote_1\": {\"url\": \"http://localhost:7700\", \"searchApiKey\": \"xxxx\"},\n            &gt;&gt;&gt;         \"remote_2\": {\"url\": \"http://localhost:7720\", \"searchApiKey\": \"xxxx\"},\n            &gt;&gt;&gt;     },\n            &gt;&gt;&gt; )\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     response = await client.add_or_update_networks(network=network)\n        \"\"\"\n        response = await self._http_requests.patch(\n            \"network\", network.model_dump(by_alias=True, exclude_none=True)\n        )\n\n        return Network(**self._http_requests.parse_json(response))\n\n    async def get_networks(self) -&gt; Network:\n        \"\"\"Fetches the remote-networks\n\n        Returns:\n            An instance of Network containing information about each remote.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     response = await client.get_networks()\n        \"\"\"\n        response = await self._http_requests.get(\"network\")\n\n        return Network(**self._http_requests.parse_json(response))\n\n    async def get_webhooks(self) -&gt; Webhooks:\n        \"\"\"Get all webhooks.\n\n        Returns:\n            An instance of Webhooks containing all configured webhooks.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     webhooks = await client.get_webhooks()\n        \"\"\"\n        response = await self._http_requests.get(\"webhooks\")\n\n        return Webhooks(**self._http_requests.parse_json(response))\n\n    async def get_webhook(self, uuid: str) -&gt; Webhook:\n        \"\"\"Get a specific webhook by UUID.\n\n        Args:\n            uuid: The webhook's unique identifier.\n\n        Returns:\n            An instance of Webhook containing the webhook information.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     webhook = await client.get_webhook(\"abc-123\")\n        \"\"\"\n        response = await self._http_requests.get(f\"webhooks/{uuid}\")\n\n        return Webhook(**self._http_requests.parse_json(response))\n\n    async def create_webhook(self, webhook: WebhookCreate) -&gt; Webhook:\n        \"\"\"Create a new webhook.\n\n        Args:\n            webhook: The webhook configuration to create.\n\n        Returns:\n            The created webhook.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookCreate\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     webhook_config = WebhookCreate(\n            &gt;&gt;&gt;         url=\"https://example.com/webhook\",\n            &gt;&gt;&gt;         headers={\"Authorization\": \"Bearer token\"}\n            &gt;&gt;&gt;     )\n            &gt;&gt;&gt;     webhook = await client.create_webhook(webhook_config)\n        \"\"\"\n        response = await self._http_requests.post(\n            \"webhooks\", webhook.model_dump(by_alias=True, exclude_none=True)\n        )\n\n        return Webhook(**self._http_requests.parse_json(response))\n\n    async def update_webhook(self, *, uuid: str, webhook: WebhookUpdate) -&gt; Webhook:\n        \"\"\"Update an existing webhook.\n\n        Args:\n            uuid: The webhook's unique identifier.\n            webhook: The webhook configuration updates.\n\n        Returns:\n            The updated webhook.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookUpdate\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     webhook_update = WebhookUpdate(url=\"https://example.com/new-webhook\")\n            &gt;&gt;&gt;     webhook = await client.update_webhook(\"abc-123\", webhook_update)\n        \"\"\"\n        response = await self._http_requests.patch(\n            f\"webhooks/{uuid}\", webhook.model_dump(by_alias=True, exclude_none=True)\n        )\n\n        return Webhook(**self._http_requests.parse_json(response))\n\n    async def delete_webhook(self, uuid: str) -&gt; int:\n        \"\"\"Delete a webhook.\n\n        Args:\n            uuid: The webhook's unique identifier.\n\n        Returns:\n            The Response status code. 204 signifies a successful delete.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.delete_webhook(\"abc-123\")\n        \"\"\"\n        response = await self._http_requests.delete(f\"webhooks/{uuid}\")\n        return response.status_code\n\n    async def create_dump(self) -&gt; TaskInfo:\n        \"\"\"Trigger the creation of a Meilisearch dump.\n\n        Returns:\n            The details of the task.\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.create_dump()\n        \"\"\"\n        response = await self._http_requests.post(\"dumps\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def create_index(\n        self,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        settings: MeilisearchSettings | None = None,\n        wait: bool = True,\n        timeout_in_ms: int | None = None,\n        plugins: AsyncIndexPlugins | None = None,\n        hits_type: Any = JsonDict,  # noqa: ANN401\n    ) -&gt; AsyncIndex:\n        \"\"\"Creates a new index.\n\n        Args:\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            settings: Settings for the index. The settings can also be updated independently of\n                creating the index. The advantage to updating them here is updating the settings after\n                adding documents will cause the documents to be re-indexed. Because of this it will be\n                faster to update them before adding documents. Defaults to None (i.e. default\n                Meilisearch index settings).\n            wait: If set to True and settings are being updated, the index will be returned after\n                the settings update has completed. If False it will not wait for settings to complete.\n                Default: True\n            timeout_in_ms: Amount of time in milliseconds to wait before raising a\n                MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n                if the `None` option is used the wait time could be very long. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n\n        Returns:\n            An instance of AsyncIndex containing the information of the newly created index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.create_index(\"movies\")\n        \"\"\"\n        return await AsyncIndex.create(\n            self.http_client,\n            uid,\n            primary_key,\n            settings=settings,\n            wait=wait,\n            timeout_in_ms=timeout_in_ms,\n            plugins=plugins,\n            json_handler=self.json_handler,\n            hits_type=hits_type,\n        )\n\n    async def create_snapshot(self) -&gt; TaskInfo:\n        \"\"\"Trigger the creation of a Meilisearch snapshot.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.create_snapshot()\n        \"\"\"\n        response = await self._http_requests.post(\"snapshots\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def delete_index_if_exists(self, uid: str) -&gt; bool:\n        \"\"\"Deletes an index if it already exists.\n\n        Args:\n            uid: The index's unique identifier.\n\n        Returns:\n            True if an index was deleted for False if not.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.delete_index_if_exists()\n        \"\"\"\n        response = await self._http_requests.delete(f\"indexes/{uid}\")\n        status = await self.wait_for_task(\n            self._http_requests.parse_json(response)[\"taskUid\"], timeout_in_ms=100000\n        )\n        if status.status == \"succeeded\":\n            return True\n        return False\n\n    async def get_indexes(\n        self, *, offset: int | None = None, limit: int | None = None\n    ) -&gt; list[AsyncIndex] | None:\n        \"\"\"Get all indexes.\n\n        Args:\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns:\n            A list of all indexes.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     indexes = await client.get_indexes()\n        \"\"\"\n        url = _build_offset_limit_url(\"indexes\", offset, limit)\n        response = await self._http_requests.get(url)\n\n        if not self._http_requests.parse_json(response)[\"results\"]:\n            return None\n\n        return [\n            AsyncIndex(\n                http_client=self.http_client,\n                uid=x[\"uid\"],\n                primary_key=x[\"primaryKey\"],\n                created_at=x[\"createdAt\"],\n                updated_at=x[\"updatedAt\"],\n                json_handler=self.json_handler,\n            )\n            for x in self._http_requests.parse_json(response)[\"results\"]\n        ]\n\n    async def get_index(self, uid: str) -&gt; AsyncIndex:\n        \"\"\"Gets a single index based on the uid of the index.\n\n        Args:\n            uid: The index's unique identifier.\n\n        Returns:\n            An AsyncIndex instance containing the information of the fetched index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.get_index()\n        \"\"\"\n        return await AsyncIndex(self.http_client, uid, json_handler=self.json_handler).fetch_info()\n\n    def index(self, uid: str, *, plugins: AsyncIndexPlugins | None = None) -&gt; AsyncIndex:\n        \"\"\"Create a local reference to an index identified by UID, without making an HTTP call.\n\n        Because no network call is made this method is not awaitable.\n\n        Args:\n            uid: The index's unique identifier.\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n            An AsyncIndex instance.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n        \"\"\"\n        return AsyncIndex(\n            self.http_client, uid=uid, plugins=plugins, json_handler=self.json_handler\n        )\n\n    async def get_all_stats(self) -&gt; ClientStats:\n        \"\"\"Get stats for all indexes.\n\n        Returns:\n            Information about database size and all indexes.\n            https://docs.meilisearch.com/reference/api/stats.html\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     stats = await client.get_all_stats()\n        \"\"\"\n        response = await self._http_requests.get(\"stats\")\n\n        return ClientStats(**self._http_requests.parse_json(response))\n\n    async def get_or_create_index(\n        self,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        plugins: AsyncIndexPlugins | None = None,\n        hits_type: Any = JsonDict,  # noqa: ANN401\n    ) -&gt; AsyncIndex:\n        \"\"\"Get an index, or create it if it doesn't exist.\n\n        Args:\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n\n        Returns:\n            An instance of AsyncIndex containing the information of the retrieved or newly created index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.get_or_create_index(\"movies\")\n        \"\"\"\n        try:\n            index_instance = await self.get_index(uid)\n        except MeilisearchApiError as err:\n            if \"index_not_found\" not in err.code:\n                raise\n            index_instance = await self.create_index(\n                uid, primary_key, plugins=plugins, hits_type=hits_type\n            )\n        return index_instance\n\n    async def create_key(self, key: KeyCreate) -&gt; Key:\n        \"\"\"Creates a new API key.\n\n        Args:\n            key: The information to use in creating the key. Note that if an expires_at value\n                is included it should be in UTC time.\n\n        Returns:\n            The new API key.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     key_info = KeyCreate(\n            &gt;&gt;&gt;         description=\"My new key\",\n            &gt;&gt;&gt;         actions=[\"search\"],\n            &gt;&gt;&gt;         indexes=[\"movies\"],\n            &gt;&gt;&gt;     )\n            &gt;&gt;&gt;     keys = await client.create_key(key_info)\n        \"\"\"\n        response = await self._http_requests.post(\n            \"keys\", key.model_dump(by_alias=True, mode=\"json\")\n        )\n\n        return Key(**self._http_requests.parse_json(response))\n\n    async def delete_key(self, key: str) -&gt; int:\n        \"\"\"Deletes an API key.\n\n        Args:\n            key: The key or uid to delete.\n\n        Returns:\n            The Response status code. 204 signifies a successful delete.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.delete_key(\"abc123\")\n        \"\"\"\n        response = await self._http_requests.delete(f\"keys/{key}\")\n        return response.status_code\n\n    async def get_keys(self, *, offset: int | None = None, limit: int | None = None) -&gt; KeySearch:\n        \"\"\"Gets the Meilisearch API keys.\n\n        Args:\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns:\n            API keys.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            from meilisearch_python_sdk import AsyncClient\n            async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n                keys = await client.get_keys()\n        \"\"\"\n        url = _build_offset_limit_url(\"keys\", offset, limit)\n        response = await self._http_requests.get(url)\n\n        return KeySearch(**self._http_requests.parse_json(response))\n\n    async def get_key(self, key: str) -&gt; Key:\n        \"\"\"Gets information about a specific API key.\n\n        Args:\n            key: The key for which to retrieve the information.\n\n        Returns:\n            The API key, or `None` if the key is not found.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     keys = await client.get_key(\"abc123\")\n        \"\"\"\n        response = await self._http_requests.get(f\"keys/{key}\")\n\n        return Key(**self._http_requests.parse_json(response))\n\n    async def update_key(self, key: KeyUpdate) -&gt; Key:\n        \"\"\"Update an API key.\n\n        Args:\n            key: The information to use in updating the key. Note that if an expires_at value\n                is included it should be in UTC time.\n\n        Returns:\n            The updated API key.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     key_info = KeyUpdate(\n                        key=\"abc123\",\n            &gt;&gt;&gt;         indexes=[\"*\"],\n            &gt;&gt;&gt;     )\n            &gt;&gt;&gt;     keys = await client.update_key(key_info)\n        \"\"\"\n        payload = _build_update_key_payload(key, self.json_handler)\n        response = await self._http_requests.patch(f\"keys/{key.key}\", payload)\n\n        return Key(**self._http_requests.parse_json(response))\n\n    async def multi_search(\n        self,\n        queries: list[SearchParams],\n        *,\n        federation: Federation | FederationMerged | None = None,\n        hits_type: Any = JsonDict,  # noqa: ANN401\n    ) -&gt; list[SearchResultsWithUID] | SearchResultsFederated:\n        \"\"\"Multi-index search.\n\n        Args:\n            queries: List of SearchParameters\n            federation: If included a single search result with hits built from all queries will\n                be returned. This parameter can only be used with Meilisearch &gt;= v1.10.0. Defaults\n                to None.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n\n        Returns:\n            Results of the search\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     queries = [\n            &gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n            &gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n            &gt;&gt;&gt;     ]\n            &gt;&gt;&gt;     search_results = await client.search(queries)\n        \"\"\"\n        url = \"multi-search\"\n        processed_queries = []\n        for query in queries:\n            q = query.model_dump(by_alias=True)\n\n            if query.retrieve_vectors is None:\n                del q[\"retrieveVectors\"]\n\n            if federation:\n                del q[\"limit\"]\n                del q[\"offset\"]\n\n            if query.media is None:\n                del q[\"media\"]\n\n            if query.show_performance_details is None:\n                del q[\"showPerformanceDetails\"]\n\n            processed_queries.append(q)\n\n        if federation:\n            federation_payload = federation.model_dump(by_alias=True)\n            if federation.facets_by_index is None:\n                del federation_payload[\"facetsByIndex\"]\n\n        else:\n            federation_payload = None\n\n        response = await self._http_requests.post(\n            url,\n            body={\n                \"federation\": federation_payload,\n                \"queries\": processed_queries,\n            },\n        )\n\n        if federation:\n            results = self._http_requests.parse_json(response)\n            return SearchResultsFederated[hits_type](**results)\n\n        return [\n            SearchResultsWithUID[hits_type](**x)\n            for x in self._http_requests.parse_json(response)[\"results\"]\n        ]\n\n    async def get_raw_index(self, uid: str) -&gt; IndexInfo | None:\n        \"\"\"Gets the index and returns all the index information rather than an AsyncIndex instance.\n\n        Args:\n            uid: The index's unique identifier.\n\n        Returns:\n            Index information rather than an AsyncIndex instance.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.get_raw_index(\"movies\")\n        \"\"\"\n        response = await self.http_client.get(f\"indexes/{uid}\")\n\n        if response.status_code == 404:\n            return None\n\n        return IndexInfo(**self._http_requests.parse_json(response))\n\n    async def get_raw_indexes(\n        self, *, offset: int | None = None, limit: int | None = None\n    ) -&gt; list[IndexInfo] | None:\n        \"\"\"Gets all the indexes.\n\n        Args:\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns all the index information rather than an AsyncIndex instance.\n\n        Returns:\n            A list of the Index information rather than an AsyncIndex instances.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.get_raw_indexes()\n        \"\"\"\n        url = _build_offset_limit_url(\"indexes\", offset, limit)\n        response = await self._http_requests.get(url)\n\n        if not self._http_requests.parse_json(response)[\"results\"]:\n            return None\n\n        return [IndexInfo(**x) for x in self._http_requests.parse_json(response)[\"results\"]]\n\n    async def get_version(self) -&gt; Version:\n        \"\"\"Get the Meilisearch version.\n\n        Returns:\n            Information about the version of Meilisearch.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     version = await client.get_version()\n        \"\"\"\n        response = await self._http_requests.get(\"version\")\n\n        return Version(**self._http_requests.parse_json(response))\n\n    async def health(self) -&gt; Health:\n        \"\"\"Get health of the Meilisearch server.\n\n        Returns:\n            The status of the Meilisearch server.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     health = await client.get_health()\n        \"\"\"\n        response = await self._http_requests.get(\"health\")\n\n        return Health(**self._http_requests.parse_json(response))\n\n    async def swap_indexes(self, indexes: list[tuple[str, str]], rename: bool = False) -&gt; TaskInfo:\n        \"\"\"Swap two indexes.\n\n        Args:\n            indexes: A list of tuples, each tuple should contain the indexes to swap.\n            rename: Use rename false if you are swapping two existing indexes. Use rename true if\n                the second index in your array does not exist. Default = False\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.swap_indexes([(\"index_a\", \"index_b\")])\n        \"\"\"\n        if rename:\n            processed_indexes = [{\"indexes\": x, \"rename\": True} for x in indexes]\n        else:\n            processed_indexes = [{\"indexes\": x} for x in indexes]\n        response = await self._http_requests.post(\"swap-indexes\", processed_indexes)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_batch(self, batch_uid: int) -&gt; BatchResult | None:\n        return await async_get_batch(self, batch_uid)\n\n    async def get_batches(\n        self,\n        *,\n        uids: list[int] | None = None,\n        batch_uids: list[int] | None = None,\n        index_uids: list[int] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        limit: int = 20,\n        from_: str | None = None,\n        reverse: bool = False,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; BatchStatus:\n        return await async_get_batches(\n            self,\n            uids=uids,\n            batch_uids=batch_uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            limit=limit,\n            from_=from_,\n            reverse=reverse,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    async def cancel_tasks(\n        self,\n        *,\n        uids: list[int] | None = None,\n        index_uids: list[int] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Cancel a list of enqueued or processing tasks.\n\n        Defaults to cancelling all tasks.\n\n        Args:\n            uids: A list of task UIDs to cancel.\n            index_uids: A list of index UIDs for which to cancel tasks.\n            statuses: A list of statuses to cancel.\n            types: A list of types to cancel.\n            before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n            after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n            before_started_at: Cancel tasks that were started before the specified date time.\n            after_finished_at: Cancel tasks that were finished after the specified date time.\n\n        Returns:\n            The details of the task\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.cancel_tasks(uids=[1, 2])\n        \"\"\"\n        return await _task.async_cancel_tasks(\n            self.http_client,\n            uids=uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    async def get_task(self, task_id: int) -&gt; TaskResult:\n        \"\"\"Get a single task from it's task id.\n\n        Args:\n            task_id: Identifier of the task to retrieve.\n\n        Returns:\n            Results of a task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.task import get_task\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.get_task(client, 1244)\n        \"\"\"\n        return await _task.async_get_task(self.http_client, task_id=task_id)\n\n    async def delete_tasks(\n        self,\n        *,\n        uids: list[int] | None = None,\n        index_uids: list[int] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Delete a list of tasks.\n\n        Defaults to deleting all tasks.\n\n        Args:\n            uids: A list of task UIDs to delete.\n            index_uids: A list of index UIDs for which to delete tasks.\n            statuses: A list of statuses to delete.\n            types: A list of types to delete.\n            before_enqueued_at: Delete tasks that were enqueued before the specified date time.\n            after_enqueued_at: Delete tasks that were enqueued after the specified date time.\n            before_started_at: Delete tasks that were started before the specified date time.\n            after_finished_at: Delete tasks that were finished after the specified date time.\n\n        Returns:\n            The details of the task\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.task import delete_tasks\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.delete_tasks(uids=[1, 2])\n        \"\"\"\n        return await _task.async_delete_tasks(\n            self.http_client,\n            uids=uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    async def get_tasks(\n        self,\n        *,\n        index_ids: list[str] | None = None,\n        types: str | list[str] | None = None,\n        reverse: bool | None = None,\n    ) -&gt; TaskStatus:\n        \"\"\"Get multiple tasks.\n\n        Args:\n            index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n                tasks only for the specified indexes, if not all tasks will be returned. Default = None\n            types: Specify specific task types to retrieve. Default = None\n            reverse: If True the tasks will be returned in reverse order. Default = None\n\n        Returns:\n            Task statuses.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.get_tasks()\n        \"\"\"\n        return await _task.async_get_tasks(\n            self.http_client, index_ids=index_ids, types=types, reverse=reverse\n        )\n\n    async def wait_for_task(\n        self,\n        task_id: int,\n        *,\n        timeout_in_ms: int | None = 5000,\n        interval_in_ms: int = 50,\n        raise_for_status: bool = False,\n    ) -&gt; TaskResult:\n        \"\"\"Wait until Meilisearch processes a task, and get its status.\n\n        Args:\n            task_id: Identifier of the task to retrieve.\n            timeout_in_ms: Amount of time in milliseconds to wait before raising a\n                MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n                if the `None` option is used the wait time could be very long. Defaults to 5000.\n            interval_in_ms: Time interval in milliseconds to sleep between requests. Defaults to 50.\n            raise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n                has a failed status. Defaults to False.\n\n        Returns:\n            Details of the processed update status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n            MeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     response = await index.add_documents(documents)\n            &gt;&gt;&gt;     await client.wait_for_task(client, response.update_id)\n        \"\"\"\n        return await _task.async_wait_for_task(\n            self.http_client,\n            task_id=task_id,\n            timeout_in_ms=timeout_in_ms,\n            interval_in_ms=interval_in_ms,\n            raise_for_status=raise_for_status,\n        )\n\n    # No cover because it requires multiple instances of Meilisearch\n    async def transfer_documents(  # pragma: no cover\n        self,\n        url: str,\n        *,\n        api_key: str | None = None,\n        payload_size: str | None = None,\n        indexes: JsonMapping | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Transfer settings and documents from one Meilisearch instance to another.\n\n        Args:\n            url: Where to send our settings and documents.\n            api_key: The API key with the rights to send the requests. Usually the master key of\n                the remote machine. Defaults to None.\n            payload_size: Human readable size defining the size of the payloads to send. Defaults\n                to 50\u00a0MiB.\n            indexes: A set of patterns of matching the indexes you want to export. Defaults to all\n                indexes without filter.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await index.transfer_documents(\n            &gt;&gt;&gt;         \"https://another-instance.com\", api_key=\"otherMasterKey\"\n            &gt;&gt;&gt;     )\n        \"\"\"\n        payload: JsonDict = {\"url\": url}\n\n        if api_key:\n            payload[\"apiKey\"] = api_key\n\n        if payload:\n            payload[\"payloadSize\"] = payload_size\n\n        if indexes:\n            payload[\"indexes\"] = indexes\n\n        response = await self._http_requests.post(url, body=payload)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_experimental_features(self) -&gt; dict[str, bool]:\n        \"\"\"Gets all experimental features and if they are enabled or not.\n\n        Returns:\n            The status of the experimental features.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await index.get_experimental_feature()\n        \"\"\"\n\n        response = await self._http_requests.get(\"/experimental-features\")\n        return self._http_requests.parse_json(response)\n\n    async def update_experimental_features(self, features: dict[str, bool]) -&gt; dict[str, bool]:\n        \"\"\"Update the status of an experimental feature.\n\n        Args:\n            features: Dictionary of features to enable/disable. The dictionary keys can be in either\n                camel case or snake case, the conversion to the correct type will be handed for you by\n                the program. For example {\"logsRoute\": True} and {\"logs_route\": True} will both work.\n\n        Returns:\n            The status of the experimental features.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await index.update_experimental_features({\"logsRoute\": True})\n        \"\"\"\n        payload = dict_to_camel(features)\n        response = await self._http_requests.patch(\"/experimental-features\", body=payload)\n\n        return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.__init__","title":"<code>__init__(url, api_key=None, *, timeout=None, verify=True, custom_headers=None, json_handler=None, http2=False)</code>","text":"<p>Class initializer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to the Meilisearch API (ex: http://localhost:7700)</p> required <code>api_key</code> <code>str | None</code> <p>The optional API key for Meilisearch. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>The amount of time in seconds that the client will wait for a response before timing out. Defaults to None.</p> <code>None</code> <code>verify</code> <code>bool | SSLContext</code> <p>SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts. Either <code>True</code> (default CA bundle), a path to an SSL certificate file, or <code>False</code> (disable verification)</p> <code>True</code> <code>custom_headers</code> <code>dict[str, str] | None</code> <p>Custom headers to add when sending data to Meilisearch. Defaults to None.</p> <code>None</code> <code>json_handler</code> <code>BuiltinHandler | OrjsonHandler | None</code> <p>The module to use for json operations. The options are BuiltinHandler (uses the json module from the standard library), or OrjsonHandler (uses orjson). Note that in order use orjson the corresponding extra needs to be included. Default: BuiltinHandler.</p> <code>None</code> <code>http2</code> <code>bool</code> <p>Whether or not to use HTTP/2. Defaults to False.</p> <code>False</code> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    api_key: str | None = None,\n    *,\n    timeout: int | None = None,\n    verify: bool | SSLContext = True,\n    custom_headers: dict[str, str] | None = None,\n    json_handler: BuiltinHandler | OrjsonHandler | None = None,\n    http2: bool = False,\n) -&gt; None:\n    \"\"\"Class initializer.\n\n    Args:\n        url: The url to the Meilisearch API (ex: http://localhost:7700)\n        api_key: The optional API key for Meilisearch. Defaults to None.\n        timeout: The amount of time in seconds that the client will wait for a response before\n            timing out. Defaults to None.\n        verify: SSL certificates (a.k.a CA bundle) used to\n            verify the identity of requested hosts. Either `True` (default CA bundle),\n            a path to an SSL certificate file, or `False` (disable verification)\n        custom_headers: Custom headers to add when sending data to Meilisearch. Defaults to\n            None.\n        json_handler: The module to use for json operations. The options are BuiltinHandler\n            (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n            Note that in order use orjson the corresponding extra needs to be included.\n            Default: BuiltinHandler.\n        http2: Whether or not to use HTTP/2. Defaults to False.\n    \"\"\"\n    super().__init__(api_key, custom_headers, json_handler)\n\n    self.http_client = HttpxAsyncClient(\n        base_url=url, timeout=timeout, headers=self._headers, verify=verify, http2=http2\n    )\n    self._http_requests = AsyncHttpRequests(self.http_client, json_handler=self.json_handler)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Closes the client.</p> <p>This only needs to be used if the client was not created with a context manager.</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Closes the client.\n\n    This only needs to be used if the client was not created with a context manager.\n    \"\"\"\n    await self.http_client.aclose()\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.add_or_update_networks","title":"<code>add_or_update_networks(*, network)</code>  <code>async</code>","text":"<p>Set or update remote networks.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Network</code> <p>Information to use for the networks.</p> required <p>Returns:</p> Type Description <code>Network</code> <p>An instance of Network containing the network information.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.models.client import Network, Remote\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; network = Network(\n&gt;&gt;&gt; self_=\"remote_1\",\n&gt;&gt;&gt;     remotes={\n&gt;&gt;&gt;         \"remote_1\": {\"url\": \"http://localhost:7700\", \"searchApiKey\": \"xxxx\"},\n&gt;&gt;&gt;         \"remote_2\": {\"url\": \"http://localhost:7720\", \"searchApiKey\": \"xxxx\"},\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     response = await client.add_or_update_networks(network=network)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def add_or_update_networks(self, *, network: Network) -&gt; Network:\n    \"\"\"Set or update remote networks.\n\n    Args:\n        network: Information to use for the networks.\n\n    Returns:\n        An instance of Network containing the network information.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.client import Network, Remote\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; network = Network(\n        &gt;&gt;&gt; self_=\"remote_1\",\n        &gt;&gt;&gt;     remotes={\n        &gt;&gt;&gt;         \"remote_1\": {\"url\": \"http://localhost:7700\", \"searchApiKey\": \"xxxx\"},\n        &gt;&gt;&gt;         \"remote_2\": {\"url\": \"http://localhost:7720\", \"searchApiKey\": \"xxxx\"},\n        &gt;&gt;&gt;     },\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     response = await client.add_or_update_networks(network=network)\n    \"\"\"\n    response = await self._http_requests.patch(\n        \"network\", network.model_dump(by_alias=True, exclude_none=True)\n    )\n\n    return Network(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.cancel_tasks","title":"<code>cancel_tasks(*, uids=None, index_uids=None, statuses=None, types=None, before_enqueued_at=None, after_enqueued_at=None, before_started_at=None, after_finished_at=None)</code>  <code>async</code>","text":"<p>Cancel a list of enqueued or processing tasks.</p> <p>Defaults to cancelling all tasks.</p> <p>Parameters:</p> Name Type Description Default <code>uids</code> <code>list[int] | None</code> <p>A list of task UIDs to cancel.</p> <code>None</code> <code>index_uids</code> <code>list[int] | None</code> <p>A list of index UIDs for which to cancel tasks.</p> <code>None</code> <code>statuses</code> <code>list[str] | None</code> <p>A list of statuses to cancel.</p> <code>None</code> <code>types</code> <code>list[str] | None</code> <p>A list of types to cancel.</p> <code>None</code> <code>before_enqueued_at</code> <code>datetime | None</code> <p>Cancel tasks that were enqueued before the specified date time.</p> <code>None</code> <code>after_enqueued_at</code> <code>datetime | None</code> <p>Cancel tasks that were enqueued after the specified date time.</p> <code>None</code> <code>before_started_at</code> <code>datetime | None</code> <p>Cancel tasks that were started before the specified date time.</p> <code>None</code> <code>after_finished_at</code> <code>datetime | None</code> <p>Cancel tasks that were finished after the specified date time.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt;     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     await client.cancel_tasks(uids=[1, 2])</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def cancel_tasks(\n    self,\n    *,\n    uids: list[int] | None = None,\n    index_uids: list[int] | None = None,\n    statuses: list[str] | None = None,\n    types: list[str] | None = None,\n    before_enqueued_at: datetime | None = None,\n    after_enqueued_at: datetime | None = None,\n    before_started_at: datetime | None = None,\n    after_finished_at: datetime | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Cancel a list of enqueued or processing tasks.\n\n    Defaults to cancelling all tasks.\n\n    Args:\n        uids: A list of task UIDs to cancel.\n        index_uids: A list of index UIDs for which to cancel tasks.\n        statuses: A list of statuses to cancel.\n        types: A list of types to cancel.\n        before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n        after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n        before_started_at: Cancel tasks that were started before the specified date time.\n        after_finished_at: Cancel tasks that were finished after the specified date time.\n\n    Returns:\n        The details of the task\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.cancel_tasks(uids=[1, 2])\n    \"\"\"\n    return await _task.async_cancel_tasks(\n        self.http_client,\n        uids=uids,\n        index_uids=index_uids,\n        statuses=statuses,\n        types=types,\n        before_enqueued_at=before_enqueued_at,\n        after_enqueued_at=after_enqueued_at,\n        before_started_at=before_started_at,\n        after_finished_at=after_finished_at,\n    )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_dump","title":"<code>create_dump()</code>  <code>async</code>","text":"<p>Trigger the creation of a Meilisearch dump.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:     MeilisearchCommunicationError: If there was an error communicating with the server.     MeilisearchApiError: If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.create_dump()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_dump(self) -&gt; TaskInfo:\n    \"\"\"Trigger the creation of a Meilisearch dump.\n\n    Returns:\n        The details of the task.\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.create_dump()\n    \"\"\"\n    response = await self._http_requests.post(\"dumps\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_index","title":"<code>create_index(uid, primary_key=None, *, settings=None, wait=True, timeout_in_ms=None, plugins=None, hits_type=JsonDict)</code>  <code>async</code>","text":"<p>Creates a new index.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. Defaults to None.</p> <code>None</code> <code>settings</code> <code>MeilisearchSettings | None</code> <p>Settings for the index. The settings can also be updated independently of creating the index. The advantage to updating them here is updating the settings after adding documents will cause the documents to be re-indexed. Because of this it will be faster to update them before adding documents. Defaults to None (i.e. default Meilisearch index settings).</p> <code>None</code> <code>wait</code> <code>bool</code> <p>If set to True and settings are being updated, the index will be returned after the settings update has completed. If False it will not wait for settings to complete. Default: True</p> <code>True</code> <code>timeout_in_ms</code> <code>int | None</code> <p>Amount of time in milliseconds to wait before raising a MeilisearchTimeoutError. <code>None</code> can also be passed to wait indefinitely. Be aware that if the <code>None</code> option is used the wait time could be very long. Defaults to None.</p> <code>None</code> <code>plugins</code> <code>AsyncIndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <code>hits_type</code> <code>Any</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> <p>Returns:</p> Type Description <code>AsyncIndex</code> <p>An instance of AsyncIndex containing the information of the newly created index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await client.create_index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_index(\n    self,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    settings: MeilisearchSettings | None = None,\n    wait: bool = True,\n    timeout_in_ms: int | None = None,\n    plugins: AsyncIndexPlugins | None = None,\n    hits_type: Any = JsonDict,  # noqa: ANN401\n) -&gt; AsyncIndex:\n    \"\"\"Creates a new index.\n\n    Args:\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        settings: Settings for the index. The settings can also be updated independently of\n            creating the index. The advantage to updating them here is updating the settings after\n            adding documents will cause the documents to be re-indexed. Because of this it will be\n            faster to update them before adding documents. Defaults to None (i.e. default\n            Meilisearch index settings).\n        wait: If set to True and settings are being updated, the index will be returned after\n            the settings update has completed. If False it will not wait for settings to complete.\n            Default: True\n        timeout_in_ms: Amount of time in milliseconds to wait before raising a\n            MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n            if the `None` option is used the wait time could be very long. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n\n    Returns:\n        An instance of AsyncIndex containing the information of the newly created index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.create_index(\"movies\")\n    \"\"\"\n    return await AsyncIndex.create(\n        self.http_client,\n        uid,\n        primary_key,\n        settings=settings,\n        wait=wait,\n        timeout_in_ms=timeout_in_ms,\n        plugins=plugins,\n        json_handler=self.json_handler,\n        hits_type=hits_type,\n    )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_key","title":"<code>create_key(key)</code>  <code>async</code>","text":"<p>Creates a new API key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>KeyCreate</code> <p>The information to use in creating the key. Note that if an expires_at value is included it should be in UTC time.</p> required <p>Returns:</p> Type Description <code>Key</code> <p>The new API key.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     key_info = KeyCreate(     &gt;&gt;&gt;         description=\"My new key\",     &gt;&gt;&gt;         actions=[\"search\"],     &gt;&gt;&gt;         indexes=[\"movies\"],     &gt;&gt;&gt;     )     &gt;&gt;&gt;     keys = await client.create_key(key_info)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_key(self, key: KeyCreate) -&gt; Key:\n    \"\"\"Creates a new API key.\n\n    Args:\n        key: The information to use in creating the key. Note that if an expires_at value\n            is included it should be in UTC time.\n\n    Returns:\n        The new API key.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     key_info = KeyCreate(\n        &gt;&gt;&gt;         description=\"My new key\",\n        &gt;&gt;&gt;         actions=[\"search\"],\n        &gt;&gt;&gt;         indexes=[\"movies\"],\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt;     keys = await client.create_key(key_info)\n    \"\"\"\n    response = await self._http_requests.post(\n        \"keys\", key.model_dump(by_alias=True, mode=\"json\")\n    )\n\n    return Key(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_snapshot","title":"<code>create_snapshot()</code>  <code>async</code>","text":"<p>Trigger the creation of a Meilisearch snapshot.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.create_snapshot()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_snapshot(self) -&gt; TaskInfo:\n    \"\"\"Trigger the creation of a Meilisearch snapshot.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.create_snapshot()\n    \"\"\"\n    response = await self._http_requests.post(\"snapshots\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_webhook","title":"<code>create_webhook(webhook)</code>  <code>async</code>","text":"<p>Create a new webhook.</p> <p>Parameters:</p> Name Type Description Default <code>webhook</code> <code>WebhookCreate</code> <p>The webhook configuration to create.</p> required <p>Returns:</p> Type Description <code>Webhook</code> <p>The created webhook.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookCreate\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     webhook_config = WebhookCreate(\n&gt;&gt;&gt;         url=\"https://example.com/webhook\",\n&gt;&gt;&gt;         headers={\"Authorization\": \"Bearer token\"}\n&gt;&gt;&gt;     )\n&gt;&gt;&gt;     webhook = await client.create_webhook(webhook_config)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_webhook(self, webhook: WebhookCreate) -&gt; Webhook:\n    \"\"\"Create a new webhook.\n\n    Args:\n        webhook: The webhook configuration to create.\n\n    Returns:\n        The created webhook.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookCreate\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     webhook_config = WebhookCreate(\n        &gt;&gt;&gt;         url=\"https://example.com/webhook\",\n        &gt;&gt;&gt;         headers={\"Authorization\": \"Bearer token\"}\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt;     webhook = await client.create_webhook(webhook_config)\n    \"\"\"\n    response = await self._http_requests.post(\n        \"webhooks\", webhook.model_dump(by_alias=True, exclude_none=True)\n    )\n\n    return Webhook(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.delete_index_if_exists","title":"<code>delete_index_if_exists(uid)</code>  <code>async</code>","text":"<p>Deletes an index if it already exists.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if an index was deleted for False if not.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.delete_index_if_exists()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def delete_index_if_exists(self, uid: str) -&gt; bool:\n    \"\"\"Deletes an index if it already exists.\n\n    Args:\n        uid: The index's unique identifier.\n\n    Returns:\n        True if an index was deleted for False if not.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.delete_index_if_exists()\n    \"\"\"\n    response = await self._http_requests.delete(f\"indexes/{uid}\")\n    status = await self.wait_for_task(\n        self._http_requests.parse_json(response)[\"taskUid\"], timeout_in_ms=100000\n    )\n    if status.status == \"succeeded\":\n        return True\n    return False\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.delete_key","title":"<code>delete_key(key)</code>  <code>async</code>","text":"<p>Deletes an API key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key or uid to delete.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The Response status code. 204 signifies a successful delete.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     await client.delete_key(\"abc123\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def delete_key(self, key: str) -&gt; int:\n    \"\"\"Deletes an API key.\n\n    Args:\n        key: The key or uid to delete.\n\n    Returns:\n        The Response status code. 204 signifies a successful delete.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.delete_key(\"abc123\")\n    \"\"\"\n    response = await self._http_requests.delete(f\"keys/{key}\")\n    return response.status_code\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.delete_tasks","title":"<code>delete_tasks(*, uids=None, index_uids=None, statuses=None, types=None, before_enqueued_at=None, after_enqueued_at=None, before_started_at=None, after_finished_at=None)</code>  <code>async</code>","text":"<p>Delete a list of tasks.</p> <p>Defaults to deleting all tasks.</p> <p>Parameters:</p> Name Type Description Default <code>uids</code> <code>list[int] | None</code> <p>A list of task UIDs to delete.</p> <code>None</code> <code>index_uids</code> <code>list[int] | None</code> <p>A list of index UIDs for which to delete tasks.</p> <code>None</code> <code>statuses</code> <code>list[str] | None</code> <p>A list of statuses to delete.</p> <code>None</code> <code>types</code> <code>list[str] | None</code> <p>A list of types to delete.</p> <code>None</code> <code>before_enqueued_at</code> <code>datetime | None</code> <p>Delete tasks that were enqueued before the specified date time.</p> <code>None</code> <code>after_enqueued_at</code> <code>datetime | None</code> <p>Delete tasks that were enqueued after the specified date time.</p> <code>None</code> <code>before_started_at</code> <code>datetime | None</code> <p>Delete tasks that were started before the specified date time.</p> <code>None</code> <code>after_finished_at</code> <code>datetime | None</code> <p>Delete tasks that were finished after the specified date time.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.task import delete_tasks     &gt;&gt;&gt;     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     await client.delete_tasks(uids=[1, 2])</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def delete_tasks(\n    self,\n    *,\n    uids: list[int] | None = None,\n    index_uids: list[int] | None = None,\n    statuses: list[str] | None = None,\n    types: list[str] | None = None,\n    before_enqueued_at: datetime | None = None,\n    after_enqueued_at: datetime | None = None,\n    before_started_at: datetime | None = None,\n    after_finished_at: datetime | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Delete a list of tasks.\n\n    Defaults to deleting all tasks.\n\n    Args:\n        uids: A list of task UIDs to delete.\n        index_uids: A list of index UIDs for which to delete tasks.\n        statuses: A list of statuses to delete.\n        types: A list of types to delete.\n        before_enqueued_at: Delete tasks that were enqueued before the specified date time.\n        after_enqueued_at: Delete tasks that were enqueued after the specified date time.\n        before_started_at: Delete tasks that were started before the specified date time.\n        after_finished_at: Delete tasks that were finished after the specified date time.\n\n    Returns:\n        The details of the task\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.task import delete_tasks\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.delete_tasks(uids=[1, 2])\n    \"\"\"\n    return await _task.async_delete_tasks(\n        self.http_client,\n        uids=uids,\n        index_uids=index_uids,\n        statuses=statuses,\n        types=types,\n        before_enqueued_at=before_enqueued_at,\n        after_enqueued_at=after_enqueued_at,\n        before_started_at=before_started_at,\n        after_finished_at=after_finished_at,\n    )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.delete_webhook","title":"<code>delete_webhook(uuid)</code>  <code>async</code>","text":"<p>Delete a webhook.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The webhook's unique identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The Response status code. 204 signifies a successful delete.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.delete_webhook(\"abc-123\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def delete_webhook(self, uuid: str) -&gt; int:\n    \"\"\"Delete a webhook.\n\n    Args:\n        uuid: The webhook's unique identifier.\n\n    Returns:\n        The Response status code. 204 signifies a successful delete.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.delete_webhook(\"abc-123\")\n    \"\"\"\n    response = await self._http_requests.delete(f\"webhooks/{uuid}\")\n    return response.status_code\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_all_stats","title":"<code>get_all_stats()</code>  <code>async</code>","text":"<p>Get stats for all indexes.</p> <p>Returns:</p> Name Type Description <code>ClientStats</code> <p>Information about database size and all indexes.</p> <code>https</code> <code>ClientStats</code> <p>//docs.meilisearch.com/reference/api/stats.html</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     stats = await client.get_all_stats()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_all_stats(self) -&gt; ClientStats:\n    \"\"\"Get stats for all indexes.\n\n    Returns:\n        Information about database size and all indexes.\n        https://docs.meilisearch.com/reference/api/stats.html\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     stats = await client.get_all_stats()\n    \"\"\"\n    response = await self._http_requests.get(\"stats\")\n\n    return ClientStats(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_experimental_features","title":"<code>get_experimental_features()</code>  <code>async</code>","text":"<p>Gets all experimental features and if they are enabled or not.</p> <p>Returns:</p> Type Description <code>dict[str, bool]</code> <p>The status of the experimental features.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     await index.get_experimental_feature()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_experimental_features(self) -&gt; dict[str, bool]:\n    \"\"\"Gets all experimental features and if they are enabled or not.\n\n    Returns:\n        The status of the experimental features.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await index.get_experimental_feature()\n    \"\"\"\n\n    response = await self._http_requests.get(\"/experimental-features\")\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_index","title":"<code>get_index(uid)</code>  <code>async</code>","text":"<p>Gets a single index based on the uid of the index.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <p>Returns:</p> Type Description <code>AsyncIndex</code> <p>An AsyncIndex instance containing the information of the fetched index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await client.get_index()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_index(self, uid: str) -&gt; AsyncIndex:\n    \"\"\"Gets a single index based on the uid of the index.\n\n    Args:\n        uid: The index's unique identifier.\n\n    Returns:\n        An AsyncIndex instance containing the information of the fetched index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.get_index()\n    \"\"\"\n    return await AsyncIndex(self.http_client, uid, json_handler=self.json_handler).fetch_info()\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_indexes","title":"<code>get_indexes(*, offset=None, limit=None)</code>  <code>async</code>","text":"<p>Get all indexes.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int | None</code> <p>Number of indexes to skip. The default of None will use the Meilisearch default.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Number of indexes to return. The default of None will use the Meilisearch default.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[AsyncIndex] | None</code> <p>A list of all indexes.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     indexes = await client.get_indexes()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_indexes(\n    self, *, offset: int | None = None, limit: int | None = None\n) -&gt; list[AsyncIndex] | None:\n    \"\"\"Get all indexes.\n\n    Args:\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns:\n        A list of all indexes.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     indexes = await client.get_indexes()\n    \"\"\"\n    url = _build_offset_limit_url(\"indexes\", offset, limit)\n    response = await self._http_requests.get(url)\n\n    if not self._http_requests.parse_json(response)[\"results\"]:\n        return None\n\n    return [\n        AsyncIndex(\n            http_client=self.http_client,\n            uid=x[\"uid\"],\n            primary_key=x[\"primaryKey\"],\n            created_at=x[\"createdAt\"],\n            updated_at=x[\"updatedAt\"],\n            json_handler=self.json_handler,\n        )\n        for x in self._http_requests.parse_json(response)[\"results\"]\n    ]\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_key","title":"<code>get_key(key)</code>  <code>async</code>","text":"<p>Gets information about a specific API key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for which to retrieve the information.</p> required <p>Returns:</p> Type Description <code>Key</code> <p>The API key, or <code>None</code> if the key is not found.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     keys = await client.get_key(\"abc123\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_key(self, key: str) -&gt; Key:\n    \"\"\"Gets information about a specific API key.\n\n    Args:\n        key: The key for which to retrieve the information.\n\n    Returns:\n        The API key, or `None` if the key is not found.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     keys = await client.get_key(\"abc123\")\n    \"\"\"\n    response = await self._http_requests.get(f\"keys/{key}\")\n\n    return Key(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_keys","title":"<code>get_keys(*, offset=None, limit=None)</code>  <code>async</code>","text":"<p>Gets the Meilisearch API keys.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int | None</code> <p>Number of indexes to skip. The default of None will use the Meilisearch default.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Number of indexes to return. The default of None will use the Meilisearch default.</p> <code>None</code> <p>Returns:</p> Type Description <code>KeySearch</code> <p>API keys.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     from meilisearch_python_sdk import AsyncClient     async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:         keys = await client.get_keys()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_keys(self, *, offset: int | None = None, limit: int | None = None) -&gt; KeySearch:\n    \"\"\"Gets the Meilisearch API keys.\n\n    Args:\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns:\n        API keys.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        from meilisearch_python_sdk import AsyncClient\n        async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            keys = await client.get_keys()\n    \"\"\"\n    url = _build_offset_limit_url(\"keys\", offset, limit)\n    response = await self._http_requests.get(url)\n\n    return KeySearch(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_networks","title":"<code>get_networks()</code>  <code>async</code>","text":"<p>Fetches the remote-networks</p> <p>Returns:</p> Type Description <code>Network</code> <p>An instance of Network containing information about each remote.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     response = await client.get_networks()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_networks(self) -&gt; Network:\n    \"\"\"Fetches the remote-networks\n\n    Returns:\n        An instance of Network containing information about each remote.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     response = await client.get_networks()\n    \"\"\"\n    response = await self._http_requests.get(\"network\")\n\n    return Network(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_or_create_index","title":"<code>get_or_create_index(uid, primary_key=None, *, plugins=None, hits_type=JsonDict)</code>  <code>async</code>","text":"<p>Get an index, or create it if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. Defaults to None.</p> <code>None</code> <code>plugins</code> <code>AsyncIndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <code>hits_type</code> <code>Any</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> <p>Returns:</p> Type Description <code>AsyncIndex</code> <p>An instance of AsyncIndex containing the information of the retrieved or newly created index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = await client.get_or_create_index(\"movies\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_or_create_index(\n    self,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    plugins: AsyncIndexPlugins | None = None,\n    hits_type: Any = JsonDict,  # noqa: ANN401\n) -&gt; AsyncIndex:\n    \"\"\"Get an index, or create it if it doesn't exist.\n\n    Args:\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n\n    Returns:\n        An instance of AsyncIndex containing the information of the retrieved or newly created index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.get_or_create_index(\"movies\")\n    \"\"\"\n    try:\n        index_instance = await self.get_index(uid)\n    except MeilisearchApiError as err:\n        if \"index_not_found\" not in err.code:\n            raise\n        index_instance = await self.create_index(\n            uid, primary_key, plugins=plugins, hits_type=hits_type\n        )\n    return index_instance\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_raw_index","title":"<code>get_raw_index(uid)</code>  <code>async</code>","text":"<p>Gets the index and returns all the index information rather than an AsyncIndex instance.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <p>Returns:</p> Type Description <code>IndexInfo | None</code> <p>Index information rather than an AsyncIndex instance.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = await client.get_raw_index(\"movies\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_raw_index(self, uid: str) -&gt; IndexInfo | None:\n    \"\"\"Gets the index and returns all the index information rather than an AsyncIndex instance.\n\n    Args:\n        uid: The index's unique identifier.\n\n    Returns:\n        Index information rather than an AsyncIndex instance.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.get_raw_index(\"movies\")\n    \"\"\"\n    response = await self.http_client.get(f\"indexes/{uid}\")\n\n    if response.status_code == 404:\n        return None\n\n    return IndexInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_raw_indexes","title":"<code>get_raw_indexes(*, offset=None, limit=None)</code>  <code>async</code>","text":"<p>Gets all the indexes.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int | None</code> <p>Number of indexes to skip. The default of None will use the Meilisearch default.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Number of indexes to return. The default of None will use the Meilisearch default.</p> <code>None</code> <p>Returns all the index information rather than an AsyncIndex instance.</p> <p>Returns:</p> Type Description <code>list[IndexInfo] | None</code> <p>A list of the Index information rather than an AsyncIndex instances.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = await client.get_raw_indexes()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_raw_indexes(\n    self, *, offset: int | None = None, limit: int | None = None\n) -&gt; list[IndexInfo] | None:\n    \"\"\"Gets all the indexes.\n\n    Args:\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns all the index information rather than an AsyncIndex instance.\n\n    Returns:\n        A list of the Index information rather than an AsyncIndex instances.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.get_raw_indexes()\n    \"\"\"\n    url = _build_offset_limit_url(\"indexes\", offset, limit)\n    response = await self._http_requests.get(url)\n\n    if not self._http_requests.parse_json(response)[\"results\"]:\n        return None\n\n    return [IndexInfo(**x) for x in self._http_requests.parse_json(response)[\"results\"]]\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_task","title":"<code>get_task(task_id)</code>  <code>async</code>","text":"<p>Get a single task from it's task id.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>Identifier of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>TaskResult</code> <p>Results of a task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.task import get_task     &gt;&gt;&gt;     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     await client.get_task(client, 1244)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_task(self, task_id: int) -&gt; TaskResult:\n    \"\"\"Get a single task from it's task id.\n\n    Args:\n        task_id: Identifier of the task to retrieve.\n\n    Returns:\n        Results of a task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.task import get_task\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.get_task(client, 1244)\n    \"\"\"\n    return await _task.async_get_task(self.http_client, task_id=task_id)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_tasks","title":"<code>get_tasks(*, index_ids=None, types=None, reverse=None)</code>  <code>async</code>","text":"<p>Get multiple tasks.</p> <p>Parameters:</p> Name Type Description Default <code>index_ids</code> <code>list[str] | None</code> <p>A list of index UIDs for which to get the tasks. If provided this will get the tasks only for the specified indexes, if not all tasks will be returned. Default = None</p> <code>None</code> <code>types</code> <code>str | list[str] | None</code> <p>Specify specific task types to retrieve. Default = None</p> <code>None</code> <code>reverse</code> <code>bool | None</code> <p>If True the tasks will be returned in reverse order. Default = None</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskStatus</code> <p>Task statuses.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt;     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     await client.get_tasks()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_tasks(\n    self,\n    *,\n    index_ids: list[str] | None = None,\n    types: str | list[str] | None = None,\n    reverse: bool | None = None,\n) -&gt; TaskStatus:\n    \"\"\"Get multiple tasks.\n\n    Args:\n        index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n            tasks only for the specified indexes, if not all tasks will be returned. Default = None\n        types: Specify specific task types to retrieve. Default = None\n        reverse: If True the tasks will be returned in reverse order. Default = None\n\n    Returns:\n        Task statuses.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.get_tasks()\n    \"\"\"\n    return await _task.async_get_tasks(\n        self.http_client, index_ids=index_ids, types=types, reverse=reverse\n    )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_version","title":"<code>get_version()</code>  <code>async</code>","text":"<p>Get the Meilisearch version.</p> <p>Returns:</p> Type Description <code>Version</code> <p>Information about the version of Meilisearch.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     version = await client.get_version()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_version(self) -&gt; Version:\n    \"\"\"Get the Meilisearch version.\n\n    Returns:\n        Information about the version of Meilisearch.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     version = await client.get_version()\n    \"\"\"\n    response = await self._http_requests.get(\"version\")\n\n    return Version(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_webhook","title":"<code>get_webhook(uuid)</code>  <code>async</code>","text":"<p>Get a specific webhook by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The webhook's unique identifier.</p> required <p>Returns:</p> Type Description <code>Webhook</code> <p>An instance of Webhook containing the webhook information.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     webhook = await client.get_webhook(\"abc-123\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_webhook(self, uuid: str) -&gt; Webhook:\n    \"\"\"Get a specific webhook by UUID.\n\n    Args:\n        uuid: The webhook's unique identifier.\n\n    Returns:\n        An instance of Webhook containing the webhook information.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     webhook = await client.get_webhook(\"abc-123\")\n    \"\"\"\n    response = await self._http_requests.get(f\"webhooks/{uuid}\")\n\n    return Webhook(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_webhooks","title":"<code>get_webhooks()</code>  <code>async</code>","text":"<p>Get all webhooks.</p> <p>Returns:</p> Type Description <code>Webhooks</code> <p>An instance of Webhooks containing all configured webhooks.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     webhooks = await client.get_webhooks()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_webhooks(self) -&gt; Webhooks:\n    \"\"\"Get all webhooks.\n\n    Returns:\n        An instance of Webhooks containing all configured webhooks.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     webhooks = await client.get_webhooks()\n    \"\"\"\n    response = await self._http_requests.get(\"webhooks\")\n\n    return Webhooks(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.health","title":"<code>health()</code>  <code>async</code>","text":"<p>Get health of the Meilisearch server.</p> <p>Returns:</p> Type Description <code>Health</code> <p>The status of the Meilisearch server.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     health = await client.get_health()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def health(self) -&gt; Health:\n    \"\"\"Get health of the Meilisearch server.\n\n    Returns:\n        The status of the Meilisearch server.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     health = await client.get_health()\n    \"\"\"\n    response = await self._http_requests.get(\"health\")\n\n    return Health(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.index","title":"<code>index(uid, *, plugins=None)</code>","text":"<p>Create a local reference to an index identified by UID, without making an HTTP call.</p> <p>Because no network call is made this method is not awaitable.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>plugins</code> <code>AsyncIndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIndex</code> <p>An AsyncIndex instance.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def index(self, uid: str, *, plugins: AsyncIndexPlugins | None = None) -&gt; AsyncIndex:\n    \"\"\"Create a local reference to an index identified by UID, without making an HTTP call.\n\n    Because no network call is made this method is not awaitable.\n\n    Args:\n        uid: The index's unique identifier.\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n        An AsyncIndex instance.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n    \"\"\"\n    return AsyncIndex(\n        self.http_client, uid=uid, plugins=plugins, json_handler=self.json_handler\n    )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.multi_search","title":"<code>multi_search(queries, *, federation=None, hits_type=JsonDict)</code>  <code>async</code>","text":"<p>Multi-index search.</p> <p>Parameters:</p> Name Type Description Default <code>queries</code> <code>list[SearchParams]</code> <p>List of SearchParameters</p> required <code>federation</code> <code>Federation | FederationMerged | None</code> <p>If included a single search result with hits built from all queries will be returned. This parameter can only be used with Meilisearch &gt;= v1.10.0. Defaults to None.</p> <code>None</code> <code>hits_type</code> <code>Any</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> <p>Returns:</p> Type Description <code>list[SearchResultsWithUID] | SearchResultsFederated</code> <p>Results of the search</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     queries = [     &gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),     &gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")     &gt;&gt;&gt;     ]     &gt;&gt;&gt;     search_results = await client.search(queries)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def multi_search(\n    self,\n    queries: list[SearchParams],\n    *,\n    federation: Federation | FederationMerged | None = None,\n    hits_type: Any = JsonDict,  # noqa: ANN401\n) -&gt; list[SearchResultsWithUID] | SearchResultsFederated:\n    \"\"\"Multi-index search.\n\n    Args:\n        queries: List of SearchParameters\n        federation: If included a single search result with hits built from all queries will\n            be returned. This parameter can only be used with Meilisearch &gt;= v1.10.0. Defaults\n            to None.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n\n    Returns:\n        Results of the search\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     queries = [\n        &gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n        &gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n        &gt;&gt;&gt;     ]\n        &gt;&gt;&gt;     search_results = await client.search(queries)\n    \"\"\"\n    url = \"multi-search\"\n    processed_queries = []\n    for query in queries:\n        q = query.model_dump(by_alias=True)\n\n        if query.retrieve_vectors is None:\n            del q[\"retrieveVectors\"]\n\n        if federation:\n            del q[\"limit\"]\n            del q[\"offset\"]\n\n        if query.media is None:\n            del q[\"media\"]\n\n        if query.show_performance_details is None:\n            del q[\"showPerformanceDetails\"]\n\n        processed_queries.append(q)\n\n    if federation:\n        federation_payload = federation.model_dump(by_alias=True)\n        if federation.facets_by_index is None:\n            del federation_payload[\"facetsByIndex\"]\n\n    else:\n        federation_payload = None\n\n    response = await self._http_requests.post(\n        url,\n        body={\n            \"federation\": federation_payload,\n            \"queries\": processed_queries,\n        },\n    )\n\n    if federation:\n        results = self._http_requests.parse_json(response)\n        return SearchResultsFederated[hits_type](**results)\n\n    return [\n        SearchResultsWithUID[hits_type](**x)\n        for x in self._http_requests.parse_json(response)[\"results\"]\n    ]\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.swap_indexes","title":"<code>swap_indexes(indexes, rename=False)</code>  <code>async</code>","text":"<p>Swap two indexes.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>list[tuple[str, str]]</code> <p>A list of tuples, each tuple should contain the indexes to swap.</p> required <code>rename</code> <code>bool</code> <p>Use rename false if you are swapping two existing indexes. Use rename true if the second index in your array does not exist. Default = False</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = await client.swap_indexes([(\"index_a\", \"index_b\")])</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def swap_indexes(self, indexes: list[tuple[str, str]], rename: bool = False) -&gt; TaskInfo:\n    \"\"\"Swap two indexes.\n\n    Args:\n        indexes: A list of tuples, each tuple should contain the indexes to swap.\n        rename: Use rename false if you are swapping two existing indexes. Use rename true if\n            the second index in your array does not exist. Default = False\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.swap_indexes([(\"index_a\", \"index_b\")])\n    \"\"\"\n    if rename:\n        processed_indexes = [{\"indexes\": x, \"rename\": True} for x in indexes]\n    else:\n        processed_indexes = [{\"indexes\": x} for x in indexes]\n    response = await self._http_requests.post(\"swap-indexes\", processed_indexes)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.transfer_documents","title":"<code>transfer_documents(url, *, api_key=None, payload_size=None, indexes=None)</code>  <code>async</code>","text":"<p>Transfer settings and documents from one Meilisearch instance to another.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Where to send our settings and documents.</p> required <code>api_key</code> <code>str | None</code> <p>The API key with the rights to send the requests. Usually the master key of the remote machine. Defaults to None.</p> <code>None</code> <code>payload_size</code> <code>str | None</code> <p>Human readable size defining the size of the payloads to send. Defaults to 50\u00a0MiB.</p> <code>None</code> <code>indexes</code> <code>JsonMapping | None</code> <p>A set of patterns of matching the indexes you want to export. Defaults to all indexes without filter.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     await index.transfer_documents(     &gt;&gt;&gt;         \"https://another-instance.com\", api_key=\"otherMasterKey\"     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def transfer_documents(  # pragma: no cover\n    self,\n    url: str,\n    *,\n    api_key: str | None = None,\n    payload_size: str | None = None,\n    indexes: JsonMapping | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Transfer settings and documents from one Meilisearch instance to another.\n\n    Args:\n        url: Where to send our settings and documents.\n        api_key: The API key with the rights to send the requests. Usually the master key of\n            the remote machine. Defaults to None.\n        payload_size: Human readable size defining the size of the payloads to send. Defaults\n            to 50\u00a0MiB.\n        indexes: A set of patterns of matching the indexes you want to export. Defaults to all\n            indexes without filter.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await index.transfer_documents(\n        &gt;&gt;&gt;         \"https://another-instance.com\", api_key=\"otherMasterKey\"\n        &gt;&gt;&gt;     )\n    \"\"\"\n    payload: JsonDict = {\"url\": url}\n\n    if api_key:\n        payload[\"apiKey\"] = api_key\n\n    if payload:\n        payload[\"payloadSize\"] = payload_size\n\n    if indexes:\n        payload[\"indexes\"] = indexes\n\n    response = await self._http_requests.post(url, body=payload)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.update_experimental_features","title":"<code>update_experimental_features(features)</code>  <code>async</code>","text":"<p>Update the status of an experimental feature.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>dict[str, bool]</code> <p>Dictionary of features to enable/disable. The dictionary keys can be in either camel case or snake case, the conversion to the correct type will be handed for you by the program. For example {\"logsRoute\": True} and {\"logs_route\": True} will both work.</p> required <p>Returns:</p> Type Description <code>dict[str, bool]</code> <p>The status of the experimental features.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     await index.update_experimental_features({\"logsRoute\": True})</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def update_experimental_features(self, features: dict[str, bool]) -&gt; dict[str, bool]:\n    \"\"\"Update the status of an experimental feature.\n\n    Args:\n        features: Dictionary of features to enable/disable. The dictionary keys can be in either\n            camel case or snake case, the conversion to the correct type will be handed for you by\n            the program. For example {\"logsRoute\": True} and {\"logs_route\": True} will both work.\n\n    Returns:\n        The status of the experimental features.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await index.update_experimental_features({\"logsRoute\": True})\n    \"\"\"\n    payload = dict_to_camel(features)\n    response = await self._http_requests.patch(\"/experimental-features\", body=payload)\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.update_key","title":"<code>update_key(key)</code>  <code>async</code>","text":"<p>Update an API key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>KeyUpdate</code> <p>The information to use in updating the key. Note that if an expires_at value is included it should be in UTC time.</p> required <p>Returns:</p> Type Description <code>Key</code> <p>The updated API key.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     key_info = KeyUpdate(                 key=\"abc123\",     &gt;&gt;&gt;         indexes=[\"*\"],     &gt;&gt;&gt;     )     &gt;&gt;&gt;     keys = await client.update_key(key_info)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def update_key(self, key: KeyUpdate) -&gt; Key:\n    \"\"\"Update an API key.\n\n    Args:\n        key: The information to use in updating the key. Note that if an expires_at value\n            is included it should be in UTC time.\n\n    Returns:\n        The updated API key.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     key_info = KeyUpdate(\n                    key=\"abc123\",\n        &gt;&gt;&gt;         indexes=[\"*\"],\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt;     keys = await client.update_key(key_info)\n    \"\"\"\n    payload = _build_update_key_payload(key, self.json_handler)\n    response = await self._http_requests.patch(f\"keys/{key.key}\", payload)\n\n    return Key(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.update_webhook","title":"<code>update_webhook(*, uuid, webhook)</code>  <code>async</code>","text":"<p>Update an existing webhook.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The webhook's unique identifier.</p> required <code>webhook</code> <code>WebhookUpdate</code> <p>The webhook configuration updates.</p> required <p>Returns:</p> Type Description <code>Webhook</code> <p>The updated webhook.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookUpdate\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     webhook_update = WebhookUpdate(url=\"https://example.com/new-webhook\")\n&gt;&gt;&gt;     webhook = await client.update_webhook(\"abc-123\", webhook_update)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def update_webhook(self, *, uuid: str, webhook: WebhookUpdate) -&gt; Webhook:\n    \"\"\"Update an existing webhook.\n\n    Args:\n        uuid: The webhook's unique identifier.\n        webhook: The webhook configuration updates.\n\n    Returns:\n        The updated webhook.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookUpdate\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     webhook_update = WebhookUpdate(url=\"https://example.com/new-webhook\")\n        &gt;&gt;&gt;     webhook = await client.update_webhook(\"abc-123\", webhook_update)\n    \"\"\"\n    response = await self._http_requests.patch(\n        f\"webhooks/{uuid}\", webhook.model_dump(by_alias=True, exclude_none=True)\n    )\n\n    return Webhook(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.wait_for_task","title":"<code>wait_for_task(task_id, *, timeout_in_ms=5000, interval_in_ms=50, raise_for_status=False)</code>  <code>async</code>","text":"<p>Wait until Meilisearch processes a task, and get its status.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>Identifier of the task to retrieve.</p> required <code>timeout_in_ms</code> <code>int | None</code> <p>Amount of time in milliseconds to wait before raising a MeilisearchTimeoutError. <code>None</code> can also be passed to wait indefinitely. Be aware that if the <code>None</code> option is used the wait time could be very long. Defaults to 5000.</p> <code>5000</code> <code>interval_in_ms</code> <code>int</code> <p>Time interval in milliseconds to sleep between requests. Defaults to 50.</p> <code>50</code> <code>raise_for_status</code> <code>bool</code> <p>When set to <code>True</code> a MeilisearchTaskFailedError will be raised if a task has a failed status. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskResult</code> <p>Details of the processed update status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <code>MeilisearchTaskFailedError</code> <p>If <code>raise_for_status</code> is <code>True</code> and a task has a failed status.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     response = await index.add_documents(documents)     &gt;&gt;&gt;     await client.wait_for_task(client, response.update_id)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def wait_for_task(\n    self,\n    task_id: int,\n    *,\n    timeout_in_ms: int | None = 5000,\n    interval_in_ms: int = 50,\n    raise_for_status: bool = False,\n) -&gt; TaskResult:\n    \"\"\"Wait until Meilisearch processes a task, and get its status.\n\n    Args:\n        task_id: Identifier of the task to retrieve.\n        timeout_in_ms: Amount of time in milliseconds to wait before raising a\n            MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n            if the `None` option is used the wait time could be very long. Defaults to 5000.\n        interval_in_ms: Time interval in milliseconds to sleep between requests. Defaults to 50.\n        raise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n            has a failed status. Defaults to False.\n\n    Returns:\n        Details of the processed update status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n        MeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     response = await index.add_documents(documents)\n        &gt;&gt;&gt;     await client.wait_for_task(client, response.update_id)\n    \"\"\"\n    return await _task.async_wait_for_task(\n        self.http_client,\n        task_id=task_id,\n        timeout_in_ms=timeout_in_ms,\n        interval_in_ms=interval_in_ms,\n        raise_for_status=raise_for_status,\n    )\n</code></pre>"},{"location":"async_index_api/","title":"AsyncIndex","text":""},{"location":"async_index_api/#asyncindex-usage","title":"<code>AsyncIndex</code> Usage","text":"<p>The <code>AsyncIndex</code> is the the same as the <code>Index</code>, but gives asynchronous methods to work with, and and should be used when using the <code>AsyncClient</code>. When you create a new index with the <code>AsyncClient</code> it will create an <code>AsyncIndex</code> instance.</p>"},{"location":"async_index_api/#asyncindex-api","title":"<code>AsyncIndex</code> API","text":"<p>               Bases: <code>BaseIndex</code></p> <p>AsyncIndex class gives access to all indexes routes and child routes.</p> <p>https://docs.meilisearch.com/reference/api/indexes.html</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>class AsyncIndex(BaseIndex):\n    \"\"\"AsyncIndex class gives access to all indexes routes and child routes.\n\n    https://docs.meilisearch.com/reference/api/indexes.html\n    \"\"\"\n\n    def __init__(\n        self,\n        http_client: AsyncClient,\n        uid: str,\n        primary_key: str | None = None,\n        created_at: str | datetime | None = None,\n        updated_at: str | datetime | None = None,\n        plugins: AsyncIndexPlugins | None = None,\n        json_handler: BuiltinHandler | OrjsonHandler | None = None,\n        *,\n        hits_type: type[Any] = JsonDict,\n    ) -&gt; None:\n        \"\"\"Class initializer.\n\n        Args:\n            http_client: An instance of the AsyncClient. This automatically gets passed by the\n                AsyncClient when creating and AsyncIndex instance.\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            created_at: The date and time the index was created. Defaults to None.\n            updated_at: The date and time the index was last updated. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n            json_handler: The module to use for json operations. The options are BuiltinHandler\n                (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n                Note that in order use orjson the corresponding extra needs to be included.\n                Default: BuiltinHandler.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n        \"\"\"\n        super().__init__(\n            uid=uid,\n            primary_key=primary_key,\n            created_at=created_at,\n            updated_at=updated_at,\n            json_handler=json_handler,\n            hits_type=hits_type,\n        )\n        self.http_client = http_client\n        self._http_requests = AsyncHttpRequests(http_client, json_handler=self._json_handler)\n        self.plugins = plugins\n\n    @cached_property\n    def _concurrent_add_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.add_documents_plugins, \"CONCURRENT_EVENT\")\n\n    @cached_property\n    def _post_add_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.add_documents_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_add_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.add_documents_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _concurrent_delete_all_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_all_documents_plugins, \"CONCURRENT_EVENT\")\n\n    @cached_property\n    def _post_delete_all_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_all_documents_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_delete_all_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_all_documents_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _concurrent_delete_document_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_document_plugins, \"CONCURRENT_EVENT\")\n\n    @cached_property\n    def _post_delete_document_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_document_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_delete_document_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_document_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _concurrent_delete_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_plugins, \"CONCURRENT_EVENT\")\n\n    @cached_property\n    def _post_delete_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_delete_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _concurrent_delete_documents_by_filter_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_by_filter_plugins, \"CONCURRENT_EVENT\")\n\n    @cached_property\n    def _post_delete_documents_by_filter_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_by_filter_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_delete_documents_by_filter_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_by_filter_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _concurrent_facet_search_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.facet_search_plugins, \"CONCURRENT_EVENT\")\n\n    @cached_property\n    def _post_facet_search_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.facet_search_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_facet_search_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.facet_search_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _concurrent_search_plugins(self) -&gt; list[AsyncPlugin | AsyncPostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.search_plugins, \"CONCURRENT_EVENT\")\n\n    @cached_property\n    def _post_search_plugins(self) -&gt; list[AsyncPlugin | AsyncPostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.search_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_search_plugins(self) -&gt; list[AsyncPlugin | AsyncPostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.search_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _concurrent_update_documents_plugins(\n        self,\n    ) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.update_documents_plugins, \"CONCURRENT_EVENT\")\n\n    @cached_property\n    def _post_update_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.update_documents_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_update_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.update_documents_plugins, \"PRE_EVENT\")\n\n    async def compact(self) -&gt; TaskInfo:\n        \"\"\"Appends a new task to the queue to compact the database.\n\n        This defragments the LMDB database potentially speeds up indexing and searching.\n        NOTE: This is only available in Meilisearch v1.23.0+\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.compact()\n        \"\"\"\n        response = await self._http_requests.post(f\"{self._base_url_with_uid}/compact\")\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def delete(self) -&gt; TaskInfo:\n        \"\"\"Deletes the index.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete()\n        \"\"\"\n        response = await self._http_requests.delete(self._base_url_with_uid)\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def delete_if_exists(self) -&gt; bool:\n        \"\"\"Delete the index if it already exists.\n\n        Returns:\n            True if the index was deleted or False if not.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_if_exists()\n        \"\"\"\n        response = await self.delete()\n        status = await async_wait_for_task(\n            self.http_client, response.task_uid, timeout_in_ms=100000\n        )\n        if status.status == \"succeeded\":\n            return True\n\n        return False\n\n    async def update(self, primary_key: str) -&gt; Self:\n        \"\"\"Update the index primary key.\n\n        Args:\n            primary_key: The primary key of the documents.\n\n        Returns:\n            An instance of the AsyncIndex with the updated information.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     updated_index = await index.update()\n        \"\"\"\n        payload = {\"primaryKey\": primary_key}\n        response = await self._http_requests.patch(self._base_url_with_uid, payload)\n        await async_wait_for_task(\n            self.http_client,\n            self._http_requests.parse_json(response)[\"taskUid\"],\n            timeout_in_ms=100000,\n        )\n        index_response = await self._http_requests.get(f\"{self._base_url_with_uid}\")\n        self.primary_key = self._http_requests.parse_json(index_response)[\"primaryKey\"]\n        return self\n\n    async def fetch_info(self) -&gt; Self:\n        \"\"\"Gets the information about the index.\n\n        Returns:\n            An instance of the AsyncIndex containing the retrieved information.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index_info = await index.fetch_info()\n        \"\"\"\n        response = await self._http_requests.get(self._base_url_with_uid)\n        index_dict = self._http_requests.parse_json(response)\n        self._set_fetch_info(\n            index_dict[\"primaryKey\"], index_dict[\"createdAt\"], index_dict[\"updatedAt\"]\n        )\n        return self\n\n    async def get_primary_key(self) -&gt; str | None:\n        \"\"\"Get the primary key.\n\n        Returns:\n            The primary key for the documents in the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     primary_key = await index.get_primary_key()\n        \"\"\"\n        info = await self.fetch_info()\n        return info.primary_key\n\n    @classmethod\n    async def create(\n        cls,\n        http_client: AsyncClient,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        settings: MeilisearchSettings | None = None,\n        wait: bool = True,\n        timeout_in_ms: int | None = None,\n        plugins: AsyncIndexPlugins | None = None,\n        json_handler: BuiltinHandler | OrjsonHandler | None = None,\n        hits_type: type[Any] = JsonDict,\n    ) -&gt; Self:\n        \"\"\"Creates a new index.\n\n        In general this method should not be used directly and instead the index should be created\n        through the `Client`.\n\n        Args:\n            http_client: An instance of the AsyncClient. This automatically gets passed by the\n                Client when creating an AsyncIndex instance.\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            settings: Settings for the index. The settings can also be updated independently of\n                creating the index. The advantage to updating them here is updating the settings after\n                adding documents will cause the documents to be re-indexed. Because of this it will be\n                faster to update them before adding documents. Defaults to None (i.e. default\n                Meilisearch index settings).\n            wait: If set to True and settings are being updated, the index will be returned after\n                the settings update has completed. If False it will not wait for settings to complete.\n                Default: True\n            timeout_in_ms: Amount of time in milliseconds to wait before raising a\n                MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n                if the `None` option is used the wait time could be very long. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n            json_handler: The module to use for json operations. The options are BuiltinHandler\n                (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n                Note that in order use orjson the corresponding extra needs to be included.\n                Default: BuiltinHandler.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n\n        Returns:\n            An instance of AsyncIndex containing the information of the newly created index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await index.create(client, \"movies\")\n        \"\"\"\n        if not primary_key:\n            payload = {\"uid\": uid}\n        else:\n            payload = {\"primaryKey\": primary_key, \"uid\": uid}\n\n        url = \"indexes\"\n        handler = json_handler if json_handler else BuiltinHandler()\n        http_request = AsyncHttpRequests(http_client, json_handler=handler)\n        response = await http_request.post(url, payload)\n        await async_wait_for_task(\n            http_client,\n            http_request.parse_json(response)[\"taskUid\"],\n            timeout_in_ms=timeout_in_ms,\n        )\n\n        index_response = await http_request.get(f\"{url}/{uid}\")\n        index_dict = http_request.parse_json(index_response)\n        index = cls(\n            http_client=http_client,\n            uid=index_dict[\"uid\"],\n            primary_key=index_dict[\"primaryKey\"],\n            created_at=index_dict[\"createdAt\"],\n            updated_at=index_dict[\"updatedAt\"],\n            plugins=plugins,\n            json_handler=json_handler,\n            hits_type=hits_type,\n        )\n\n        if settings:\n            settings_task = await index.update_settings(settings)\n            if wait:\n                await async_wait_for_task(\n                    http_client, settings_task.task_uid, timeout_in_ms=timeout_in_ms\n                )\n\n        return index\n\n    async def get_stats(self) -&gt; IndexStats:\n        \"\"\"Get stats of the index.\n\n        Returns:\n            Stats of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     stats = await index.get_stats()\n        \"\"\"\n        response = await self._http_requests.get(self._stats_url)\n\n        return IndexStats(**self._http_requests.parse_json(response))\n\n    async def search(\n        self,\n        query: str | None = None,\n        *,\n        offset: int = 0,\n        limit: int = 20,\n        filter: Filter | None = None,\n        facets: list[str] | None = None,\n        attributes_to_retrieve: list[str] | None = None,\n        attributes_to_crop: list[str] | None = None,\n        crop_length: int = 200,\n        attributes_to_highlight: list[str] | None = None,\n        sort: list[str] | None = None,\n        show_matches_position: bool = False,\n        highlight_pre_tag: str = \"&lt;em&gt;\",\n        highlight_post_tag: str = \"&lt;/em&gt;\",\n        crop_marker: str = \"...\",\n        matching_strategy: Literal[\"all\", \"last\", \"frequency\"] = \"last\",\n        hits_per_page: int | None = None,\n        page: int | None = None,\n        attributes_to_search_on: list[str] | None = None,\n        distinct: str | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        ranking_score_threshold: float | None = None,\n        vector: list[float] | None = None,\n        hybrid: Hybrid | None = None,\n        locales: list[str] | None = None,\n        retrieve_vectors: bool | None = None,\n        media: JsonMapping | None = None,\n        show_performance_details: bool = False,\n    ) -&gt; SearchResults:\n        \"\"\"Search the index.\n\n        Args:\n            query: String containing the word(s) to search\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            facets: Facets for which to retrieve the matching count. Defaults to None.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n            crop_length: The maximum number of words to display. Defaults to 200.\n            attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n                Defaults to None.\n            sort: Attributes by which to sort the results. Defaults to None.\n            show_matches_position: Defines whether an object that contains information about the\n                matches should be returned or not. Defaults to False.\n            highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n            highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n            crop_marker: Marker to display when the number of words exceeds the `crop_length`.\n                Defaults to ...\n            matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to\n                `last`.\n            hits_per_page: Sets the number of results returned per page.\n            page: Sets the specific results page to fetch.\n            attributes_to_search_on: List of field names. Allow search over a subset of searchable\n                attributes without modifying the index settings. Defaults to None.\n            distinct: If set the distinct value will return at most one result for the\n                filterable attribute. Note that a filterable attributes must be set for this work.\n                Defaults to None.\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n                to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n                sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n                Because this feature is experimental it may be removed or updated causing breaking\n                changes in this library without a major version bump so use with caution. This\n                feature became stable in Meiliseach v1.7.0.\n            ranking_score_threshold: If set, no document whose _rankingScore is under the\n                rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n                to None.\n            vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n                In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n            hybrid: Hybrid search information. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n                In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n            locales: Specifies the languages for the search. This parameter can only be used with\n                Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.\n            retrieve_vectors: Return document vector data with search result.\n            media: The content of media is used as if it were a document to generate request\n                fragments from the searchFragments parameter. Defaults to None. This parameter can\n                only be used with Meilisearch &gt;= v1.16.0. In order to use this feature in\n                Meilisearch v1.16.0 you first need to enable the feature by sending a PATCH request\n                to /experimental-features with { \"multimodal\": true }. Because this feature is\n                experimental it may be removed or updated causing breaking changes in this library\n                without a major version bump so use with caution.\n            show_performance_details: When set to true, the search response contains a performance\n                trace. Default False.\n\n        Returns:\n            Results of the search\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_results = await index.search(\"Tron\")\n        \"\"\"\n        if ranking_score_threshold:\n            validate_ranking_score_threshold(ranking_score_threshold)\n\n        body = process_search_parameters(\n            q=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            distinct=distinct,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n            hybrid=hybrid,\n            ranking_score_threshold=ranking_score_threshold,\n            locales=locales,\n            retrieve_vectors=retrieve_vectors,\n            media=media,\n            show_performance_details=show_performance_details,\n        )\n        search_url = f\"{self._base_url_with_uid}/search\"\n\n        if self._pre_search_plugins:\n            await _run_plugins(\n                self._pre_search_plugins,\n                AsyncEvent.PRE,\n                query=query,\n                offset=offset,\n                limit=limit,\n                filter=filter,\n                facets=facets,\n                attributes_to_retrieve=attributes_to_retrieve,\n                attributes_to_crop=attributes_to_crop,\n                crop_length=crop_length,\n                attributes_to_highlight=attributes_to_highlight,\n                sort=sort,\n                show_matches_position=show_matches_position,\n                highlight_pre_tag=highlight_pre_tag,\n                highlight_post_tag=highlight_post_tag,\n                crop_marker=crop_marker,\n                matching_strategy=matching_strategy,\n                hits_per_page=hits_per_page,\n                page=page,\n                attributes_to_search_on=attributes_to_search_on,\n                distinct=distinct,\n                show_ranking_score=show_ranking_score,\n                show_ranking_score_details=show_ranking_score_details,\n                vector=vector,\n                hybrid=hybrid,\n            )\n\n        if self._concurrent_search_plugins:\n            if not use_task_groups():\n                concurrent_tasks: Any = []\n                for plugin in self._concurrent_search_plugins:\n                    if plugin_has_method(plugin, \"run_plugin\"):\n                        concurrent_tasks.append(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                query=query,\n                                offset=offset,\n                                limit=limit,\n                                filter=filter,\n                                facets=facets,\n                                attributes_to_retrieve=attributes_to_retrieve,\n                                attributes_to_crop=attributes_to_crop,\n                                crop_length=crop_length,\n                                attributes_to_highlight=attributes_to_highlight,\n                                sort=sort,\n                                show_matches_position=show_matches_position,\n                                highlight_pre_tag=highlight_pre_tag,\n                                highlight_post_tag=highlight_post_tag,\n                                crop_marker=crop_marker,\n                                matching_strategy=matching_strategy,\n                                hits_per_page=hits_per_page,\n                                page=page,\n                                attributes_to_search_on=attributes_to_search_on,\n                                distinct=distinct,\n                                show_ranking_score=show_ranking_score,\n                                show_ranking_score_details=show_ranking_score_details,\n                                vector=vector,\n                            )\n                        )\n\n                concurrent_tasks.append(self._http_requests.post(search_url, body=body))\n\n                responses = await asyncio.gather(*concurrent_tasks)\n                result = SearchResults[self.hits_type](**responses[-1].json())  # type: ignore[name-defined]\n                if self._post_search_plugins:\n                    post = await _run_plugins(\n                        self._post_search_plugins, AsyncEvent.POST, search_results=result\n                    )\n                    if post.get(\"search_result\"):\n                        result = post[\"search_result\"]\n\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_search_plugins:\n                    if plugin_has_method(plugin, \"run_plugin\"):\n                        tg.create_task(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                query=query,\n                                offset=offset,\n                                limit=limit,\n                                filter=filter,\n                                facets=facets,\n                                attributes_to_retrieve=attributes_to_retrieve,\n                                attributes_to_crop=attributes_to_crop,\n                                crop_length=crop_length,\n                                attributes_to_highlight=attributes_to_highlight,\n                                sort=sort,\n                                show_matches_position=show_matches_position,\n                                highlight_pre_tag=highlight_pre_tag,\n                                highlight_post_tag=highlight_post_tag,\n                                crop_marker=crop_marker,\n                                matching_strategy=matching_strategy,\n                                hits_per_page=hits_per_page,\n                                page=page,\n                                attributes_to_search_on=attributes_to_search_on,\n                                distinct=distinct,\n                                show_ranking_score=show_ranking_score,\n                                show_ranking_score_details=show_ranking_score_details,\n                                vector=vector,\n                            )\n                        )\n\n                response_coroutine = tg.create_task(self._http_requests.post(search_url, body=body))\n\n            response = await response_coroutine\n            result = SearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n            if self._post_search_plugins:\n                post = await _run_plugins(\n                    self._post_search_plugins, AsyncEvent.POST, search_results=result\n                )\n                if post.get(\"search_result\"):\n                    result = post[\"search_result\"]\n\n            return result\n\n        response = await self._http_requests.post(search_url, body=body)\n        result = SearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n\n        if self._post_search_plugins:\n            post = await _run_plugins(\n                self._post_search_plugins, AsyncEvent.POST, search_results=result\n            )\n            if post.get(\"search_result\"):\n                result = post[\"search_result\"]\n\n        return result\n\n    async def facet_search(\n        self,\n        query: str | None = None,\n        *,\n        facet_name: str,\n        facet_query: str,\n        offset: int = 0,\n        limit: int = 20,\n        filter: Filter | None = None,\n        facets: list[str] | None = None,\n        attributes_to_retrieve: list[str] | None = None,\n        attributes_to_crop: list[str] | None = None,\n        crop_length: int = 200,\n        attributes_to_highlight: list[str] | None = None,\n        sort: list[str] | None = None,\n        show_matches_position: bool = False,\n        highlight_pre_tag: str = \"&lt;em&gt;\",\n        highlight_post_tag: str = \"&lt;/em&gt;\",\n        crop_marker: str = \"...\",\n        matching_strategy: Literal[\"all\", \"last\", \"frequency\"] = \"last\",\n        hits_per_page: int | None = None,\n        page: int | None = None,\n        attributes_to_search_on: list[str] | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        ranking_score_threshold: float | None = None,\n        vector: list[float] | None = None,\n        locales: list[str] | None = None,\n        retrieve_vectors: bool | None = None,\n        exhaustive_facet_count: bool | None = None,\n    ) -&gt; FacetSearchResults:\n        \"\"\"Search the index.\n\n        Args:\n            query: String containing the word(s) to search\n            facet_name: The name of the facet to search\n            facet_query: The facet search value\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            facets: Facets for which to retrieve the matching count. Defaults to None.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n            crop_length: The maximum number of words to display. Defaults to 200.\n            attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n                Defaults to None.\n            sort: Attributes by which to sort the results. Defaults to None.\n            show_matches_position: Defines whether an object that contains information about the\n                matches should be returned or not. Defaults to False.\n            highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n            highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n            crop_marker: Marker to display when the number of words exceeds the `crop_length`.\n                Defaults to ...\n            matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to\n                `last`.\n            hits_per_page: Sets the number of results returned per page.\n            page: Sets the specific results page to fetch.\n            attributes_to_search_on: List of field names. Allow search over a subset of searchable\n                attributes without modifying the index settings. Defaults to None.\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n                to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n                sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n                Because this feature is experimental it may be removed or updated causing breaking\n                changes in this library without a major version bump so use with caution. This\n                feature became stable in Meiliseach v1.7.0.\n            ranking_score_threshold: If set, no document whose _rankingScore is under the\n                rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n                to None.\n            vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n                In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n            locales: Specifies the languages for the search. This parameter can only be used with\n                Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.\n            retrieve_vectors: Return document vector data with search result.\n            exhaustive_facet_count: forcing the facet search to compute the facet counts the same\n                way as the paginated search. This parameter can only be used with Milisearch &gt;=\n                v1.14.0. Defaults to None.\n\n        Returns:\n            Results of the search\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_results = await index.search(\n            &gt;&gt;&gt;         \"Tron\",\n            &gt;&gt;&gt;         facet_name=\"genre\",\n            &gt;&gt;&gt;         facet_query=\"Sci-fi\"\n            &gt;&gt;&gt;     )\n        \"\"\"\n        if ranking_score_threshold:\n            validate_ranking_score_threshold(ranking_score_threshold)\n\n        body = process_search_parameters(\n            q=query,\n            facet_name=facet_name,\n            facet_query=facet_query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            ranking_score_threshold=ranking_score_threshold,\n            vector=vector,\n            locales=locales,\n            retrieve_vectors=retrieve_vectors,\n            exhaustive_facet_count=exhaustive_facet_count,\n        )\n        search_url = f\"{self._base_url_with_uid}/facet-search\"\n\n        if self._pre_facet_search_plugins:\n            await _run_plugins(\n                self._pre_facet_search_plugins,\n                AsyncEvent.PRE,\n                query=query,\n                offset=offset,\n                limit=limit,\n                filter=filter,\n                facets=facets,\n                attributes_to_retrieve=attributes_to_retrieve,\n                attributes_to_crop=attributes_to_crop,\n                crop_length=crop_length,\n                attributes_to_highlight=attributes_to_highlight,\n                sort=sort,\n                show_matches_position=show_matches_position,\n                highlight_pre_tag=highlight_pre_tag,\n                highlight_post_tag=highlight_post_tag,\n                crop_marker=crop_marker,\n                matching_strategy=matching_strategy,\n                hits_per_page=hits_per_page,\n                page=page,\n                attributes_to_search_on=attributes_to_search_on,\n                show_ranking_score=show_ranking_score,\n                show_ranking_score_details=show_ranking_score_details,\n                ranking_score_threshold=ranking_score_threshold,\n                vector=vector,\n                exhaustive_facet_count=exhaustive_facet_count,\n            )\n\n        if self._concurrent_facet_search_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_facet_search_plugins:\n                    if plugin_has_method(plugin, \"run_plugin\"):\n                        tasks.append(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                query=query,\n                                offset=offset,\n                                limit=limit,\n                                filter=filter,\n                                facets=facets,\n                                attributes_to_retrieve=attributes_to_retrieve,\n                                attributes_to_crop=attributes_to_crop,\n                                crop_length=crop_length,\n                                attributes_to_highlight=attributes_to_highlight,\n                                sort=sort,\n                                show_matches_position=show_matches_position,\n                                highlight_pre_tag=highlight_pre_tag,\n                                highlight_post_tag=highlight_post_tag,\n                                crop_marker=crop_marker,\n                                matching_strategy=matching_strategy,\n                                hits_per_page=hits_per_page,\n                                page=page,\n                                attributes_to_search_on=attributes_to_search_on,\n                                show_ranking_score=show_ranking_score,\n                                show_ranking_score_details=show_ranking_score_details,\n                                ranking_score_threshold=ranking_score_threshold,\n                                vector=vector,\n                                exhaustive_facet_count=exhaustive_facet_count,\n                            )\n                        )\n\n                tasks.append(self._http_requests.post(search_url, body=body))\n                responses = await asyncio.gather(*tasks)\n                result = FacetSearchResults(**responses[-1].json())\n                if self._post_facet_search_plugins:\n                    post = await _run_plugins(\n                        self._post_facet_search_plugins, AsyncEvent.POST, result=result\n                    )\n                    if isinstance(post[\"generic_result\"], FacetSearchResults):\n                        result = post[\"generic_result\"]\n\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_facet_search_plugins:\n                    if plugin_has_method(plugin, \"run_plugin\"):\n                        tg.create_task(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                query=query,\n                                offset=offset,\n                                limit=limit,\n                                filter=filter,\n                                facets=facets,\n                                attributes_to_retrieve=attributes_to_retrieve,\n                                attributes_to_crop=attributes_to_crop,\n                                crop_length=crop_length,\n                                attributes_to_highlight=attributes_to_highlight,\n                                sort=sort,\n                                show_matches_position=show_matches_position,\n                                highlight_pre_tag=highlight_pre_tag,\n                                highlight_post_tag=highlight_post_tag,\n                                crop_marker=crop_marker,\n                                matching_strategy=matching_strategy,\n                                hits_per_page=hits_per_page,\n                                page=page,\n                                attributes_to_search_on=attributes_to_search_on,\n                                show_ranking_score=show_ranking_score,\n                                show_ranking_score_details=show_ranking_score_details,\n                                ranking_score_threshold=ranking_score_threshold,\n                                vector=vector,\n                                exhaustive_facet_count=exhaustive_facet_count,\n                            )\n                        )\n\n                response_coroutine = tg.create_task(self._http_requests.post(search_url, body=body))\n\n            response = await response_coroutine\n            result = FacetSearchResults(**self._http_requests.parse_json(response))\n            if self._post_facet_search_plugins:\n                post = await _run_plugins(\n                    self._post_facet_search_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], FacetSearchResults):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        response = await self._http_requests.post(search_url, body=body)\n        result = FacetSearchResults(**self._http_requests.parse_json(response))\n        if self._post_facet_search_plugins:\n            post = await _run_plugins(\n                self._post_facet_search_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], FacetSearchResults):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def search_similar_documents(\n        self,\n        id: str,\n        *,\n        offset: int | None = None,\n        limit: int | None = None,\n        filter: str | None = None,\n        embedder: str = \"default\",\n        attributes_to_retrieve: list[str] | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        ranking_score_threshold: float | None = None,\n    ) -&gt; SimilarSearchResults:\n        \"\"\"Search the index.\n\n        Args:\n            id: The id for the target document that is being used to find similar documents.\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            embedder: The vector DB to use for the search.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False.\n            ranking_score_threshold: If set, no document whose _rankingScore is under the\n                rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n                to None.\n\n        Returns:\n            Results of the search\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_results = await index.search_similar_documents(\"123\")\n        \"\"\"\n        payload = {\n            \"id\": id,\n            \"filter\": filter,\n            \"embedder\": embedder,\n            \"attributesToRetrieve\": attributes_to_retrieve,\n            \"showRankingScore\": show_ranking_score,\n            \"showRankingScoreDetails\": show_ranking_score_details,\n            \"rankingScoreThreshold\": ranking_score_threshold,\n        }\n\n        if offset:\n            payload[\"offset\"] = offset\n\n        if limit:\n            payload[\"limit\"] = limit\n\n        response = await self._http_requests.post(\n            f\"{self._base_url_with_uid}/similar\", body=payload\n        )\n\n        return SimilarSearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n\n    async def get_document(\n        self,\n        document_id: str,\n        *,\n        fields: list[str] | None = None,\n        retrieve_vectors: bool = False,\n    ) -&gt; JsonDict:\n        \"\"\"Get one document with given document identifier.\n\n        Args:\n            document_id: Unique identifier of the document.\n            fields: Document attributes to show. If this value is None then all\n                attributes are retrieved. Defaults to None.\n            retrieve_vectors: If set to True the embedding vectors will be returned with the document.\n                Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.13.0\n        Returns:\n            The document information\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     document = await index.get_document(\"1234\")\n        \"\"\"\n        parameters: JsonDict = {}\n\n        if fields:\n            parameters[\"fields\"] = \",\".join(fields)\n        if retrieve_vectors:\n            parameters[\"retrieveVectors\"] = \"true\"\n\n        url = build_encoded_url(f\"{self._documents_url}/{document_id}\", parameters)\n\n        response = await self._http_requests.get(url)\n\n        return self._http_requests.parse_json(response)\n\n    async def get_documents(\n        self,\n        *,\n        ids: list[str] | None = None,\n        offset: int = 0,\n        limit: int = 20,\n        fields: list[str] | None = None,\n        filter: Filter | None = None,\n        retrieve_vectors: bool = False,\n        sort: str | None = None,\n    ) -&gt; DocumentsInfo:\n        \"\"\"Get a batch documents from the index.\n\n        Args:\n            ids: Array of document primary keys to retrieve. Defaults to None (Gets all documents).\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returnedd. Defaults to 20.\n            fields: Document attributes to show. If this value is None then all\n                attributes are retrieved. Defaults to None.\n            filter: Filter value information. Defaults to None. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.2.0\n            retrieve_vectors: If set to True the vectors will be returned with each document.\n                Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.13.0\n            sort: Attribute by which to sort the results. Defaults to None.\n\n        Returns:\n            Documents info.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     documents = await index.get_documents()\n        \"\"\"\n        parameters: JsonDict = {\n            \"offset\": offset,\n            \"limit\": limit,\n        }\n\n        if sort:\n            parameters[\"sort\"] = sort\n\n        if not filter and not ids:\n            if retrieve_vectors:\n                parameters[\"retrieveVectors\"] = \"true\"\n            if fields:\n                parameters[\"fields\"] = \",\".join(fields)\n\n            url = build_encoded_url(self._documents_url, parameters)\n            response = await self._http_requests.get(url)\n\n            return DocumentsInfo(**self._http_requests.parse_json(response))\n\n        if retrieve_vectors:\n            parameters[\"retrieveVectors\"] = True\n\n        if fields:\n            parameters[\"fields\"] = fields\n\n        parameters[\"filter\"] = filter\n\n        if ids:\n            parameters[\"ids\"] = ids\n\n        response = await self._http_requests.post(f\"{self._documents_url}/fetch\", body=parameters)\n\n        return DocumentsInfo(**self._http_requests.parse_json(response))\n\n    async def add_documents(\n        self,\n        documents: Sequence[JsonMapping],\n        primary_key: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents to the index.\n\n        Args:\n            documents: List of documents.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents(documents)\n        \"\"\"\n        params = {}\n\n        if primary_key:\n            params[\"primaryKey\"] = primary_key\n\n        if custom_metadata:\n            params[\"customMetadata\"] = custom_metadata\n\n        if params:\n            url = build_encoded_url(self._documents_url, params)\n        else:\n            url = self._documents_url\n\n        if self._pre_add_documents_plugins:\n            pre = await _run_plugins(\n                self._pre_add_documents_plugins,\n                AsyncEvent.PRE,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if pre.get(\"document_result\"):\n                documents = pre[\"document_result\"]\n\n        if self._concurrent_add_documents_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_add_documents_plugins:\n                    if plugin_has_method(plugin, \"run_plugin\"):\n                        tasks.append(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n                    if plugin_has_method(plugin, \"run_document_plugin\"):\n                        tasks.append(\n                            plugin.run_document_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n\n                tasks.append(self._http_requests.post(url, documents, compress=compress))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_add_documents_plugins:\n                    post = await _run_plugins(\n                        self._post_add_documents_plugins,\n                        AsyncEvent.POST,\n                        result=result,\n                        documents=documents,\n                        primary_key=primary_key,\n                    )\n                    if isinstance(post[\"generic_result\"], TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_add_documents_plugins:\n                    if plugin_has_method(plugin, \"run_plugin\"):\n                        tg.create_task(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n                    if plugin_has_method(plugin, \"run_document_plugin\"):\n                        tg.create_task(\n                            plugin.run_document_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n\n                response_coroutine = tg.create_task(\n                    self._http_requests.post(url, documents, compress=compress)\n                )\n\n            response = await response_coroutine\n            result = TaskInfo(**self._http_requests.parse_json(response))\n            if self._post_add_documents_plugins:\n                post = await _run_plugins(\n                    self._post_add_documents_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                    documents=documents,\n                    primary_key=primary_key,\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        response = await self._http_requests.post(url, documents, compress=compress)\n\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_add_documents_plugins:\n            post = await _run_plugins(\n                self._post_add_documents_plugins,\n                AsyncEvent.POST,\n                result=result,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def add_documents_in_batches(\n        self,\n        documents: Sequence[JsonMapping],\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        compress: bool = False,\n        concurrency_limit: int | None = None,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Adds documents in batches to reduce RAM usage with indexing.\n\n        Args:\n            documents: List of documents.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n            concurrency_limit: If set this will limit the number of batches that will be sent\n                concurrently. This can be helpful if you find you are overloading the Meilisearch\n                server with requests. Defaults to None.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_in_batches(documents)\n        \"\"\"\n        if concurrency_limit:\n            semaphore = asyncio.Semaphore(concurrency_limit)\n\n            async def add_batch_with_limit(batch_data: Sequence[JsonMapping]) -&gt; TaskInfo:\n                async with semaphore:\n                    return await self.add_documents(\n                        batch_data, primary_key, custom_metadata=custom_metadata, compress=compress\n                    )\n\n            if not use_task_groups():\n                batches = [add_batch_with_limit(data) for data in batch(documents, batch_size)]\n                return await asyncio.gather(*batches)\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                tasks = [\n                    tg.create_task(add_batch_with_limit(x)) for x in batch(documents, batch_size)\n                ]\n\n            return [x.result() for x in tasks]\n\n        if not use_task_groups():\n            batches = [\n                self.add_documents(\n                    x, primary_key, custom_metadata=custom_metadata, compress=compress\n                )\n                for x in batch(documents, batch_size)\n            ]\n            return await asyncio.gather(*batches)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = [\n                tg.create_task(\n                    self.add_documents(\n                        x, primary_key, custom_metadata=custom_metadata, compress=compress\n                    )\n                )\n                for x in batch(documents, batch_size)\n            ]\n\n        return [x.result() for x in tasks]\n\n    async def add_documents_from_directory(\n        self,\n        directory_path: Path | str,\n        *,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n        concurrency_limit: int | None = None,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and add the documents to the index.\n\n        Args:\n            directory_path: Path to the directory that contains the json files.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row\n                containing the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n            concurrency_limit: If set this will limit the number of batches that will be sent\n                concurrently. This can be helpful if you find you are overloading the Meilisearch\n                server with requests. Defaults to None.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_directory(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    all_documents.append(documents)\n\n            raise_on_no_documents(all_documents, document_type, directory_path)\n\n            loop = asyncio.get_running_loop()\n            combined = await loop.run_in_executor(None, partial(combine_documents_, all_documents))\n\n            response = await self.add_documents(\n                combined, primary_key, custom_metadata=custom_metadata, compress=compress\n            )\n\n            return [response]\n\n        if concurrency_limit:\n            semaphore = asyncio.Semaphore(concurrency_limit)\n\n            async def add_docs_with_limit(docs: Sequence[JsonMapping]) -&gt; TaskInfo:\n                async with semaphore:\n                    return await self.add_documents(\n                        docs,\n                        primary_key,\n                        custom_metadata=custom_metadata,\n                        compress=compress,\n                    )\n\n            if not use_task_groups():\n                add_documents = []\n                for path in directory.iterdir():\n                    if path.suffix == f\".{document_type}\":\n                        documents = await _async_load_documents_from_file(\n                            path, csv_delimiter, json_handler=self._json_handler\n                        )\n                        add_documents.append(add_docs_with_limit(documents))\n\n                raise_on_no_documents(add_documents, document_type, directory_path)\n\n                if len(add_documents) &gt; 1:\n                    # Send the first document on its own before starting the gather. Otherwise Meilisearch\n                    # returns an error because it thinks all entries are trying to create the same index.\n                    first_response = [await add_documents.pop(0)]\n\n                    responses = await asyncio.gather(*add_documents)\n                    responses = [*first_response, *responses]\n                else:\n                    responses = [await add_documents[0]]\n\n                return responses\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                tasks = []\n                all_results = []\n                for i, path in enumerate(directory.iterdir()):\n                    if path.suffix == f\".{document_type}\":\n                        documents = await _async_load_documents_from_file(\n                            path, csv_delimiter, json_handler=self._json_handler\n                        )\n                        if i == 0:\n                            all_results = [await add_docs_with_limit(documents)]\n                        else:\n                            tasks.append(tg.create_task(add_docs_with_limit(documents)))\n\n            return [*all_results, *[x.result() for x in tasks]]\n\n        if not use_task_groups():\n            add_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    add_documents.append(\n                        self.add_documents(\n                            documents,\n                            primary_key,\n                            custom_metadata=custom_metadata,\n                            compress=compress,\n                        )\n                    )\n\n            raise_on_no_documents(add_documents, document_type, directory_path)\n\n            if len(add_documents) &gt; 1:\n                # Send the first document on its own before starting the gather. Otherwise Meilisearch\n                # returns an error because it thinks all entries are trying to create the same index.\n                first_response = [await add_documents.pop()]\n\n                responses = await asyncio.gather(*add_documents)\n                responses = [*first_response, *responses]\n            else:\n                responses = [await add_documents[0]]\n\n            return responses\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = []\n            all_results = []\n            for i, path in enumerate(directory.iterdir()):\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    if i == 0:\n                        all_results = [\n                            await self.add_documents(\n                                documents,\n                                primary_key=primary_key,\n                                custom_metadata=custom_metadata,\n                                compress=compress,\n                            )\n                        ]\n                    else:\n                        tasks.append(\n                            tg.create_task(\n                                self.add_documents(\n                                    documents,\n                                    primary_key,\n                                    custom_metadata=custom_metadata,\n                                    compress=compress,\n                                )\n                            )\n                        )\n\n        results = [x.result() for x in tasks]\n        all_results = [*all_results, *results]\n        raise_on_no_documents(all_results, document_type, directory_path)\n        return all_results\n\n    async def add_documents_from_directory_in_batches(\n        self,\n        directory_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n        concurrency_limit: int | None = None,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and add the documents to the index in batches.\n\n        Args:\n            directory_path: Path to the directory that contains the json files.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row containing\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n            concurrency_limit: If set this will limit the number of batches that will be sent\n                concurrently. This can be helpful if you find you are overloading the Meilisearch\n                server with requests. Defaults to None.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_directory_in_batches(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter=csv_delimiter, json_handler=self._json_handler\n                    )\n                    all_documents.append(documents)\n\n            raise_on_no_documents(all_documents, document_type, directory_path)\n\n            loop = asyncio.get_running_loop()\n            combined = await loop.run_in_executor(None, partial(combine_documents_, all_documents))\n\n            return await self.add_documents_in_batches(\n                combined,\n                batch_size=batch_size,\n                primary_key=primary_key,\n                custom_metadata=custom_metadata,\n                compress=compress,\n                concurrency_limit=concurrency_limit,\n            )\n\n        responses: list[TaskInfo] = []\n\n        add_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                add_documents.append(\n                    self.add_documents_in_batches(\n                        documents,\n                        batch_size=batch_size,\n                        primary_key=primary_key,\n                        custom_metadata=custom_metadata,\n                        compress=compress,\n                        concurrency_limit=concurrency_limit,\n                    )\n                )\n\n        raise_on_no_documents(add_documents, document_type, directory_path)\n\n        if len(add_documents) &gt; 1:\n            # Send the first document on its own before starting the gather. Otherwise Meilisearch\n            # returns an error because it thinks all entries are trying to create the same index.\n            first_response = await add_documents.pop()\n            responses_gather = await asyncio.gather(*add_documents)\n            responses = [*first_response, *[x for y in responses_gather for x in y]]\n        else:\n            responses = await add_documents[0]\n\n        return responses\n\n    async def add_documents_from_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents to the index from a json file.\n\n        Args:\n            file_path: Path to the json file.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_file(file_path)\n        \"\"\"\n        documents = await _async_load_documents_from_file(\n            file_path, json_handler=self._json_handler\n        )\n\n        return await self.add_documents(\n            documents, primary_key=primary_key, custom_metadata=custom_metadata, compress=compress\n        )\n\n    async def add_documents_from_file_in_batches(\n        self,\n        file_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        csv_delimiter: str | None = None,\n        compress: bool = False,\n        concurrency_limit: int | None = None,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Adds documents form a json file in batches to reduce RAM usage with indexing.\n\n        Args:\n            file_path: Path to the json file.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n            concurrency_limit: If set this will limit the number of batches that will be sent\n                concurrently. This can be helpful if you find you are overloading the Meilisearch\n                server with requests. Defaults to None.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_file_in_batches(file_path)\n        \"\"\"\n        documents = await _async_load_documents_from_file(\n            file_path, csv_delimiter, json_handler=self._json_handler\n        )\n\n        return await self.add_documents_in_batches(\n            documents,\n            batch_size=batch_size,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            compress=compress,\n            concurrency_limit=concurrency_limit,\n        )\n\n    async def add_documents_from_raw_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        csv_delimiter: str | None = None,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n        The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n        for batching.\n\n        Args:\n            file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n                allowed.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n                a non-csv file.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_raw_file(file_path)\n        \"\"\"\n        upload_path, content_type = prepare_raw_file_upload(file_path, csv_delimiter)\n        parameters = {}\n\n        if primary_key:\n            parameters[\"primaryKey\"] = primary_key\n        if csv_delimiter:\n            parameters[\"csvDelimiter\"] = csv_delimiter\n        if custom_metadata:\n            parameters[\"customMetadata\"] = custom_metadata\n\n        if parameters:\n            url = build_encoded_url(self._documents_url, parameters)\n        else:\n            url = self._documents_url\n\n        async with aiofiles.open(upload_path) as f:\n            data = await f.read()\n\n        response = await self._http_requests.post(\n            url, body=data, content_type=content_type, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def edit_documents(\n        self,\n        function: str,\n        *,\n        context: JsonDict | None = None,\n        filter: str | None = None,\n        custom_metadata: str | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Edit documents with a function.\n\n        Edit documents is only available in Meilisearch &gt;= v1.10.0, and is experimental in\n        Meilisearch v1.10.0. In order to use this feature you first need to enable it by\n        sending a PATCH request to /experimental-features with { \"editDocumentsByFunction\": true }.\n\n        Args:\n            function: Rhai function to use to update the documents.\n            context: Parameters to use in the function. Defaults to None.\n            filter: Filter the documents before applying the function. Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.edit_documents(\"doc.title = `${doc.title.to_upper()}`\")\n        \"\"\"\n        url = f\"{self._documents_url}/edit\"\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        payload: JsonDict = {\"function\": function}\n\n        if context:\n            payload[\"context\"] = context\n\n        if filter:\n            payload[\"filter\"] = filter\n\n        response = await self._http_requests.post(url, payload)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def update_documents(\n        self,\n        documents: Sequence[JsonMapping],\n        primary_key: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Update documents in the index.\n\n        Args:\n            documents: List of documents.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents(documents)\n        \"\"\"\n        params = {}\n        if primary_key:\n            params[\"primaryKey\"] = primary_key\n        if custom_metadata:\n            params[\"customMetadata\"] = custom_metadata\n        if skip_creation:\n            params[\"skipCreation\"] = \"true\"\n\n        if params:\n            url = build_encoded_url(self._documents_url, params)\n        else:\n            url = self._documents_url\n\n        if self._pre_update_documents_plugins:\n            pre = await _run_plugins(\n                self._pre_update_documents_plugins,\n                AsyncEvent.PRE,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if pre.get(\"document_result\"):\n                documents = pre[\"document_result\"]\n\n        if self._concurrent_update_documents_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_update_documents_plugins:\n                    if plugin_has_method(plugin, \"run_plugin\"):\n                        tasks.append(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n                    if plugin_has_method(plugin, \"run_document_plugin\"):\n                        tasks.append(\n                            plugin.run_document_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n\n                tasks.append(self._http_requests.put(url, documents, compress=compress))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_update_documents_plugins:\n                    post = await _run_plugins(\n                        self._post_update_documents_plugins,\n                        AsyncEvent.POST,\n                        result=result,\n                        documents=documents,\n                        primary_key=primary_key,\n                    )\n                    if isinstance(post[\"generic_result\"], TaskInfo):\n                        result = post[\"generic_result\"]\n\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_update_documents_plugins:\n                    if plugin_has_method(plugin, \"run_plugin\"):\n                        tg.create_task(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n                    if plugin_has_method(plugin, \"run_document_plugin\"):\n                        tg.create_task(\n                            plugin.run_document_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n\n                response_coroutine = tg.create_task(\n                    self._http_requests.put(url, documents, compress=compress)\n                )\n\n            response = await response_coroutine\n            result = TaskInfo(**self._http_requests.parse_json(response))\n            if self._post_update_documents_plugins:\n                post = await _run_plugins(\n                    self._post_update_documents_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                    documents=documents,\n                    primary_key=primary_key,\n                )\n\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        response = await self._http_requests.put(url, documents, compress=compress)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_update_documents_plugins:\n            post = await _run_plugins(\n                self._post_update_documents_plugins,\n                AsyncEvent.POST,\n                result=result,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def update_documents_in_batches(\n        self,\n        documents: Sequence[JsonMapping],\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        compress: bool = False,\n        skip_creation: bool = False,\n        concurrency_limit: int | None = None,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Update documents in batches to reduce RAM usage with indexing.\n\n        Each batch tries to fill the max_payload_size\n\n        Args:\n            documents: List of documents.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            concurrency_limit: If set this will limit the number of batches that will be sent\n                concurrently. This can be helpful if you find you are overloading the Meilisearch\n                server with requests. Defaults to None.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_in_batches(documents)\n        \"\"\"\n        if concurrency_limit:\n            semaphore = asyncio.Semaphore(concurrency_limit)\n\n            async def update_batch_with_limit(batch_data: Sequence[JsonMapping]) -&gt; TaskInfo:\n                async with semaphore:\n                    return await self.update_documents(\n                        batch_data,\n                        primary_key=primary_key,\n                        custom_metadata=custom_metadata,\n                        skip_creation=skip_creation,\n                        compress=compress,\n                    )\n\n            if not use_task_groups():\n                batches = [update_batch_with_limit(x) for x in batch(documents, batch_size)]\n                return await asyncio.gather(*batches)\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                tasks = [\n                    tg.create_task(update_batch_with_limit(x)) for x in batch(documents, batch_size)\n                ]\n            return [x.result() for x in tasks]\n\n        if not use_task_groups():\n            batches = [\n                self.update_documents(\n                    x,\n                    primary_key,\n                    custom_metadata=custom_metadata,\n                    skip_creation=skip_creation,\n                    compress=compress,\n                )\n                for x in batch(documents, batch_size)\n            ]\n            return await asyncio.gather(*batches)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = [\n                tg.create_task(\n                    self.update_documents(\n                        x,\n                        primary_key,\n                        custom_metadata=custom_metadata,\n                        skip_creation=skip_creation,\n                        compress=compress,\n                    )\n                )\n                for x in batch(documents, batch_size)\n            ]\n        return [x.result() for x in tasks]\n\n    async def update_documents_from_directory(\n        self,\n        directory_path: Path | str,\n        *,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and update the documents.\n\n        Args:\n            directory_path: Path to the directory that contains the json files.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row containing\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_directory(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    all_documents.append(documents)\n\n            raise_on_no_documents(all_documents, document_type, directory_path)\n\n            loop = asyncio.get_running_loop()\n            combined = await loop.run_in_executor(None, partial(combine_documents_, all_documents))\n\n            response = await self.update_documents(\n                combined,\n                primary_key,\n                custom_metadata=custom_metadata,\n                skip_creation=skip_creation,\n                compress=compress,\n            )\n            return [response]\n\n        if not use_task_groups():\n            update_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    update_documents.append(\n                        self.update_documents(\n                            documents,\n                            primary_key,\n                            custom_metadata=custom_metadata,\n                            skip_creation=skip_creation,\n                            compress=compress,\n                        )\n                    )\n\n            raise_on_no_documents(update_documents, document_type, directory_path)\n\n            if len(update_documents) &gt; 1:\n                # Send the first document on its own before starting the gather. Otherwise Meilisearch\n                # returns an error because it thinks all entries are trying to create the same index.\n                first_response = [await update_documents.pop()]\n                responses = await asyncio.gather(*update_documents)\n                responses = [*first_response, *responses]\n            else:\n                responses = [await update_documents[0]]\n\n            return responses\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = []\n            results = []\n            for i, path in enumerate(directory.iterdir()):\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    if i == 0:\n                        results = [\n                            await self.update_documents(\n                                documents,\n                                primary_key,\n                                custom_metadata=custom_metadata,\n                                skip_creation=skip_creation,\n                                compress=compress,\n                            )\n                        ]\n                    else:\n                        tasks.append(\n                            tg.create_task(\n                                self.update_documents(\n                                    documents,\n                                    primary_key,\n                                    custom_metadata=custom_metadata,\n                                    skip_creation=skip_creation,\n                                    compress=compress,\n                                )\n                            )\n                        )\n\n        results = [*results, *[x.result() for x in tasks]]\n        raise_on_no_documents(results, document_type, directory_path)\n        return results\n\n    async def update_documents_from_directory_in_batches(\n        self,\n        directory_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n        skip_creation: bool = False,\n        concurrency_limit: int | None = None,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and update the documents.\n\n        Args:\n            directory_path: Path to the directory that contains the json files.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row containing\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            concurrency_limit: If set this will limit the number of batches that will be sent\n                concurrently. This can be helpful if you find you are overloading the Meilisearch\n                server with requests. Defaults to None.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_directory_in_batches(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    all_documents.append(documents)\n\n            raise_on_no_documents(all_documents, document_type, directory_path)\n\n            loop = asyncio.get_running_loop()\n            combined = await loop.run_in_executor(None, partial(combine_documents_, all_documents))\n\n            return await self.update_documents_in_batches(\n                combined,\n                batch_size=batch_size,\n                primary_key=primary_key,\n                custom_metadata=custom_metadata,\n                compress=compress,\n                skip_creation=skip_creation,\n                concurrency_limit=concurrency_limit,\n            )\n\n        if not use_task_groups():\n            responses: list[TaskInfo] = []\n\n            update_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    update_documents.append(\n                        self.update_documents_in_batches(\n                            documents,\n                            batch_size=batch_size,\n                            primary_key=primary_key,\n                            custom_metadata=custom_metadata,\n                            compress=compress,\n                            skip_creation=skip_creation,\n                            concurrency_limit=concurrency_limit,\n                        )\n                    )\n\n            raise_on_no_documents(update_documents, document_type, directory_path)\n\n            if len(update_documents) &gt; 1:\n                # Send the first document on its own before starting the gather. Otherwise Meilisearch\n                # returns an error because it thinks all entries are trying to create the same index.\n                first_response = await update_documents.pop()\n                responses_gather = await asyncio.gather(*update_documents)\n                responses = [*first_response, *[x for y in responses_gather for x in y]]\n            else:\n                responses = await update_documents[0]\n\n            return responses\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            results = []\n            tasks = []\n            for i, path in enumerate(directory.iterdir()):\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    if i == 0:\n                        results = await self.update_documents_in_batches(\n                            documents,\n                            batch_size=batch_size,\n                            primary_key=primary_key,\n                            custom_metadata=custom_metadata,\n                            compress=compress,\n                            skip_creation=skip_creation,\n                            concurrency_limit=concurrency_limit,\n                        )\n                    else:\n                        tasks.append(\n                            tg.create_task(\n                                self.update_documents_in_batches(\n                                    documents,\n                                    batch_size=batch_size,\n                                    primary_key=primary_key,\n                                    custom_metadata=custom_metadata,\n                                    compress=compress,\n                                    skip_creation=skip_creation,\n                                    concurrency_limit=concurrency_limit,\n                                )\n                            )\n                        )\n\n        results = [*results, *[x for y in tasks for x in y.result()]]\n        raise_on_no_documents(results, document_type, directory_path)\n        return results\n\n    async def update_documents_from_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents in the index from a json file.\n\n        Args:\n            file_path: Path to the json file.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_file(file_path)\n        \"\"\"\n        documents = await _async_load_documents_from_file(\n            file_path, csv_delimiter, json_handler=self._json_handler\n        )\n\n        return await self.update_documents(\n            documents,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            skip_creation=skip_creation,\n            compress=compress,\n        )\n\n    async def update_documents_from_file_in_batches(\n        self,\n        file_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        compress: bool = False,\n        skip_creation: bool = False,\n        concurrency_limit: int | None = None,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Updates documents form a json file in batches to reduce RAM usage with indexing.\n\n        Args:\n            file_path: Path to the json file.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            concurrency_limit: If set this will limit the number of batches that will be sent\n                concurrently. This can be helpful if you find you are overloading the Meilisearch\n                server with requests. Defaults to None.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_file_in_batches(file_path)\n        \"\"\"\n        documents = await _async_load_documents_from_file(\n            file_path, json_handler=self._json_handler\n        )\n\n        return await self.update_documents_in_batches(\n            documents,\n            batch_size=batch_size,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            compress=compress,\n            skip_creation=skip_creation,\n            concurrency_limit=concurrency_limit,\n        )\n\n    async def update_documents_from_raw_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n        The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n        for batching.\n\n        Args:\n            file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n                allowed.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n                a non-csv file.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_raw_file(file_path)\n        \"\"\"\n        upload_path, content_type = prepare_raw_file_upload(file_path, csv_delimiter)\n        parameters = {}\n\n        if primary_key:\n            parameters[\"primaryKey\"] = primary_key\n        if csv_delimiter:\n            parameters[\"csvDelimiter\"] = csv_delimiter\n        if custom_metadata:\n            parameters[\"customMetadata\"] = custom_metadata\n        if skip_creation:\n            parameters[\"skipCreation\"] = \"true\"\n\n        if parameters:\n            url = build_encoded_url(self._documents_url, parameters)\n        else:\n            url = self._documents_url\n\n        async with aiofiles.open(upload_path) as f:\n            data = await f.read()\n\n        response = await self._http_requests.put(\n            url, body=data, content_type=content_type, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def delete_document(\n        self, document_id: str, *, custom_metadata: str | None = None\n    ) -&gt; TaskInfo:\n        \"\"\"Delete one document from the index.\n\n        Args:\n            document_id: Unique identifier of the document.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_document(\"1234\")\n        \"\"\"\n        url = f\"{self._documents_url}/{document_id}\"\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        if self._pre_delete_document_plugins:\n            await _run_plugins(\n                self._pre_delete_document_plugins, AsyncEvent.PRE, document_id=document_id\n            )\n\n        if self._concurrent_delete_document_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_delete_document_plugins:\n                    tasks.append(\n                        plugin.run_plugin(event=AsyncEvent.CONCURRENT, document_id=document_id)\n                    )\n\n                tasks.append(self._http_requests.delete(url))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_delete_document_plugins:\n                    post = await _run_plugins(\n                        self._post_delete_document_plugins, AsyncEvent.POST, result=result\n                    )\n                    if isinstance(post.get(\"generic_result\"), TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_delete_document_plugins:\n                    tg.create_task(\n                        plugin.run_plugin(event=AsyncEvent.CONCURRENT, document_id=document_id)\n                    )\n\n                response_coroutine = tg.create_task(self._http_requests.delete(url))\n\n            response = await response_coroutine\n            result = TaskInfo(**self._http_requests.parse_json(response))\n            if self._post_delete_document_plugins:\n                post = await _run_plugins(\n                    self._post_delete_document_plugins, event=AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        response = await self._http_requests.delete(url)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_document_plugins:\n            post = await _run_plugins(\n                self._post_delete_document_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def delete_documents(\n        self, ids: list[str], *, custom_metadata: str | None = None\n    ) -&gt; TaskInfo:\n        \"\"\"Delete multiple documents from the index.\n\n        Args:\n            ids: List of unique identifiers of documents.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_documents([\"1234\", \"5678\"])\n        \"\"\"\n        url = f\"{self._documents_url}/delete-batch\"\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        if self._pre_delete_documents_plugins:\n            await _run_plugins(self._pre_delete_documents_plugins, AsyncEvent.PRE, ids=ids)\n\n        if self._concurrent_delete_documents_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_delete_documents_plugins:\n                    tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT, ids=ids))\n\n                tasks.append(self._http_requests.post(url, ids))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_delete_documents_plugins:\n                    post = await _run_plugins(\n                        self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n                    )\n                    if isinstance(post.get(\"generic_result\"), TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_delete_documents_plugins:\n                    tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT, ids=ids))\n\n                response_coroutine = tg.create_task(self._http_requests.post(url, ids))\n\n            response = await response_coroutine\n            result = TaskInfo(**self._http_requests.parse_json(response))\n            if self._post_delete_documents_plugins:\n                post = await _run_plugins(\n                    self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        response = await self._http_requests.post(url, ids)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_documents_plugins:\n            post = await _run_plugins(\n                self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def delete_documents_by_filter(\n        self, filter: Filter, *, custom_metadata: str | None = None\n    ) -&gt; TaskInfo:\n        \"\"\"Delete documents from the index by filter.\n\n        Args:\n            filter: The filter value information.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_documents_by_filter(\"genre=horor\"))\n        \"\"\"\n        url = f\"{self._documents_url}/delete\"\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        if self._pre_delete_documents_by_filter_plugins:\n            await _run_plugins(\n                self._pre_delete_documents_by_filter_plugins, AsyncEvent.PRE, filter=filter\n            )\n\n        if self._concurrent_delete_documents_by_filter_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_delete_documents_by_filter_plugins:\n                    tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT, filter=filter))\n\n                tasks.append(self._http_requests.post(url, body={\"filter\": filter}))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_delete_documents_by_filter_plugins:\n                    post = await _run_plugins(\n                        self._post_delete_documents_by_filter_plugins,\n                        AsyncEvent.POST,\n                        result=result,\n                    )\n                    if isinstance(post[\"generic_result\"], TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_delete_documents_by_filter_plugins:\n                    tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT, filter=filter))\n\n                response_coroutine = tg.create_task(\n                    self._http_requests.post(url, body={\"filter\": filter})\n                )\n\n            response = await response_coroutine\n            result = TaskInfo(**self._http_requests.parse_json(response))\n            if self._post_delete_documents_by_filter_plugins:\n                post = await _run_plugins(\n                    self._post_delete_documents_by_filter_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        response = await self._http_requests.post(url, body={\"filter\": filter})\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_documents_by_filter_plugins:\n            post = await _run_plugins(\n                self._post_delete_documents_by_filter_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    async def delete_documents_in_batches_by_filter(\n        self,\n        filters: list[str | list[str | list[str]]],\n        concurrency_limit: int | None = None,\n        *,\n        custom_metadata: str | None = None,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Delete batches of documents from the index by filter.\n\n        Args:\n            filters: A list of filter value information.\n            concurrency_limit: If set this will limit the number of batches that will be sent\n                concurrently. This can be helpful if you find you are overloading the Meilisearch\n                server with requests. Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The a list of details of the task statuses.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_documents_in_batches_by_filter(\n            &gt;&gt;&gt;         [\n            &gt;&gt;&gt;             \"genre=horor\"),\n            &gt;&gt;&gt;             \"release_date=1520035200\"),\n            &gt;&gt;&gt;         ]\n            &gt;&gt;&gt;     )\n        \"\"\"\n        if concurrency_limit:\n            semaphore = asyncio.Semaphore(concurrency_limit)\n\n            async def delete_with_limit(\n                filter_value: str | list[str | list[str]],\n            ) -&gt; TaskInfo:\n                async with semaphore:\n                    return await self.delete_documents_by_filter(\n                        filter_value, custom_metadata=custom_metadata\n                    )\n\n            if not use_task_groups():\n                tasks = [delete_with_limit(filter) for filter in filters]\n                return await asyncio.gather(*tasks)\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                tg_tasks = [tg.create_task(delete_with_limit(filter)) for filter in filters]\n\n            return [x.result() for x in tg_tasks]\n\n        if not use_task_groups():\n            tasks = [\n                self.delete_documents_by_filter(filter, custom_metadata=custom_metadata)\n                for filter in filters\n            ]\n            return await asyncio.gather(*tasks)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tg_tasks = [\n                tg.create_task(\n                    self.delete_documents_by_filter(filter, custom_metadata=custom_metadata)\n                )\n                for filter in filters\n            ]\n\n        return [x.result() for x in tg_tasks]\n\n    async def delete_all_documents(self, *, custom_metadata: str | None = None) -&gt; TaskInfo:\n        \"\"\"Delete all documents from the index.\n\n        Args:\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_all_document()\n        \"\"\"\n        if custom_metadata:\n            url = build_encoded_url(self._documents_url, {\"customMetadata\": custom_metadata})\n        else:\n            url = self._documents_url\n\n        if self._pre_delete_all_documents_plugins:\n            await _run_plugins(self._pre_delete_all_documents_plugins, AsyncEvent.PRE)\n\n        if self._concurrent_delete_all_documents_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_delete_all_documents_plugins:\n                    tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT))\n\n                tasks.append(self._http_requests.delete(url))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_delete_all_documents_plugins:\n                    post = await _run_plugins(\n                        self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n                    )\n                    if isinstance(post.get(\"generic_result\"), TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_delete_all_documents_plugins:\n                    tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT))\n\n                response_coroutine = tg.create_task(self._http_requests.delete(url))\n\n            response = await response_coroutine\n            result = TaskInfo(**self._http_requests.parse_json(response))\n            if self._post_delete_all_documents_plugins:\n                post = await _run_plugins(\n                    self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post.get(\"generic_result\"), TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        response = await self._http_requests.delete(url)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_all_documents_plugins:\n            post = await _run_plugins(\n                self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    async def get_settings(self) -&gt; MeilisearchSettings:\n        \"\"\"Get settings of the index.\n\n        Returns:\n            Settings of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     settings = await index.get_settings()\n        \"\"\"\n        response = await self._http_requests.get(self._settings_url)\n        response_json = self._http_requests.parse_json(response)\n        settings = MeilisearchSettings(**response_json)\n\n        if response_json.get(\"embedders\"):\n            # Not coverted because it times out. It isn't an issue with the code here.\n            # https://github.com/meilisearch/meilisearch/issues/4585\n            settings.embedders = embedder_json_to_settings_model(  # pragma: no cover\n                response_json[\"embedders\"]\n            )\n\n        return settings\n\n    async def update_settings(\n        self, body: MeilisearchSettings, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update settings of the index.\n\n        Args:\n            body: Settings of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n            &gt;&gt;&gt; new_settings = MeilisearchSettings(\n            &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n            &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n            &gt;&gt;&gt;     ranking_rules=[\n            &gt;&gt;&gt;         \"words\",\n            &gt;&gt;&gt;         \"typo\",\n            &gt;&gt;&gt;         \"proximity\",\n            &gt;&gt;&gt;         \"attribute\",\n            &gt;&gt;&gt;         \"sort\",\n            &gt;&gt;&gt;         \"exactness\",\n            &gt;&gt;&gt;         \"release_date:desc\",\n            &gt;&gt;&gt;         \"rank:desc\",\n            &gt;&gt;&gt;    ],\n            &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n            &gt;&gt;&gt;    distinct_attribute=\"url\",\n            &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n            &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n            &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n            &gt;&gt;&gt; )\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_settings(new_settings)\n        \"\"\"\n        body_dict = {\n            k: v\n            for k, v in body.model_dump(by_alias=True, exclude_none=True).items()\n            if v is not None\n        }\n        response = await self._http_requests.patch(self._settings_url, body_dict, compress=compress)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_settings(self) -&gt; TaskInfo:\n        \"\"\"Reset settings of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_settings()\n        \"\"\"\n        response = await self._http_requests.delete(self._settings_url)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_ranking_rules(self) -&gt; list[str]:\n        \"\"\"Get ranking rules of the index.\n\n        Returns:\n            List containing the ranking rules of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     ranking_rules = await index.get_ranking_rules()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/ranking-rules\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_ranking_rules(\n        self, ranking_rules: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update ranking rules of the index.\n\n        Args:\n            ranking_rules: List containing the ranking rules.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; ranking_rules=[\n            &gt;&gt;&gt;      \"words\",\n            &gt;&gt;&gt;      \"typo\",\n            &gt;&gt;&gt;      \"proximity\",\n            &gt;&gt;&gt;      \"attribute\",\n            &gt;&gt;&gt;      \"sort\",\n            &gt;&gt;&gt;      \"exactness\",\n            &gt;&gt;&gt;      \"release_date:desc\",\n            &gt;&gt;&gt;      \"rank:desc\",\n            &gt;&gt;&gt; ],\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_ranking_rules(ranking_rules)\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/ranking-rules\", ranking_rules, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_ranking_rules(self) -&gt; TaskInfo:\n        \"\"\"Reset ranking rules of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_ranking_rules()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/ranking-rules\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_distinct_attribute(self) -&gt; str | None:\n        \"\"\"Get distinct attribute of the index.\n\n        Returns:\n            String containing the distinct attribute of the index. If no distinct attribute\n                `None` is returned.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     distinct_attribute = await index.get_distinct_attribute()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/distinct-attribute\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        return self._http_requests.parse_json(response)\n\n    async def update_distinct_attribute(self, body: str, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update distinct attribute of the index.\n\n        Args:\n            body: Distinct attribute.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_distinct_attribute(\"url\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/distinct-attribute\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_distinct_attribute(self) -&gt; TaskInfo:\n        \"\"\"Reset distinct attribute of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_distinct_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/distinct-attribute\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_searchable_attributes(self) -&gt; list[str]:\n        \"\"\"Get searchable attributes of the index.\n\n        Returns:\n            List containing the searchable attributes of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     searchable_attributes = await index.get_searchable_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/searchable-attributes\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_searchable_attributes(\n        self, body: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update searchable attributes of the index.\n\n        Args:\n            body: List containing the searchable attributes.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/searchable-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_searchable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset searchable attributes of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_searchable_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/searchable-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_displayed_attributes(self) -&gt; list[str]:\n        \"\"\"Get displayed attributes of the index.\n\n        Returns:\n            List containing the displayed attributes of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     displayed_attributes = await index.get_displayed_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/displayed-attributes\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_displayed_attributes(\n        self, body: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update displayed attributes of the index.\n\n        Args:\n            body: List containing the displayed attributes.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_displayed_attributes(\n            &gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]\n            &gt;&gt;&gt;     )\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/displayed-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_displayed_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset displayed attributes of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_displayed_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/displayed-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_stop_words(self) -&gt; list[str] | None:\n        \"\"\"Get stop words of the index.\n\n        Returns:\n            List containing the stop words of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     stop_words = await index.get_stop_words()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/stop-words\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        return self._http_requests.parse_json(response)\n\n    async def update_stop_words(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update stop words of the index.\n\n        Args:\n            body: List containing the stop words of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_stop_words([\"the\", \"a\", \"an\"])\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/stop-words\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_stop_words(self) -&gt; TaskInfo:\n        \"\"\"Reset stop words of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_stop_words()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/stop-words\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_synonyms(self) -&gt; dict[str, list[str]] | None:\n        \"\"\"Get synonyms of the index.\n\n        Returns:\n            The synonyms of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     synonyms = await index.get_synonyms()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/synonyms\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        return self._http_requests.parse_json(response)\n\n    async def update_synonyms(\n        self, body: dict[str, list[str]], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update synonyms of the index.\n\n        Args:\n            body: The synonyms of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_synonyms(\n            &gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n            &gt;&gt;&gt;     )\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/synonyms\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_synonyms(self) -&gt; TaskInfo:\n        \"\"\"Reset synonyms of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_synonyms()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/synonyms\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_filterable_attributes(self) -&gt; list[str | FilterableAttributes] | None:\n        \"\"\"Get filterable attributes of the index.\n\n        Returns:\n            Filterable attributes of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     filterable_attributes = await index.get_filterable_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/filterable-attributes\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        response_json = self._http_requests.parse_json(response)\n\n        filterable_attributes: list[str | FilterableAttributes] = []\n        for r in response_json:\n            if isinstance(r, str):\n                filterable_attributes.append(r)\n            else:\n                filterable_attributes.append(\n                    FilterableAttributes(\n                        attribute_patterns=r[\"attributePatterns\"],\n                        features=FilterableAttributeFeatures(**r[\"features\"]),\n                    )\n                )\n\n        return filterable_attributes\n\n    async def update_filterable_attributes(\n        self, body: list[str | FilterableAttributes], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update filterable attributes of the index.\n\n        Args:\n            body: List containing the filterable attributes of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_filterable_attributes([\"genre\", \"director\"])\n        \"\"\"\n        payload: list[str | JsonDict] = []\n\n        for b in body:\n            if isinstance(b, FilterableAttributes):\n                payload.append(b.model_dump(by_alias=True))\n            else:\n                payload.append(b)\n\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/filterable-attributes\", payload, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_filterable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset filterable attributes of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_filterable_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/filterable-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_sortable_attributes(self) -&gt; list[str]:\n        \"\"\"Get sortable attributes of the AsyncIndex.\n\n        Returns:\n            List containing the sortable attributes of the AsyncIndex.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     sortable_attributes = await index.get_sortable_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/sortable-attributes\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_sortable_attributes(\n        self, sortable_attributes: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Get sortable attributes of the AsyncIndex.\n\n        Args:\n            sortable_attributes: List of attributes for searching.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_sortable_attributes([\"title\", \"release_date\"])\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/sortable-attributes\", sortable_attributes, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_sortable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset sortable attributes of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_sortable_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/sortable-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_typo_tolerance(self) -&gt; TypoTolerance:\n        \"\"\"Get typo tolerance for the index.\n\n        Returns:\n            TypoTolerance for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     sortable_attributes = await index.get_typo_tolerance()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/typo-tolerance\")\n\n        return TypoTolerance(**self._http_requests.parse_json(response))\n\n    async def update_typo_tolerance(\n        self, typo_tolerance: TypoTolerance, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update typo tolerance.\n\n        Args:\n            typo_tolerance: Typo tolerance settings.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     TypoTolerance(enabled=False)\n            &gt;&gt;&gt;     await index.update_typo_tolerance()\n        \"\"\"\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/typo-tolerance\",\n            typo_tolerance.model_dump(by_alias=True, exclude_unset=True),\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_typo_tolerance(self) -&gt; TaskInfo:\n        \"\"\"Reset typo tolerance to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_typo_tolerance()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/typo-tolerance\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_faceting(self) -&gt; Faceting:\n        \"\"\"Get faceting for the index.\n\n        Returns:\n            Faceting for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     faceting = await index.get_faceting()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/faceting\")\n\n        return Faceting(**self._http_requests.parse_json(response))\n\n    async def update_faceting(self, faceting: Faceting, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Partially update the faceting settings for an index.\n\n        Args:\n            faceting: Faceting values.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n        \"\"\"\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/faceting\",\n            faceting.model_dump(by_alias=True),\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_faceting(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's faceting settings to their default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_faceting()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/faceting\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_pagination(self) -&gt; Pagination:\n        \"\"\"Get pagination settings for the index.\n\n        Returns:\n            Pagination for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     pagination_settings = await index.get_pagination()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/pagination\")\n\n        return Pagination(**self._http_requests.parse_json(response))\n\n    async def update_pagination(self, settings: Pagination, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Partially update the pagination settings for an index.\n\n        Args:\n            settings: settings for pagination.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_pagination(settings=Pagination(max_total_hits=123))\n        \"\"\"\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/pagination\",\n            settings.model_dump(by_alias=True),\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_pagination(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's pagination settings to their default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_pagination()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/pagination\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_separator_tokens(self) -&gt; list[str]:\n        \"\"\"Get separator token settings for the index.\n\n        Returns:\n            Separator tokens for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     separator_token_settings = await index.get_separator_tokens()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/separator-tokens\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_separator_tokens(\n        self, separator_tokens: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the separator tokens settings for an index.\n\n        Args:\n            separator_tokens: List of separator tokens.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/separator-tokens\", separator_tokens, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_separator_tokens(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's separator tokens settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_separator_tokens()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/separator-tokens\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_non_separator_tokens(self) -&gt; list[str]:\n        \"\"\"Get non-separator token settings for the index.\n\n        Returns:\n            Non-separator tokens for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     non_separator_token_settings = await index.get_non_separator_tokens()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/non-separator-tokens\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_non_separator_tokens(\n        self, non_separator_tokens: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the non-separator tokens settings for an index.\n\n        Args:\n            non_separator_tokens: List of non-separator tokens.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/non-separator-tokens\", non_separator_tokens, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_non_separator_tokens(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's non-separator tokens settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_non_separator_tokens()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/non-separator-tokens\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_search_cutoff_ms(self) -&gt; int | None:\n        \"\"\"Get search cutoff time in ms.\n\n        Returns:\n            Integer representing the search cutoff time in ms, or None.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_cutoff_ms_settings = await index.get_search_cutoff_ms()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/search-cutoff-ms\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_search_cutoff_ms(\n        self, search_cutoff_ms: int, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the search cutoff for an index.\n\n        Args:\n            search_cutoff_ms: Integer value of the search cutoff time in ms.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_search_cutoff_ms(100)\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/search-cutoff-ms\", search_cutoff_ms, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_search_cutoff_ms(self) -&gt; TaskInfo:\n        \"\"\"Reset the search cutoff time to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_search_cutoff_ms()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/search-cutoff-ms\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_word_dictionary(self) -&gt; list[str]:\n        \"\"\"Get word dictionary settings for the index.\n\n        Returns:\n            Word dictionary for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     word_dictionary = await index.get_word_dictionary()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/dictionary\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_word_dictionary(\n        self, dictionary: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the word dictionary settings for an index.\n\n        Args:\n            dictionary: List of dictionary values.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/dictionary\", dictionary, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_word_dictionary(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's word dictionary settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_word_dictionary()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/dictionary\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_proximity_precision(self) -&gt; ProximityPrecision:\n        \"\"\"Get proximity precision settings for the index.\n\n        Returns:\n            Proximity precision for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     proximity_precision = await index.get_proximity_precision()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/proximity-precision\")\n\n        return ProximityPrecision[to_snake(self._http_requests.parse_json(response)).upper()]\n\n    async def update_proximity_precision(\n        self, proximity_precision: ProximityPrecision, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the proximity precision settings for an index.\n\n        Args:\n            proximity_precision: The proximity precision value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/proximity-precision\",\n            proximity_precision.value,\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_proximity_precision(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's proximity precision settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_proximity_precision()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/proximity-precision\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_embedders(self) -&gt; Embedders | None:\n        \"\"\"Get embedder settings for the index.\n\n        Returns:\n            Embedders for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     embedders = await index.get_embedders()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/embedders\")\n\n        return embedder_json_to_embedders_model(self._http_requests.parse_json(response))\n\n    async def update_embedders(self, embedders: Embedders, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update the embedders settings for an index.\n\n        Args:\n            embedders: The embedders value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_embedders(\n            &gt;&gt;&gt;         Embedders(embedders={\"default\": UserProvidedEmbedder(dimensions=512)})\n            &gt;&gt;&gt;     )\n        \"\"\"\n        payload = {}\n        for key, embedder in embedders.embedders.items():\n            payload[key] = {\n                k: v\n                for k, v in embedder.model_dump(by_alias=True, exclude_none=True).items()\n                if v is not None\n            }\n\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/embedders\", payload, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_embedders(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's embedders settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_embedders()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/embedders\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_localized_attributes(self) -&gt; list[LocalizedAttributes] | None:\n        \"\"\"Get localized attributes settings for the index.\n\n        Returns:\n            Localized attributes for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     localized_attributes = await index.get_localized_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/localized-attributes\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        return [LocalizedAttributes(**x) for x in self._http_requests.parse_json(response)]\n\n    async def update_localized_attributes(\n        self, localized_attributes: list[LocalizedAttributes], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the localized attributes settings for an index.\n\n        Args:\n            localized_attributes: The localized attributes value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import LocalizedAttributes\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_localized_attributes([\n            &gt;&gt;&gt;         LocalizedAttributes(locales=[\"eng\", \"spa\"], attribute_patterns=[\"*\"]),\n            &gt;&gt;&gt;         LocalizedAttributes(locales=[\"ita\"], attribute_patterns=[\"*_it\"]),\n            &gt;&gt;&gt;     ])\n        \"\"\"\n        payload = [x.model_dump(by_alias=True) for x in localized_attributes]\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/localized-attributes\", payload, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_localized_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's localized attributes settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_localized_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/localized-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_facet_search(self) -&gt; bool | None:\n        \"\"\"Get setting for facet search opt-out.\n\n        Returns:\n            True if facet search is enabled or False if not.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     facet_search = await index.get_facet_search()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/facet-search\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_facet_search(self, facet_search: bool, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update setting for facet search opt-out.\n\n        Args:\n            facet_search: Boolean indicating if facet search should be disabled.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_facet_search(True)\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/facet-search\",\n            facet_search,\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_facet_search(self) -&gt; TaskInfo:\n        \"\"\"Reset the facet search opt-out settings.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_facet_search()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/facet-search\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def get_prefix_search(self) -&gt; str:\n        \"\"\"Get setting for prefix search opt-out.\n\n        Returns:\n            True if prefix search is enabled or False if not.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.index(\"movies\")\n            &gt;&gt;&gt;     prefix_search = await index.get_prefix_search()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/prefix-search\")\n\n        return self._http_requests.parse_json(response)\n\n    async def update_prefix_search(\n        self,\n        prefix_search: Literal[\"disabled\", \"indexingTime\", \"searchTime\"],\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Update setting for prefix search opt-out.\n\n        Args:\n            prefix_search: Value indicating prefix search setting.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_prefix_search(\"disabled\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/prefix-search\",\n            prefix_search,\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def reset_prefix_search(self) -&gt; TaskInfo:\n        \"\"\"Reset the prefix search opt-out settings.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_prefix_search()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/prefix-search\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    async def fields(\n        self, offset: int = 0, limit: int = 20, filter: FieldsFilter | None = None\n    ) -&gt; FieldResults:\n        \"\"\"Get the field properties on an index.\n\n        Args:\n            offset: Number of fields to skip. Defaults to 0.\n            limit: Maximum number of fields returned. Defaults to 20.\n            filter: Filter fields to return based on properties. Defaults to None.\n\n        Returns:\n            Field properties\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     docs = [{\"id\": 1, \"title\": \"Some Title}]\n            &gt;&gt;&gt;     index = await client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents(docs)\n            &gt;&gt;&gt;     fields = await index.fields()\n        \"\"\"\n        filter_value = filter.model_dump(by_alias=True) if filter else None\n        response = await self._http_requests.post(\n            f\"{self._base_url_with_uid}/fields\",\n            body={\"offset\": offset, \"limit\": limit, \"filter\": filter_value},\n        )\n        response_json = response.json()\n        fields = [Field(**field) for field in response_json[\"results\"]]\n\n        return FieldResults(\n            fields=fields,\n            offset=response_json[\"offset\"],\n            limit=response_json[\"limit\"],\n            total=response_json[\"total\"],\n        )\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.__init__","title":"<code>__init__(http_client, uid, primary_key=None, created_at=None, updated_at=None, plugins=None, json_handler=None, *, hits_type=JsonDict)</code>","text":"<p>Class initializer.</p> <p>Parameters:</p> Name Type Description Default <code>http_client</code> <code>AsyncClient</code> <p>An instance of the AsyncClient. This automatically gets passed by the AsyncClient when creating and AsyncIndex instance.</p> required <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. Defaults to None.</p> <code>None</code> <code>created_at</code> <code>str | datetime | None</code> <p>The date and time the index was created. Defaults to None.</p> <code>None</code> <code>updated_at</code> <code>str | datetime | None</code> <p>The date and time the index was last updated. Defaults to None.</p> <code>None</code> <code>plugins</code> <code>AsyncIndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <code>json_handler</code> <code>BuiltinHandler | OrjsonHandler | None</code> <p>The module to use for json operations. The options are BuiltinHandler (uses the json module from the standard library), or OrjsonHandler (uses orjson). Note that in order use orjson the corresponding extra needs to be included. Default: BuiltinHandler.</p> <code>None</code> <code>hits_type</code> <code>type[Any]</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>def __init__(\n    self,\n    http_client: AsyncClient,\n    uid: str,\n    primary_key: str | None = None,\n    created_at: str | datetime | None = None,\n    updated_at: str | datetime | None = None,\n    plugins: AsyncIndexPlugins | None = None,\n    json_handler: BuiltinHandler | OrjsonHandler | None = None,\n    *,\n    hits_type: type[Any] = JsonDict,\n) -&gt; None:\n    \"\"\"Class initializer.\n\n    Args:\n        http_client: An instance of the AsyncClient. This automatically gets passed by the\n            AsyncClient when creating and AsyncIndex instance.\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        created_at: The date and time the index was created. Defaults to None.\n        updated_at: The date and time the index was last updated. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n        json_handler: The module to use for json operations. The options are BuiltinHandler\n            (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n            Note that in order use orjson the corresponding extra needs to be included.\n            Default: BuiltinHandler.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n    \"\"\"\n    super().__init__(\n        uid=uid,\n        primary_key=primary_key,\n        created_at=created_at,\n        updated_at=updated_at,\n        json_handler=json_handler,\n        hits_type=hits_type,\n    )\n    self.http_client = http_client\n    self._http_requests = AsyncHttpRequests(http_client, json_handler=self._json_handler)\n    self.plugins = plugins\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents","title":"<code>add_documents(documents, primary_key=None, *, custom_metadata=None, compress=False)</code>  <code>async</code>","text":"<p>Add documents to the index.</p> <p>Parameters:</p> Name Type Description Default <code>documents</code> <code>Sequence[JsonMapping]</code> <p>List of documents.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.add_documents(documents)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def add_documents(\n    self,\n    documents: Sequence[JsonMapping],\n    primary_key: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents to the index.\n\n    Args:\n        documents: List of documents.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents(documents)\n    \"\"\"\n    params = {}\n\n    if primary_key:\n        params[\"primaryKey\"] = primary_key\n\n    if custom_metadata:\n        params[\"customMetadata\"] = custom_metadata\n\n    if params:\n        url = build_encoded_url(self._documents_url, params)\n    else:\n        url = self._documents_url\n\n    if self._pre_add_documents_plugins:\n        pre = await _run_plugins(\n            self._pre_add_documents_plugins,\n            AsyncEvent.PRE,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if pre.get(\"document_result\"):\n            documents = pre[\"document_result\"]\n\n    if self._concurrent_add_documents_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_add_documents_plugins:\n                if plugin_has_method(plugin, \"run_plugin\"):\n                    tasks.append(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n                if plugin_has_method(plugin, \"run_document_plugin\"):\n                    tasks.append(\n                        plugin.run_document_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n\n            tasks.append(self._http_requests.post(url, documents, compress=compress))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_add_documents_plugins:\n                post = await _run_plugins(\n                    self._post_add_documents_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                    documents=documents,\n                    primary_key=primary_key,\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_add_documents_plugins:\n                if plugin_has_method(plugin, \"run_plugin\"):\n                    tg.create_task(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n                if plugin_has_method(plugin, \"run_document_plugin\"):\n                    tg.create_task(\n                        plugin.run_document_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n\n            response_coroutine = tg.create_task(\n                self._http_requests.post(url, documents, compress=compress)\n            )\n\n        response = await response_coroutine\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_add_documents_plugins:\n            post = await _run_plugins(\n                self._post_add_documents_plugins,\n                AsyncEvent.POST,\n                result=result,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    response = await self._http_requests.post(url, documents, compress=compress)\n\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_add_documents_plugins:\n        post = await _run_plugins(\n            self._post_add_documents_plugins,\n            AsyncEvent.POST,\n            result=result,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if isinstance(post[\"generic_result\"], TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_directory","title":"<code>add_documents_from_directory(directory_path, *, primary_key=None, custom_metadata=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False, concurrency_limit=None)</code>  <code>async</code>","text":"<p>Load all json files from a directory and add the documents to the index.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | str</code> <p>Path to the directory that contains the json files.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>document_type</code> <code>str</code> <p>The type of document being added. Accepted types are json, csv, and ndjson. For csv files the first row of the document should be a header row containing the field names, and ever for should have a title.</p> <code>'json'</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>combine_documents</code> <code>bool</code> <p>If set to True this will combine the documents from all the files before indexing them. Defaults to True.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <code>concurrency_limit</code> <code>int | None</code> <p>If set this will limit the number of batches that will be sent concurrently. This can be helpful if you find you are overloading the Meilisearch server with requests. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.add_documents_from_directory(directory_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def add_documents_from_directory(\n    self,\n    directory_path: Path | str,\n    *,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n    concurrency_limit: int | None = None,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and add the documents to the index.\n\n    Args:\n        directory_path: Path to the directory that contains the json files.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row\n            containing the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n        concurrency_limit: If set this will limit the number of batches that will be sent\n            concurrently. This can be helpful if you find you are overloading the Meilisearch\n            server with requests. Defaults to None.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_directory(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                all_documents.append(documents)\n\n        raise_on_no_documents(all_documents, document_type, directory_path)\n\n        loop = asyncio.get_running_loop()\n        combined = await loop.run_in_executor(None, partial(combine_documents_, all_documents))\n\n        response = await self.add_documents(\n            combined, primary_key, custom_metadata=custom_metadata, compress=compress\n        )\n\n        return [response]\n\n    if concurrency_limit:\n        semaphore = asyncio.Semaphore(concurrency_limit)\n\n        async def add_docs_with_limit(docs: Sequence[JsonMapping]) -&gt; TaskInfo:\n            async with semaphore:\n                return await self.add_documents(\n                    docs,\n                    primary_key,\n                    custom_metadata=custom_metadata,\n                    compress=compress,\n                )\n\n        if not use_task_groups():\n            add_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    add_documents.append(add_docs_with_limit(documents))\n\n            raise_on_no_documents(add_documents, document_type, directory_path)\n\n            if len(add_documents) &gt; 1:\n                # Send the first document on its own before starting the gather. Otherwise Meilisearch\n                # returns an error because it thinks all entries are trying to create the same index.\n                first_response = [await add_documents.pop(0)]\n\n                responses = await asyncio.gather(*add_documents)\n                responses = [*first_response, *responses]\n            else:\n                responses = [await add_documents[0]]\n\n            return responses\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = []\n            all_results = []\n            for i, path in enumerate(directory.iterdir()):\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    if i == 0:\n                        all_results = [await add_docs_with_limit(documents)]\n                    else:\n                        tasks.append(tg.create_task(add_docs_with_limit(documents)))\n\n        return [*all_results, *[x.result() for x in tasks]]\n\n    if not use_task_groups():\n        add_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                add_documents.append(\n                    self.add_documents(\n                        documents,\n                        primary_key,\n                        custom_metadata=custom_metadata,\n                        compress=compress,\n                    )\n                )\n\n        raise_on_no_documents(add_documents, document_type, directory_path)\n\n        if len(add_documents) &gt; 1:\n            # Send the first document on its own before starting the gather. Otherwise Meilisearch\n            # returns an error because it thinks all entries are trying to create the same index.\n            first_response = [await add_documents.pop()]\n\n            responses = await asyncio.gather(*add_documents)\n            responses = [*first_response, *responses]\n        else:\n            responses = [await add_documents[0]]\n\n        return responses\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tasks = []\n        all_results = []\n        for i, path in enumerate(directory.iterdir()):\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                if i == 0:\n                    all_results = [\n                        await self.add_documents(\n                            documents,\n                            primary_key=primary_key,\n                            custom_metadata=custom_metadata,\n                            compress=compress,\n                        )\n                    ]\n                else:\n                    tasks.append(\n                        tg.create_task(\n                            self.add_documents(\n                                documents,\n                                primary_key,\n                                custom_metadata=custom_metadata,\n                                compress=compress,\n                            )\n                        )\n                    )\n\n    results = [x.result() for x in tasks]\n    all_results = [*all_results, *results]\n    raise_on_no_documents(all_results, document_type, directory_path)\n    return all_results\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_directory_in_batches","title":"<code>add_documents_from_directory_in_batches(directory_path, *, batch_size=1000, primary_key=None, custom_metadata=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False, concurrency_limit=None)</code>  <code>async</code>","text":"<p>Load all json files from a directory and add the documents to the index in batches.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | str</code> <p>Path to the directory that contains the json files.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>document_type</code> <code>str</code> <p>The type of document being added. Accepted types are json, csv, and ndjson. For csv files the first row of the document should be a header row containing the field names, and ever for should have a title.</p> <code>'json'</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>combine_documents</code> <code>bool</code> <p>If set to True this will combine the documents from all the files before indexing them. Defaults to True.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <code>concurrency_limit</code> <code>int | None</code> <p>If set this will limit the number of batches that will be sent concurrently. This can be helpful if you find you are overloading the Meilisearch server with requests. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.add_documents_from_directory_in_batches(directory_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def add_documents_from_directory_in_batches(\n    self,\n    directory_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n    concurrency_limit: int | None = None,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and add the documents to the index in batches.\n\n    Args:\n        directory_path: Path to the directory that contains the json files.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row containing\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n        concurrency_limit: If set this will limit the number of batches that will be sent\n            concurrently. This can be helpful if you find you are overloading the Meilisearch\n            server with requests. Defaults to None.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_directory_in_batches(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter=csv_delimiter, json_handler=self._json_handler\n                )\n                all_documents.append(documents)\n\n        raise_on_no_documents(all_documents, document_type, directory_path)\n\n        loop = asyncio.get_running_loop()\n        combined = await loop.run_in_executor(None, partial(combine_documents_, all_documents))\n\n        return await self.add_documents_in_batches(\n            combined,\n            batch_size=batch_size,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            compress=compress,\n            concurrency_limit=concurrency_limit,\n        )\n\n    responses: list[TaskInfo] = []\n\n    add_documents = []\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = await _async_load_documents_from_file(\n                path, csv_delimiter, json_handler=self._json_handler\n            )\n            add_documents.append(\n                self.add_documents_in_batches(\n                    documents,\n                    batch_size=batch_size,\n                    primary_key=primary_key,\n                    custom_metadata=custom_metadata,\n                    compress=compress,\n                    concurrency_limit=concurrency_limit,\n                )\n            )\n\n    raise_on_no_documents(add_documents, document_type, directory_path)\n\n    if len(add_documents) &gt; 1:\n        # Send the first document on its own before starting the gather. Otherwise Meilisearch\n        # returns an error because it thinks all entries are trying to create the same index.\n        first_response = await add_documents.pop()\n        responses_gather = await asyncio.gather(*add_documents)\n        responses = [*first_response, *[x for y in responses_gather for x in y]]\n    else:\n        responses = await add_documents[0]\n\n    return responses\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_file","title":"<code>add_documents_from_file(file_path, primary_key=None, *, custom_metadata=None, compress=False)</code>  <code>async</code>","text":"<p>Add documents to the index from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the json file.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.add_documents_from_file(file_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def add_documents_from_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents to the index from a json file.\n\n    Args:\n        file_path: Path to the json file.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_file(file_path)\n    \"\"\"\n    documents = await _async_load_documents_from_file(\n        file_path, json_handler=self._json_handler\n    )\n\n    return await self.add_documents(\n        documents, primary_key=primary_key, custom_metadata=custom_metadata, compress=compress\n    )\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_file_in_batches","title":"<code>add_documents_from_file_in_batches(file_path, *, batch_size=1000, primary_key=None, custom_metadata=None, csv_delimiter=None, compress=False, concurrency_limit=None)</code>  <code>async</code>","text":"<p>Adds documents form a json file in batches to reduce RAM usage with indexing.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the json file.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <code>concurrency_limit</code> <code>int | None</code> <p>If set this will limit the number of batches that will be sent concurrently. This can be helpful if you find you are overloading the Meilisearch server with requests. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.add_documents_from_file_in_batches(file_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def add_documents_from_file_in_batches(\n    self,\n    file_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    csv_delimiter: str | None = None,\n    compress: bool = False,\n    concurrency_limit: int | None = None,\n) -&gt; list[TaskInfo]:\n    \"\"\"Adds documents form a json file in batches to reduce RAM usage with indexing.\n\n    Args:\n        file_path: Path to the json file.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n        concurrency_limit: If set this will limit the number of batches that will be sent\n            concurrently. This can be helpful if you find you are overloading the Meilisearch\n            server with requests. Defaults to None.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_file_in_batches(file_path)\n    \"\"\"\n    documents = await _async_load_documents_from_file(\n        file_path, csv_delimiter, json_handler=self._json_handler\n    )\n\n    return await self.add_documents_in_batches(\n        documents,\n        batch_size=batch_size,\n        primary_key=primary_key,\n        custom_metadata=custom_metadata,\n        compress=compress,\n        concurrency_limit=concurrency_limit,\n    )\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_raw_file","title":"<code>add_documents_from_raw_file(file_path, primary_key=None, *, custom_metadata=None, csv_delimiter=None, compress=False)</code>  <code>async</code>","text":"<p>Directly send csv or ndjson files to Meilisearch without pre-processing.</p> <p>The can reduce RAM usage from Meilisearch during indexing, but does not include the option for batching.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>The path to the file to send to Meilisearch. Only csv and ndjson files are allowed.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is not a csv or ndjson file, or if a csv_delimiter is sent for a non-csv file.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.add_documents_from_raw_file(file_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def add_documents_from_raw_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    csv_delimiter: str | None = None,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n    The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n    for batching.\n\n    Args:\n        file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n            allowed.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n            a non-csv file.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_raw_file(file_path)\n    \"\"\"\n    upload_path, content_type = prepare_raw_file_upload(file_path, csv_delimiter)\n    parameters = {}\n\n    if primary_key:\n        parameters[\"primaryKey\"] = primary_key\n    if csv_delimiter:\n        parameters[\"csvDelimiter\"] = csv_delimiter\n    if custom_metadata:\n        parameters[\"customMetadata\"] = custom_metadata\n\n    if parameters:\n        url = build_encoded_url(self._documents_url, parameters)\n    else:\n        url = self._documents_url\n\n    async with aiofiles.open(upload_path) as f:\n        data = await f.read()\n\n    response = await self._http_requests.post(\n        url, body=data, content_type=content_type, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_in_batches","title":"<code>add_documents_in_batches(documents, *, batch_size=1000, primary_key=None, custom_metadata=None, compress=False, concurrency_limit=None)</code>  <code>async</code>","text":"<p>Adds documents in batches to reduce RAM usage with indexing.</p> <p>Parameters:</p> Name Type Description Default <code>documents</code> <code>Sequence[JsonMapping]</code> <p>List of documents.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <code>concurrency_limit</code> <code>int | None</code> <p>If set this will limit the number of batches that will be sent concurrently. This can be helpful if you find you are overloading the Meilisearch server with requests. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.add_documents_in_batches(documents)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def add_documents_in_batches(\n    self,\n    documents: Sequence[JsonMapping],\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    compress: bool = False,\n    concurrency_limit: int | None = None,\n) -&gt; list[TaskInfo]:\n    \"\"\"Adds documents in batches to reduce RAM usage with indexing.\n\n    Args:\n        documents: List of documents.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n        concurrency_limit: If set this will limit the number of batches that will be sent\n            concurrently. This can be helpful if you find you are overloading the Meilisearch\n            server with requests. Defaults to None.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_in_batches(documents)\n    \"\"\"\n    if concurrency_limit:\n        semaphore = asyncio.Semaphore(concurrency_limit)\n\n        async def add_batch_with_limit(batch_data: Sequence[JsonMapping]) -&gt; TaskInfo:\n            async with semaphore:\n                return await self.add_documents(\n                    batch_data, primary_key, custom_metadata=custom_metadata, compress=compress\n                )\n\n        if not use_task_groups():\n            batches = [add_batch_with_limit(data) for data in batch(documents, batch_size)]\n            return await asyncio.gather(*batches)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = [\n                tg.create_task(add_batch_with_limit(x)) for x in batch(documents, batch_size)\n            ]\n\n        return [x.result() for x in tasks]\n\n    if not use_task_groups():\n        batches = [\n            self.add_documents(\n                x, primary_key, custom_metadata=custom_metadata, compress=compress\n            )\n            for x in batch(documents, batch_size)\n        ]\n        return await asyncio.gather(*batches)\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tasks = [\n            tg.create_task(\n                self.add_documents(\n                    x, primary_key, custom_metadata=custom_metadata, compress=compress\n                )\n            )\n            for x in batch(documents, batch_size)\n        ]\n\n    return [x.result() for x in tasks]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.compact","title":"<code>compact()</code>  <code>async</code>","text":"<p>Appends a new task to the queue to compact the database.</p> <p>This defragments the LMDB database potentially speeds up indexing and searching. NOTE: This is only available in Meilisearch v1.23.0+</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.compact()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def compact(self) -&gt; TaskInfo:\n    \"\"\"Appends a new task to the queue to compact the database.\n\n    This defragments the LMDB database potentially speeds up indexing and searching.\n    NOTE: This is only available in Meilisearch v1.23.0+\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.compact()\n    \"\"\"\n    response = await self._http_requests.post(f\"{self._base_url_with_uid}/compact\")\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.create","title":"<code>create(http_client, uid, primary_key=None, *, settings=None, wait=True, timeout_in_ms=None, plugins=None, json_handler=None, hits_type=JsonDict)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Creates a new index.</p> <p>In general this method should not be used directly and instead the index should be created through the <code>Client</code>.</p> <p>Parameters:</p> Name Type Description Default <code>http_client</code> <code>AsyncClient</code> <p>An instance of the AsyncClient. This automatically gets passed by the Client when creating an AsyncIndex instance.</p> required <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. Defaults to None.</p> <code>None</code> <code>settings</code> <code>MeilisearchSettings | None</code> <p>Settings for the index. The settings can also be updated independently of creating the index. The advantage to updating them here is updating the settings after adding documents will cause the documents to be re-indexed. Because of this it will be faster to update them before adding documents. Defaults to None (i.e. default Meilisearch index settings).</p> <code>None</code> <code>wait</code> <code>bool</code> <p>If set to True and settings are being updated, the index will be returned after the settings update has completed. If False it will not wait for settings to complete. Default: True</p> <code>True</code> <code>timeout_in_ms</code> <code>int | None</code> <p>Amount of time in milliseconds to wait before raising a MeilisearchTimeoutError. <code>None</code> can also be passed to wait indefinitely. Be aware that if the <code>None</code> option is used the wait time could be very long. Defaults to None.</p> <code>None</code> <code>plugins</code> <code>AsyncIndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <code>json_handler</code> <code>BuiltinHandler | OrjsonHandler | None</code> <p>The module to use for json operations. The options are BuiltinHandler (uses the json module from the standard library), or OrjsonHandler (uses orjson). Note that in order use orjson the corresponding extra needs to be included. Default: BuiltinHandler.</p> <code>None</code> <code>hits_type</code> <code>type[Any]</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of AsyncIndex containing the information of the newly created index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = await index.create(client, \"movies\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>@classmethod\nasync def create(\n    cls,\n    http_client: AsyncClient,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    settings: MeilisearchSettings | None = None,\n    wait: bool = True,\n    timeout_in_ms: int | None = None,\n    plugins: AsyncIndexPlugins | None = None,\n    json_handler: BuiltinHandler | OrjsonHandler | None = None,\n    hits_type: type[Any] = JsonDict,\n) -&gt; Self:\n    \"\"\"Creates a new index.\n\n    In general this method should not be used directly and instead the index should be created\n    through the `Client`.\n\n    Args:\n        http_client: An instance of the AsyncClient. This automatically gets passed by the\n            Client when creating an AsyncIndex instance.\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        settings: Settings for the index. The settings can also be updated independently of\n            creating the index. The advantage to updating them here is updating the settings after\n            adding documents will cause the documents to be re-indexed. Because of this it will be\n            faster to update them before adding documents. Defaults to None (i.e. default\n            Meilisearch index settings).\n        wait: If set to True and settings are being updated, the index will be returned after\n            the settings update has completed. If False it will not wait for settings to complete.\n            Default: True\n        timeout_in_ms: Amount of time in milliseconds to wait before raising a\n            MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n            if the `None` option is used the wait time could be very long. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n        json_handler: The module to use for json operations. The options are BuiltinHandler\n            (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n            Note that in order use orjson the corresponding extra needs to be included.\n            Default: BuiltinHandler.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n\n    Returns:\n        An instance of AsyncIndex containing the information of the newly created index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await index.create(client, \"movies\")\n    \"\"\"\n    if not primary_key:\n        payload = {\"uid\": uid}\n    else:\n        payload = {\"primaryKey\": primary_key, \"uid\": uid}\n\n    url = \"indexes\"\n    handler = json_handler if json_handler else BuiltinHandler()\n    http_request = AsyncHttpRequests(http_client, json_handler=handler)\n    response = await http_request.post(url, payload)\n    await async_wait_for_task(\n        http_client,\n        http_request.parse_json(response)[\"taskUid\"],\n        timeout_in_ms=timeout_in_ms,\n    )\n\n    index_response = await http_request.get(f\"{url}/{uid}\")\n    index_dict = http_request.parse_json(index_response)\n    index = cls(\n        http_client=http_client,\n        uid=index_dict[\"uid\"],\n        primary_key=index_dict[\"primaryKey\"],\n        created_at=index_dict[\"createdAt\"],\n        updated_at=index_dict[\"updatedAt\"],\n        plugins=plugins,\n        json_handler=json_handler,\n        hits_type=hits_type,\n    )\n\n    if settings:\n        settings_task = await index.update_settings(settings)\n        if wait:\n            await async_wait_for_task(\n                http_client, settings_task.task_uid, timeout_in_ms=timeout_in_ms\n            )\n\n    return index\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Deletes the index.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.delete()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def delete(self) -&gt; TaskInfo:\n    \"\"\"Deletes the index.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete()\n    \"\"\"\n    response = await self._http_requests.delete(self._base_url_with_uid)\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_all_documents","title":"<code>delete_all_documents(*, custom_metadata=None)</code>  <code>async</code>","text":"<p>Delete all documents from the index.</p> <p>Parameters:</p> Name Type Description Default <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.delete_all_document()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def delete_all_documents(self, *, custom_metadata: str | None = None) -&gt; TaskInfo:\n    \"\"\"Delete all documents from the index.\n\n    Args:\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_all_document()\n    \"\"\"\n    if custom_metadata:\n        url = build_encoded_url(self._documents_url, {\"customMetadata\": custom_metadata})\n    else:\n        url = self._documents_url\n\n    if self._pre_delete_all_documents_plugins:\n        await _run_plugins(self._pre_delete_all_documents_plugins, AsyncEvent.PRE)\n\n    if self._concurrent_delete_all_documents_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_delete_all_documents_plugins:\n                tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT))\n\n            tasks.append(self._http_requests.delete(url))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_delete_all_documents_plugins:\n                post = await _run_plugins(\n                    self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post.get(\"generic_result\"), TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_delete_all_documents_plugins:\n                tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT))\n\n            response_coroutine = tg.create_task(self._http_requests.delete(url))\n\n        response = await response_coroutine\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_all_documents_plugins:\n            post = await _run_plugins(\n                self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    response = await self._http_requests.delete(url)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_delete_all_documents_plugins:\n        post = await _run_plugins(\n            self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_document","title":"<code>delete_document(document_id, *, custom_metadata=None)</code>  <code>async</code>","text":"<p>Delete one document from the index.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>Unique identifier of the document.</p> required <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.delete_document(\"1234\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def delete_document(\n    self, document_id: str, *, custom_metadata: str | None = None\n) -&gt; TaskInfo:\n    \"\"\"Delete one document from the index.\n\n    Args:\n        document_id: Unique identifier of the document.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_document(\"1234\")\n    \"\"\"\n    url = f\"{self._documents_url}/{document_id}\"\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    if self._pre_delete_document_plugins:\n        await _run_plugins(\n            self._pre_delete_document_plugins, AsyncEvent.PRE, document_id=document_id\n        )\n\n    if self._concurrent_delete_document_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_delete_document_plugins:\n                tasks.append(\n                    plugin.run_plugin(event=AsyncEvent.CONCURRENT, document_id=document_id)\n                )\n\n            tasks.append(self._http_requests.delete(url))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_delete_document_plugins:\n                post = await _run_plugins(\n                    self._post_delete_document_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post.get(\"generic_result\"), TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_delete_document_plugins:\n                tg.create_task(\n                    plugin.run_plugin(event=AsyncEvent.CONCURRENT, document_id=document_id)\n                )\n\n            response_coroutine = tg.create_task(self._http_requests.delete(url))\n\n        response = await response_coroutine\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_document_plugins:\n            post = await _run_plugins(\n                self._post_delete_document_plugins, event=AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    response = await self._http_requests.delete(url)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_delete_document_plugins:\n        post = await _run_plugins(\n            self._post_delete_document_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post[\"generic_result\"], TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_documents","title":"<code>delete_documents(ids, *, custom_metadata=None)</code>  <code>async</code>","text":"<p>Delete multiple documents from the index.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of unique identifiers of documents.</p> required <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.delete_documents([\"1234\", \"5678\"])</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def delete_documents(\n    self, ids: list[str], *, custom_metadata: str | None = None\n) -&gt; TaskInfo:\n    \"\"\"Delete multiple documents from the index.\n\n    Args:\n        ids: List of unique identifiers of documents.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_documents([\"1234\", \"5678\"])\n    \"\"\"\n    url = f\"{self._documents_url}/delete-batch\"\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    if self._pre_delete_documents_plugins:\n        await _run_plugins(self._pre_delete_documents_plugins, AsyncEvent.PRE, ids=ids)\n\n    if self._concurrent_delete_documents_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_delete_documents_plugins:\n                tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT, ids=ids))\n\n            tasks.append(self._http_requests.post(url, ids))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_delete_documents_plugins:\n                post = await _run_plugins(\n                    self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post.get(\"generic_result\"), TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_delete_documents_plugins:\n                tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT, ids=ids))\n\n            response_coroutine = tg.create_task(self._http_requests.post(url, ids))\n\n        response = await response_coroutine\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_documents_plugins:\n            post = await _run_plugins(\n                self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    response = await self._http_requests.post(url, ids)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_delete_documents_plugins:\n        post = await _run_plugins(\n            self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post[\"generic_result\"], TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_documents_by_filter","title":"<code>delete_documents_by_filter(filter, *, custom_metadata=None)</code>  <code>async</code>","text":"<p>Delete documents from the index by filter.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Filter</code> <p>The filter value information.</p> required <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.delete_documents_by_filter(\"genre=horor\"))</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def delete_documents_by_filter(\n    self, filter: Filter, *, custom_metadata: str | None = None\n) -&gt; TaskInfo:\n    \"\"\"Delete documents from the index by filter.\n\n    Args:\n        filter: The filter value information.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_documents_by_filter(\"genre=horor\"))\n    \"\"\"\n    url = f\"{self._documents_url}/delete\"\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    if self._pre_delete_documents_by_filter_plugins:\n        await _run_plugins(\n            self._pre_delete_documents_by_filter_plugins, AsyncEvent.PRE, filter=filter\n        )\n\n    if self._concurrent_delete_documents_by_filter_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_delete_documents_by_filter_plugins:\n                tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT, filter=filter))\n\n            tasks.append(self._http_requests.post(url, body={\"filter\": filter}))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_delete_documents_by_filter_plugins:\n                post = await _run_plugins(\n                    self._post_delete_documents_by_filter_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_delete_documents_by_filter_plugins:\n                tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT, filter=filter))\n\n            response_coroutine = tg.create_task(\n                self._http_requests.post(url, body={\"filter\": filter})\n            )\n\n        response = await response_coroutine\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_documents_by_filter_plugins:\n            post = await _run_plugins(\n                self._post_delete_documents_by_filter_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    response = await self._http_requests.post(url, body={\"filter\": filter})\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_delete_documents_by_filter_plugins:\n        post = await _run_plugins(\n            self._post_delete_documents_by_filter_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_documents_in_batches_by_filter","title":"<code>delete_documents_in_batches_by_filter(filters, concurrency_limit=None, *, custom_metadata=None)</code>  <code>async</code>","text":"<p>Delete batches of documents from the index by filter.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>list[str | list[str | list[str]]]</code> <p>A list of filter value information.</p> required <code>concurrency_limit</code> <code>int | None</code> <p>If set this will limit the number of batches that will be sent concurrently. This can be helpful if you find you are overloading the Meilisearch server with requests. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>The a list of details of the task statuses.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.delete_documents_in_batches_by_filter(     &gt;&gt;&gt;         [     &gt;&gt;&gt;             \"genre=horor\"),     &gt;&gt;&gt;             \"release_date=1520035200\"),     &gt;&gt;&gt;         ]     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def delete_documents_in_batches_by_filter(\n    self,\n    filters: list[str | list[str | list[str]]],\n    concurrency_limit: int | None = None,\n    *,\n    custom_metadata: str | None = None,\n) -&gt; list[TaskInfo]:\n    \"\"\"Delete batches of documents from the index by filter.\n\n    Args:\n        filters: A list of filter value information.\n        concurrency_limit: If set this will limit the number of batches that will be sent\n            concurrently. This can be helpful if you find you are overloading the Meilisearch\n            server with requests. Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The a list of details of the task statuses.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_documents_in_batches_by_filter(\n        &gt;&gt;&gt;         [\n        &gt;&gt;&gt;             \"genre=horor\"),\n        &gt;&gt;&gt;             \"release_date=1520035200\"),\n        &gt;&gt;&gt;         ]\n        &gt;&gt;&gt;     )\n    \"\"\"\n    if concurrency_limit:\n        semaphore = asyncio.Semaphore(concurrency_limit)\n\n        async def delete_with_limit(\n            filter_value: str | list[str | list[str]],\n        ) -&gt; TaskInfo:\n            async with semaphore:\n                return await self.delete_documents_by_filter(\n                    filter_value, custom_metadata=custom_metadata\n                )\n\n        if not use_task_groups():\n            tasks = [delete_with_limit(filter) for filter in filters]\n            return await asyncio.gather(*tasks)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tg_tasks = [tg.create_task(delete_with_limit(filter)) for filter in filters]\n\n        return [x.result() for x in tg_tasks]\n\n    if not use_task_groups():\n        tasks = [\n            self.delete_documents_by_filter(filter, custom_metadata=custom_metadata)\n            for filter in filters\n        ]\n        return await asyncio.gather(*tasks)\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tg_tasks = [\n            tg.create_task(\n                self.delete_documents_by_filter(filter, custom_metadata=custom_metadata)\n            )\n            for filter in filters\n        ]\n\n    return [x.result() for x in tg_tasks]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_if_exists","title":"<code>delete_if_exists()</code>  <code>async</code>","text":"<p>Delete the index if it already exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the index was deleted or False if not.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.delete_if_exists()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def delete_if_exists(self) -&gt; bool:\n    \"\"\"Delete the index if it already exists.\n\n    Returns:\n        True if the index was deleted or False if not.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_if_exists()\n    \"\"\"\n    response = await self.delete()\n    status = await async_wait_for_task(\n        self.http_client, response.task_uid, timeout_in_ms=100000\n    )\n    if status.status == \"succeeded\":\n        return True\n\n    return False\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.edit_documents","title":"<code>edit_documents(function, *, context=None, filter=None, custom_metadata=None)</code>  <code>async</code>","text":"<p>Edit documents with a function.</p> <p>Edit documents is only available in Meilisearch &gt;= v1.10.0, and is experimental in Meilisearch v1.10.0. In order to use this feature you first need to enable it by sending a PATCH request to /experimental-features with { \"editDocumentsByFunction\": true }.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Rhai function to use to update the documents.</p> required <code>context</code> <code>JsonDict | None</code> <p>Parameters to use in the function. Defaults to None.</p> <code>None</code> <code>filter</code> <code>str | None</code> <p>Filter the documents before applying the function. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.edit_documents(\"doc.title = <code>${doc.title.to_upper()}</code>\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def edit_documents(\n    self,\n    function: str,\n    *,\n    context: JsonDict | None = None,\n    filter: str | None = None,\n    custom_metadata: str | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Edit documents with a function.\n\n    Edit documents is only available in Meilisearch &gt;= v1.10.0, and is experimental in\n    Meilisearch v1.10.0. In order to use this feature you first need to enable it by\n    sending a PATCH request to /experimental-features with { \"editDocumentsByFunction\": true }.\n\n    Args:\n        function: Rhai function to use to update the documents.\n        context: Parameters to use in the function. Defaults to None.\n        filter: Filter the documents before applying the function. Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.edit_documents(\"doc.title = `${doc.title.to_upper()}`\")\n    \"\"\"\n    url = f\"{self._documents_url}/edit\"\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    payload: JsonDict = {\"function\": function}\n\n    if context:\n        payload[\"context\"] = context\n\n    if filter:\n        payload[\"filter\"] = filter\n\n    response = await self._http_requests.post(url, payload)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.facet_search","title":"<code>facet_search(query=None, *, facet_name, facet_query, offset=0, limit=20, filter=None, facets=None, attributes_to_retrieve=None, attributes_to_crop=None, crop_length=200, attributes_to_highlight=None, sort=None, show_matches_position=False, highlight_pre_tag='&lt;em&gt;', highlight_post_tag='&lt;/em&gt;', crop_marker='...', matching_strategy='last', hits_per_page=None, page=None, attributes_to_search_on=None, show_ranking_score=False, show_ranking_score_details=False, ranking_score_threshold=None, vector=None, locales=None, retrieve_vectors=None, exhaustive_facet_count=None)</code>  <code>async</code>","text":"<p>Search the index.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>String containing the word(s) to search</p> <code>None</code> <code>facet_name</code> <code>str</code> <p>The name of the facet to search</p> required <code>facet_query</code> <code>str</code> <p>The facet search value</p> required <code>offset</code> <code>int</code> <p>Number of documents to skip. Defaults to 0.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of documents returned. Defaults to 20.</p> <code>20</code> <code>filter</code> <code>Filter | None</code> <p>Filter queries by an attribute value. Defaults to None.</p> <code>None</code> <code>facets</code> <code>list[str] | None</code> <p>Facets for which to retrieve the matching count. Defaults to None.</p> <code>None</code> <code>attributes_to_retrieve</code> <code>list[str] | None</code> <p>Attributes to display in the returned documents. Defaults to [\"*\"].</p> <code>None</code> <code>attributes_to_crop</code> <code>list[str] | None</code> <p>Attributes whose values have to be cropped. Defaults to None.</p> <code>None</code> <code>crop_length</code> <code>int</code> <p>The maximum number of words to display. Defaults to 200.</p> <code>200</code> <code>attributes_to_highlight</code> <code>list[str] | None</code> <p>Attributes whose values will contain highlighted matching terms. Defaults to None.</p> <code>None</code> <code>sort</code> <code>list[str] | None</code> <p>Attributes by which to sort the results. Defaults to None.</p> <code>None</code> <code>show_matches_position</code> <code>bool</code> <p>Defines whether an object that contains information about the matches should be returned or not. Defaults to False.</p> <code>False</code> <code>highlight_pre_tag</code> <code>str</code> <p>The opening tag for highlighting text. Defaults to . <code>'&lt;em&gt;'</code> <code>highlight_post_tag</code> <code>str</code> <p>The closing tag for highlighting text. Defaults to </p> <code>'&lt;/em&gt;'</code> <code>crop_marker</code> <code>str</code> <p>Marker to display when the number of words exceeds the <code>crop_length</code>. Defaults to ...</p> <code>'...'</code> <code>matching_strategy</code> <code>Literal['all', 'last', 'frequency']</code> <p>Specifies the matching strategy Meilisearch should use. Defaults to <code>last</code>.</p> <code>'last'</code> <code>hits_per_page</code> <code>int | None</code> <p>Sets the number of results returned per page.</p> <code>None</code> <code>page</code> <code>int | None</code> <p>Sets the specific results page to fetch.</p> <code>None</code> <code>attributes_to_search_on</code> <code>list[str] | None</code> <p>List of field names. Allow search over a subset of searchable attributes without modifying the index settings. Defaults to None.</p> <code>None</code> <code>show_ranking_score</code> <code>bool</code> <p>If set to True the ranking score will be returned with each document in the search. Defaults to False.</p> <code>False</code> <code>show_ranking_score_details</code> <code>bool</code> <p>If set to True the ranking details will be returned with each document in the search. Defaults to False. Note: This parameter can only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order to use this feature in Meilisearch v1.3.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"scoreDetails\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution. This feature became stable in Meiliseach v1.7.0.</p> <code>False</code> <code>ranking_score_threshold</code> <code>float | None</code> <p>If set, no document whose _rankingScore is under the rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults to None.</p> <code>None</code> <code>vector</code> <code>list[float] | None</code> <p>List of vectors for vector search. Defaults to None. Note: This parameter can only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order to use this feature in Meilisearch v1.3.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"vectorStore\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution.</p> <code>None</code> <code>locales</code> <code>list[str] | None</code> <p>Specifies the languages for the search. This parameter can only be used with Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.</p> <code>None</code> <code>retrieve_vectors</code> <code>bool | None</code> <p>Return document vector data with search result.</p> <code>None</code> <code>exhaustive_facet_count</code> <code>bool | None</code> <p>forcing the facet search to compute the facet counts the same way as the paginated search. This parameter can only be used with Milisearch &gt;= v1.14.0. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>FacetSearchResults</code> <p>Results of the search</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     search_results = await index.search(     &gt;&gt;&gt;         \"Tron\",     &gt;&gt;&gt;         facet_name=\"genre\",     &gt;&gt;&gt;         facet_query=\"Sci-fi\"     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def facet_search(\n    self,\n    query: str | None = None,\n    *,\n    facet_name: str,\n    facet_query: str,\n    offset: int = 0,\n    limit: int = 20,\n    filter: Filter | None = None,\n    facets: list[str] | None = None,\n    attributes_to_retrieve: list[str] | None = None,\n    attributes_to_crop: list[str] | None = None,\n    crop_length: int = 200,\n    attributes_to_highlight: list[str] | None = None,\n    sort: list[str] | None = None,\n    show_matches_position: bool = False,\n    highlight_pre_tag: str = \"&lt;em&gt;\",\n    highlight_post_tag: str = \"&lt;/em&gt;\",\n    crop_marker: str = \"...\",\n    matching_strategy: Literal[\"all\", \"last\", \"frequency\"] = \"last\",\n    hits_per_page: int | None = None,\n    page: int | None = None,\n    attributes_to_search_on: list[str] | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    ranking_score_threshold: float | None = None,\n    vector: list[float] | None = None,\n    locales: list[str] | None = None,\n    retrieve_vectors: bool | None = None,\n    exhaustive_facet_count: bool | None = None,\n) -&gt; FacetSearchResults:\n    \"\"\"Search the index.\n\n    Args:\n        query: String containing the word(s) to search\n        facet_name: The name of the facet to search\n        facet_query: The facet search value\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        facets: Facets for which to retrieve the matching count. Defaults to None.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n        crop_length: The maximum number of words to display. Defaults to 200.\n        attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n            Defaults to None.\n        sort: Attributes by which to sort the results. Defaults to None.\n        show_matches_position: Defines whether an object that contains information about the\n            matches should be returned or not. Defaults to False.\n        highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n        highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n        crop_marker: Marker to display when the number of words exceeds the `crop_length`.\n            Defaults to ...\n        matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to\n            `last`.\n        hits_per_page: Sets the number of results returned per page.\n        page: Sets the specific results page to fetch.\n        attributes_to_search_on: List of field names. Allow search over a subset of searchable\n            attributes without modifying the index settings. Defaults to None.\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n            to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n            sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n            Because this feature is experimental it may be removed or updated causing breaking\n            changes in this library without a major version bump so use with caution. This\n            feature became stable in Meiliseach v1.7.0.\n        ranking_score_threshold: If set, no document whose _rankingScore is under the\n            rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n            to None.\n        vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n            In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n        locales: Specifies the languages for the search. This parameter can only be used with\n            Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.\n        retrieve_vectors: Return document vector data with search result.\n        exhaustive_facet_count: forcing the facet search to compute the facet counts the same\n            way as the paginated search. This parameter can only be used with Milisearch &gt;=\n            v1.14.0. Defaults to None.\n\n    Returns:\n        Results of the search\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_results = await index.search(\n        &gt;&gt;&gt;         \"Tron\",\n        &gt;&gt;&gt;         facet_name=\"genre\",\n        &gt;&gt;&gt;         facet_query=\"Sci-fi\"\n        &gt;&gt;&gt;     )\n    \"\"\"\n    if ranking_score_threshold:\n        validate_ranking_score_threshold(ranking_score_threshold)\n\n    body = process_search_parameters(\n        q=query,\n        facet_name=facet_name,\n        facet_query=facet_query,\n        offset=offset,\n        limit=limit,\n        filter=filter,\n        facets=facets,\n        attributes_to_retrieve=attributes_to_retrieve,\n        attributes_to_crop=attributes_to_crop,\n        crop_length=crop_length,\n        attributes_to_highlight=attributes_to_highlight,\n        sort=sort,\n        show_matches_position=show_matches_position,\n        highlight_pre_tag=highlight_pre_tag,\n        highlight_post_tag=highlight_post_tag,\n        crop_marker=crop_marker,\n        matching_strategy=matching_strategy,\n        hits_per_page=hits_per_page,\n        page=page,\n        attributes_to_search_on=attributes_to_search_on,\n        show_ranking_score=show_ranking_score,\n        show_ranking_score_details=show_ranking_score_details,\n        ranking_score_threshold=ranking_score_threshold,\n        vector=vector,\n        locales=locales,\n        retrieve_vectors=retrieve_vectors,\n        exhaustive_facet_count=exhaustive_facet_count,\n    )\n    search_url = f\"{self._base_url_with_uid}/facet-search\"\n\n    if self._pre_facet_search_plugins:\n        await _run_plugins(\n            self._pre_facet_search_plugins,\n            AsyncEvent.PRE,\n            query=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            ranking_score_threshold=ranking_score_threshold,\n            vector=vector,\n            exhaustive_facet_count=exhaustive_facet_count,\n        )\n\n    if self._concurrent_facet_search_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_facet_search_plugins:\n                if plugin_has_method(plugin, \"run_plugin\"):\n                    tasks.append(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            query=query,\n                            offset=offset,\n                            limit=limit,\n                            filter=filter,\n                            facets=facets,\n                            attributes_to_retrieve=attributes_to_retrieve,\n                            attributes_to_crop=attributes_to_crop,\n                            crop_length=crop_length,\n                            attributes_to_highlight=attributes_to_highlight,\n                            sort=sort,\n                            show_matches_position=show_matches_position,\n                            highlight_pre_tag=highlight_pre_tag,\n                            highlight_post_tag=highlight_post_tag,\n                            crop_marker=crop_marker,\n                            matching_strategy=matching_strategy,\n                            hits_per_page=hits_per_page,\n                            page=page,\n                            attributes_to_search_on=attributes_to_search_on,\n                            show_ranking_score=show_ranking_score,\n                            show_ranking_score_details=show_ranking_score_details,\n                            ranking_score_threshold=ranking_score_threshold,\n                            vector=vector,\n                            exhaustive_facet_count=exhaustive_facet_count,\n                        )\n                    )\n\n            tasks.append(self._http_requests.post(search_url, body=body))\n            responses = await asyncio.gather(*tasks)\n            result = FacetSearchResults(**responses[-1].json())\n            if self._post_facet_search_plugins:\n                post = await _run_plugins(\n                    self._post_facet_search_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], FacetSearchResults):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_facet_search_plugins:\n                if plugin_has_method(plugin, \"run_plugin\"):\n                    tg.create_task(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            query=query,\n                            offset=offset,\n                            limit=limit,\n                            filter=filter,\n                            facets=facets,\n                            attributes_to_retrieve=attributes_to_retrieve,\n                            attributes_to_crop=attributes_to_crop,\n                            crop_length=crop_length,\n                            attributes_to_highlight=attributes_to_highlight,\n                            sort=sort,\n                            show_matches_position=show_matches_position,\n                            highlight_pre_tag=highlight_pre_tag,\n                            highlight_post_tag=highlight_post_tag,\n                            crop_marker=crop_marker,\n                            matching_strategy=matching_strategy,\n                            hits_per_page=hits_per_page,\n                            page=page,\n                            attributes_to_search_on=attributes_to_search_on,\n                            show_ranking_score=show_ranking_score,\n                            show_ranking_score_details=show_ranking_score_details,\n                            ranking_score_threshold=ranking_score_threshold,\n                            vector=vector,\n                            exhaustive_facet_count=exhaustive_facet_count,\n                        )\n                    )\n\n            response_coroutine = tg.create_task(self._http_requests.post(search_url, body=body))\n\n        response = await response_coroutine\n        result = FacetSearchResults(**self._http_requests.parse_json(response))\n        if self._post_facet_search_plugins:\n            post = await _run_plugins(\n                self._post_facet_search_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], FacetSearchResults):\n                result = post[\"generic_result\"]\n\n        return result\n\n    response = await self._http_requests.post(search_url, body=body)\n    result = FacetSearchResults(**self._http_requests.parse_json(response))\n    if self._post_facet_search_plugins:\n        post = await _run_plugins(\n            self._post_facet_search_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post[\"generic_result\"], FacetSearchResults):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.fetch_info","title":"<code>fetch_info()</code>  <code>async</code>","text":"<p>Gets the information about the index.</p> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the AsyncIndex containing the retrieved information.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index_info = await index.fetch_info()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def fetch_info(self) -&gt; Self:\n    \"\"\"Gets the information about the index.\n\n    Returns:\n        An instance of the AsyncIndex containing the retrieved information.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index_info = await index.fetch_info()\n    \"\"\"\n    response = await self._http_requests.get(self._base_url_with_uid)\n    index_dict = self._http_requests.parse_json(response)\n    self._set_fetch_info(\n        index_dict[\"primaryKey\"], index_dict[\"createdAt\"], index_dict[\"updatedAt\"]\n    )\n    return self\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.fields","title":"<code>fields(offset=0, limit=20, filter=None)</code>  <code>async</code>","text":"<p>Get the field properties on an index.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Number of fields to skip. Defaults to 0.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of fields returned. Defaults to 20.</p> <code>20</code> <code>filter</code> <code>FieldsFilter | None</code> <p>Filter fields to return based on properties. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>FieldResults</code> <p>Field properties</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     docs = [{\"id\": 1, \"title\": \"Some Title}]     &gt;&gt;&gt;     index = await client.index(\"movies\")     &gt;&gt;&gt;     await index.add_documents(docs)     &gt;&gt;&gt;     fields = await index.fields()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def fields(\n    self, offset: int = 0, limit: int = 20, filter: FieldsFilter | None = None\n) -&gt; FieldResults:\n    \"\"\"Get the field properties on an index.\n\n    Args:\n        offset: Number of fields to skip. Defaults to 0.\n        limit: Maximum number of fields returned. Defaults to 20.\n        filter: Filter fields to return based on properties. Defaults to None.\n\n    Returns:\n        Field properties\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     docs = [{\"id\": 1, \"title\": \"Some Title}]\n        &gt;&gt;&gt;     index = await client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents(docs)\n        &gt;&gt;&gt;     fields = await index.fields()\n    \"\"\"\n    filter_value = filter.model_dump(by_alias=True) if filter else None\n    response = await self._http_requests.post(\n        f\"{self._base_url_with_uid}/fields\",\n        body={\"offset\": offset, \"limit\": limit, \"filter\": filter_value},\n    )\n    response_json = response.json()\n    fields = [Field(**field) for field in response_json[\"results\"]]\n\n    return FieldResults(\n        fields=fields,\n        offset=response_json[\"offset\"],\n        limit=response_json[\"limit\"],\n        total=response_json[\"total\"],\n    )\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_displayed_attributes","title":"<code>get_displayed_attributes()</code>  <code>async</code>","text":"<p>Get displayed attributes of the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List containing the displayed attributes of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     displayed_attributes = await index.get_displayed_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_displayed_attributes(self) -&gt; list[str]:\n    \"\"\"Get displayed attributes of the index.\n\n    Returns:\n        List containing the displayed attributes of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     displayed_attributes = await index.get_displayed_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/displayed-attributes\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_distinct_attribute","title":"<code>get_distinct_attribute()</code>  <code>async</code>","text":"<p>Get distinct attribute of the index.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>String containing the distinct attribute of the index. If no distinct attribute <code>None</code> is returned.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     distinct_attribute = await index.get_distinct_attribute()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_distinct_attribute(self) -&gt; str | None:\n    \"\"\"Get distinct attribute of the index.\n\n    Returns:\n        String containing the distinct attribute of the index. If no distinct attribute\n            `None` is returned.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     distinct_attribute = await index.get_distinct_attribute()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/distinct-attribute\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_document","title":"<code>get_document(document_id, *, fields=None, retrieve_vectors=False)</code>  <code>async</code>","text":"<p>Get one document with given document identifier.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>Unique identifier of the document.</p> required <code>fields</code> <code>list[str] | None</code> <p>Document attributes to show. If this value is None then all attributes are retrieved. Defaults to None.</p> <code>None</code> <code>retrieve_vectors</code> <code>bool</code> <p>If set to True the embedding vectors will be returned with the document. Defaults to False. Note: This parameter can only be used with Meilisearch &gt;= v1.13.0</p> <code>False</code> <p>Returns:     The document information</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     document = await index.get_document(\"1234\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_document(\n    self,\n    document_id: str,\n    *,\n    fields: list[str] | None = None,\n    retrieve_vectors: bool = False,\n) -&gt; JsonDict:\n    \"\"\"Get one document with given document identifier.\n\n    Args:\n        document_id: Unique identifier of the document.\n        fields: Document attributes to show. If this value is None then all\n            attributes are retrieved. Defaults to None.\n        retrieve_vectors: If set to True the embedding vectors will be returned with the document.\n            Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.13.0\n    Returns:\n        The document information\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     document = await index.get_document(\"1234\")\n    \"\"\"\n    parameters: JsonDict = {}\n\n    if fields:\n        parameters[\"fields\"] = \",\".join(fields)\n    if retrieve_vectors:\n        parameters[\"retrieveVectors\"] = \"true\"\n\n    url = build_encoded_url(f\"{self._documents_url}/{document_id}\", parameters)\n\n    response = await self._http_requests.get(url)\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_documents","title":"<code>get_documents(*, ids=None, offset=0, limit=20, fields=None, filter=None, retrieve_vectors=False, sort=None)</code>  <code>async</code>","text":"<p>Get a batch documents from the index.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str] | None</code> <p>Array of document primary keys to retrieve. Defaults to None (Gets all documents).</p> <code>None</code> <code>offset</code> <code>int</code> <p>Number of documents to skip. Defaults to 0.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of documents returnedd. Defaults to 20.</p> <code>20</code> <code>fields</code> <code>list[str] | None</code> <p>Document attributes to show. If this value is None then all attributes are retrieved. Defaults to None.</p> <code>None</code> <code>filter</code> <code>Filter | None</code> <p>Filter value information. Defaults to None. Note: This parameter can only be used with Meilisearch &gt;= v1.2.0</p> <code>None</code> <code>retrieve_vectors</code> <code>bool</code> <p>If set to True the vectors will be returned with each document. Defaults to False. Note: This parameter can only be used with Meilisearch &gt;= v1.13.0</p> <code>False</code> <code>sort</code> <code>str | None</code> <p>Attribute by which to sort the results. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DocumentsInfo</code> <p>Documents info.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     documents = await index.get_documents()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_documents(\n    self,\n    *,\n    ids: list[str] | None = None,\n    offset: int = 0,\n    limit: int = 20,\n    fields: list[str] | None = None,\n    filter: Filter | None = None,\n    retrieve_vectors: bool = False,\n    sort: str | None = None,\n) -&gt; DocumentsInfo:\n    \"\"\"Get a batch documents from the index.\n\n    Args:\n        ids: Array of document primary keys to retrieve. Defaults to None (Gets all documents).\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returnedd. Defaults to 20.\n        fields: Document attributes to show. If this value is None then all\n            attributes are retrieved. Defaults to None.\n        filter: Filter value information. Defaults to None. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.2.0\n        retrieve_vectors: If set to True the vectors will be returned with each document.\n            Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.13.0\n        sort: Attribute by which to sort the results. Defaults to None.\n\n    Returns:\n        Documents info.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     documents = await index.get_documents()\n    \"\"\"\n    parameters: JsonDict = {\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    if sort:\n        parameters[\"sort\"] = sort\n\n    if not filter and not ids:\n        if retrieve_vectors:\n            parameters[\"retrieveVectors\"] = \"true\"\n        if fields:\n            parameters[\"fields\"] = \",\".join(fields)\n\n        url = build_encoded_url(self._documents_url, parameters)\n        response = await self._http_requests.get(url)\n\n        return DocumentsInfo(**self._http_requests.parse_json(response))\n\n    if retrieve_vectors:\n        parameters[\"retrieveVectors\"] = True\n\n    if fields:\n        parameters[\"fields\"] = fields\n\n    parameters[\"filter\"] = filter\n\n    if ids:\n        parameters[\"ids\"] = ids\n\n    response = await self._http_requests.post(f\"{self._documents_url}/fetch\", body=parameters)\n\n    return DocumentsInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_embedders","title":"<code>get_embedders()</code>  <code>async</code>","text":"<p>Get embedder settings for the index.</p> <p>Returns:</p> Type Description <code>Embedders | None</code> <p>Embedders for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     embedders = await index.get_embedders()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_embedders(self) -&gt; Embedders | None:\n    \"\"\"Get embedder settings for the index.\n\n    Returns:\n        Embedders for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     embedders = await index.get_embedders()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/embedders\")\n\n    return embedder_json_to_embedders_model(self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_facet_search","title":"<code>get_facet_search()</code>  <code>async</code>","text":"<p>Get setting for facet search opt-out.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p>True if facet search is enabled or False if not.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     facet_search = await index.get_facet_search()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_facet_search(self) -&gt; bool | None:\n    \"\"\"Get setting for facet search opt-out.\n\n    Returns:\n        True if facet search is enabled or False if not.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     facet_search = await index.get_facet_search()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/facet-search\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_faceting","title":"<code>get_faceting()</code>  <code>async</code>","text":"<p>Get faceting for the index.</p> <p>Returns:</p> Type Description <code>Faceting</code> <p>Faceting for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     faceting = await index.get_faceting()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_faceting(self) -&gt; Faceting:\n    \"\"\"Get faceting for the index.\n\n    Returns:\n        Faceting for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     faceting = await index.get_faceting()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/faceting\")\n\n    return Faceting(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_filterable_attributes","title":"<code>get_filterable_attributes()</code>  <code>async</code>","text":"<p>Get filterable attributes of the index.</p> <p>Returns:</p> Type Description <code>list[str | FilterableAttributes] | None</code> <p>Filterable attributes of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     filterable_attributes = await index.get_filterable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_filterable_attributes(self) -&gt; list[str | FilterableAttributes] | None:\n    \"\"\"Get filterable attributes of the index.\n\n    Returns:\n        Filterable attributes of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     filterable_attributes = await index.get_filterable_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/filterable-attributes\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    response_json = self._http_requests.parse_json(response)\n\n    filterable_attributes: list[str | FilterableAttributes] = []\n    for r in response_json:\n        if isinstance(r, str):\n            filterable_attributes.append(r)\n        else:\n            filterable_attributes.append(\n                FilterableAttributes(\n                    attribute_patterns=r[\"attributePatterns\"],\n                    features=FilterableAttributeFeatures(**r[\"features\"]),\n                )\n            )\n\n    return filterable_attributes\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_localized_attributes","title":"<code>get_localized_attributes()</code>  <code>async</code>","text":"<p>Get localized attributes settings for the index.</p> <p>Returns:</p> Type Description <code>list[LocalizedAttributes] | None</code> <p>Localized attributes for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     localized_attributes = await index.get_localized_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_localized_attributes(self) -&gt; list[LocalizedAttributes] | None:\n    \"\"\"Get localized attributes settings for the index.\n\n    Returns:\n        Localized attributes for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     localized_attributes = await index.get_localized_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/localized-attributes\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    return [LocalizedAttributes(**x) for x in self._http_requests.parse_json(response)]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_non_separator_tokens","title":"<code>get_non_separator_tokens()</code>  <code>async</code>","text":"<p>Get non-separator token settings for the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Non-separator tokens for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     non_separator_token_settings = await index.get_non_separator_tokens()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_non_separator_tokens(self) -&gt; list[str]:\n    \"\"\"Get non-separator token settings for the index.\n\n    Returns:\n        Non-separator tokens for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     non_separator_token_settings = await index.get_non_separator_tokens()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/non-separator-tokens\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_pagination","title":"<code>get_pagination()</code>  <code>async</code>","text":"<p>Get pagination settings for the index.</p> <p>Returns:</p> Type Description <code>Pagination</code> <p>Pagination for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     pagination_settings = await index.get_pagination()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_pagination(self) -&gt; Pagination:\n    \"\"\"Get pagination settings for the index.\n\n    Returns:\n        Pagination for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     pagination_settings = await index.get_pagination()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/pagination\")\n\n    return Pagination(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_prefix_search","title":"<code>get_prefix_search()</code>  <code>async</code>","text":"<p>Get setting for prefix search opt-out.</p> <p>Returns:</p> Type Description <code>str</code> <p>True if prefix search is enabled or False if not.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = await client.index(\"movies\")     &gt;&gt;&gt;     prefix_search = await index.get_prefix_search()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_prefix_search(self) -&gt; str:\n    \"\"\"Get setting for prefix search opt-out.\n\n    Returns:\n        True if prefix search is enabled or False if not.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.index(\"movies\")\n        &gt;&gt;&gt;     prefix_search = await index.get_prefix_search()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/prefix-search\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_primary_key","title":"<code>get_primary_key()</code>  <code>async</code>","text":"<p>Get the primary key.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The primary key for the documents in the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     primary_key = await index.get_primary_key()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_primary_key(self) -&gt; str | None:\n    \"\"\"Get the primary key.\n\n    Returns:\n        The primary key for the documents in the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     primary_key = await index.get_primary_key()\n    \"\"\"\n    info = await self.fetch_info()\n    return info.primary_key\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_proximity_precision","title":"<code>get_proximity_precision()</code>  <code>async</code>","text":"<p>Get proximity precision settings for the index.</p> <p>Returns:</p> Type Description <code>ProximityPrecision</code> <p>Proximity precision for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     proximity_precision = await index.get_proximity_precision()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_proximity_precision(self) -&gt; ProximityPrecision:\n    \"\"\"Get proximity precision settings for the index.\n\n    Returns:\n        Proximity precision for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     proximity_precision = await index.get_proximity_precision()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/proximity-precision\")\n\n    return ProximityPrecision[to_snake(self._http_requests.parse_json(response)).upper()]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_ranking_rules","title":"<code>get_ranking_rules()</code>  <code>async</code>","text":"<p>Get ranking rules of the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List containing the ranking rules of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     ranking_rules = await index.get_ranking_rules()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_ranking_rules(self) -&gt; list[str]:\n    \"\"\"Get ranking rules of the index.\n\n    Returns:\n        List containing the ranking rules of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     ranking_rules = await index.get_ranking_rules()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/ranking-rules\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_search_cutoff_ms","title":"<code>get_search_cutoff_ms()</code>  <code>async</code>","text":"<p>Get search cutoff time in ms.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>Integer representing the search cutoff time in ms, or None.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     search_cutoff_ms_settings = await index.get_search_cutoff_ms()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_search_cutoff_ms(self) -&gt; int | None:\n    \"\"\"Get search cutoff time in ms.\n\n    Returns:\n        Integer representing the search cutoff time in ms, or None.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_cutoff_ms_settings = await index.get_search_cutoff_ms()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/search-cutoff-ms\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_searchable_attributes","title":"<code>get_searchable_attributes()</code>  <code>async</code>","text":"<p>Get searchable attributes of the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List containing the searchable attributes of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     searchable_attributes = await index.get_searchable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_searchable_attributes(self) -&gt; list[str]:\n    \"\"\"Get searchable attributes of the index.\n\n    Returns:\n        List containing the searchable attributes of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     searchable_attributes = await index.get_searchable_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/searchable-attributes\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_separator_tokens","title":"<code>get_separator_tokens()</code>  <code>async</code>","text":"<p>Get separator token settings for the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Separator tokens for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     separator_token_settings = await index.get_separator_tokens()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_separator_tokens(self) -&gt; list[str]:\n    \"\"\"Get separator token settings for the index.\n\n    Returns:\n        Separator tokens for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     separator_token_settings = await index.get_separator_tokens()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/separator-tokens\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_settings","title":"<code>get_settings()</code>  <code>async</code>","text":"<p>Get settings of the index.</p> <p>Returns:</p> Type Description <code>MeilisearchSettings</code> <p>Settings of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     settings = await index.get_settings()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_settings(self) -&gt; MeilisearchSettings:\n    \"\"\"Get settings of the index.\n\n    Returns:\n        Settings of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     settings = await index.get_settings()\n    \"\"\"\n    response = await self._http_requests.get(self._settings_url)\n    response_json = self._http_requests.parse_json(response)\n    settings = MeilisearchSettings(**response_json)\n\n    if response_json.get(\"embedders\"):\n        # Not coverted because it times out. It isn't an issue with the code here.\n        # https://github.com/meilisearch/meilisearch/issues/4585\n        settings.embedders = embedder_json_to_settings_model(  # pragma: no cover\n            response_json[\"embedders\"]\n        )\n\n    return settings\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_sortable_attributes","title":"<code>get_sortable_attributes()</code>  <code>async</code>","text":"<p>Get sortable attributes of the AsyncIndex.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List containing the sortable attributes of the AsyncIndex.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     sortable_attributes = await index.get_sortable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_sortable_attributes(self) -&gt; list[str]:\n    \"\"\"Get sortable attributes of the AsyncIndex.\n\n    Returns:\n        List containing the sortable attributes of the AsyncIndex.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     sortable_attributes = await index.get_sortable_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/sortable-attributes\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_stats","title":"<code>get_stats()</code>  <code>async</code>","text":"<p>Get stats of the index.</p> <p>Returns:</p> Type Description <code>IndexStats</code> <p>Stats of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     stats = await index.get_stats()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_stats(self) -&gt; IndexStats:\n    \"\"\"Get stats of the index.\n\n    Returns:\n        Stats of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     stats = await index.get_stats()\n    \"\"\"\n    response = await self._http_requests.get(self._stats_url)\n\n    return IndexStats(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_stop_words","title":"<code>get_stop_words()</code>  <code>async</code>","text":"<p>Get stop words of the index.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>List containing the stop words of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     stop_words = await index.get_stop_words()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_stop_words(self) -&gt; list[str] | None:\n    \"\"\"Get stop words of the index.\n\n    Returns:\n        List containing the stop words of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     stop_words = await index.get_stop_words()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/stop-words\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_synonyms","title":"<code>get_synonyms()</code>  <code>async</code>","text":"<p>Get synonyms of the index.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]] | None</code> <p>The synonyms of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     synonyms = await index.get_synonyms()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_synonyms(self) -&gt; dict[str, list[str]] | None:\n    \"\"\"Get synonyms of the index.\n\n    Returns:\n        The synonyms of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     synonyms = await index.get_synonyms()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/synonyms\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_typo_tolerance","title":"<code>get_typo_tolerance()</code>  <code>async</code>","text":"<p>Get typo tolerance for the index.</p> <p>Returns:</p> Type Description <code>TypoTolerance</code> <p>TypoTolerance for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     sortable_attributes = await index.get_typo_tolerance()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_typo_tolerance(self) -&gt; TypoTolerance:\n    \"\"\"Get typo tolerance for the index.\n\n    Returns:\n        TypoTolerance for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     sortable_attributes = await index.get_typo_tolerance()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/typo-tolerance\")\n\n    return TypoTolerance(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_word_dictionary","title":"<code>get_word_dictionary()</code>  <code>async</code>","text":"<p>Get word dictionary settings for the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Word dictionary for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     word_dictionary = await index.get_word_dictionary()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def get_word_dictionary(self) -&gt; list[str]:\n    \"\"\"Get word dictionary settings for the index.\n\n    Returns:\n        Word dictionary for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     word_dictionary = await index.get_word_dictionary()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/dictionary\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_displayed_attributes","title":"<code>reset_displayed_attributes()</code>  <code>async</code>","text":"<p>Reset displayed attributes of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_displayed_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_displayed_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset displayed attributes of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_displayed_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/displayed-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_distinct_attribute","title":"<code>reset_distinct_attribute()</code>  <code>async</code>","text":"<p>Reset distinct attribute of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_distinct_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_distinct_attribute(self) -&gt; TaskInfo:\n    \"\"\"Reset distinct attribute of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_distinct_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/distinct-attribute\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_embedders","title":"<code>reset_embedders()</code>  <code>async</code>","text":"<p>Reset an index's embedders settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_embedders()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_embedders(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's embedders settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_embedders()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/embedders\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_facet_search","title":"<code>reset_facet_search()</code>  <code>async</code>","text":"<p>Reset the facet search opt-out settings.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_facet_search()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_facet_search(self) -&gt; TaskInfo:\n    \"\"\"Reset the facet search opt-out settings.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_facet_search()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/facet-search\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_faceting","title":"<code>reset_faceting()</code>  <code>async</code>","text":"<p>Reset an index's faceting settings to their default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_faceting()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_faceting(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's faceting settings to their default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_faceting()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/faceting\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_filterable_attributes","title":"<code>reset_filterable_attributes()</code>  <code>async</code>","text":"<p>Reset filterable attributes of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_filterable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_filterable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset filterable attributes of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_filterable_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/filterable-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_localized_attributes","title":"<code>reset_localized_attributes()</code>  <code>async</code>","text":"<p>Reset an index's localized attributes settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_localized_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_localized_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's localized attributes settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_localized_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/localized-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_non_separator_tokens","title":"<code>reset_non_separator_tokens()</code>  <code>async</code>","text":"<p>Reset an index's non-separator tokens settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_non_separator_tokens()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_non_separator_tokens(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's non-separator tokens settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_non_separator_tokens()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/non-separator-tokens\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_pagination","title":"<code>reset_pagination()</code>  <code>async</code>","text":"<p>Reset an index's pagination settings to their default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_pagination()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_pagination(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's pagination settings to their default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_pagination()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/pagination\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_prefix_search","title":"<code>reset_prefix_search()</code>  <code>async</code>","text":"<p>Reset the prefix search opt-out settings.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = await client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_prefix_search()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_prefix_search(self) -&gt; TaskInfo:\n    \"\"\"Reset the prefix search opt-out settings.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_prefix_search()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/prefix-search\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_proximity_precision","title":"<code>reset_proximity_precision()</code>  <code>async</code>","text":"<p>Reset an index's proximity precision settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_proximity_precision()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_proximity_precision(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's proximity precision settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_proximity_precision()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/proximity-precision\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_ranking_rules","title":"<code>reset_ranking_rules()</code>  <code>async</code>","text":"<p>Reset ranking rules of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_ranking_rules()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_ranking_rules(self) -&gt; TaskInfo:\n    \"\"\"Reset ranking rules of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_ranking_rules()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/ranking-rules\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_search_cutoff_ms","title":"<code>reset_search_cutoff_ms()</code>  <code>async</code>","text":"<p>Reset the search cutoff time to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_search_cutoff_ms()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_search_cutoff_ms(self) -&gt; TaskInfo:\n    \"\"\"Reset the search cutoff time to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_search_cutoff_ms()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/search-cutoff-ms\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_searchable_attributes","title":"<code>reset_searchable_attributes()</code>  <code>async</code>","text":"<p>Reset searchable attributes of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_searchable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_searchable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset searchable attributes of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_searchable_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/searchable-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_separator_tokens","title":"<code>reset_separator_tokens()</code>  <code>async</code>","text":"<p>Reset an index's separator tokens settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_separator_tokens()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_separator_tokens(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's separator tokens settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_separator_tokens()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/separator-tokens\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_settings","title":"<code>reset_settings()</code>  <code>async</code>","text":"<p>Reset settings of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_settings()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_settings(self) -&gt; TaskInfo:\n    \"\"\"Reset settings of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_settings()\n    \"\"\"\n    response = await self._http_requests.delete(self._settings_url)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_sortable_attributes","title":"<code>reset_sortable_attributes()</code>  <code>async</code>","text":"<p>Reset sortable attributes of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_sortable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_sortable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset sortable attributes of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_sortable_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/sortable-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_stop_words","title":"<code>reset_stop_words()</code>  <code>async</code>","text":"<p>Reset stop words of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_stop_words()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_stop_words(self) -&gt; TaskInfo:\n    \"\"\"Reset stop words of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_stop_words()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/stop-words\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_synonyms","title":"<code>reset_synonyms()</code>  <code>async</code>","text":"<p>Reset synonyms of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_synonyms()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_synonyms(self) -&gt; TaskInfo:\n    \"\"\"Reset synonyms of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_synonyms()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/synonyms\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_typo_tolerance","title":"<code>reset_typo_tolerance()</code>  <code>async</code>","text":"<p>Reset typo tolerance to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_typo_tolerance()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_typo_tolerance(self) -&gt; TaskInfo:\n    \"\"\"Reset typo tolerance to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_typo_tolerance()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/typo-tolerance\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_word_dictionary","title":"<code>reset_word_dictionary()</code>  <code>async</code>","text":"<p>Reset an index's word dictionary settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_word_dictionary()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def reset_word_dictionary(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's word dictionary settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_word_dictionary()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/dictionary\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.search","title":"<code>search(query=None, *, offset=0, limit=20, filter=None, facets=None, attributes_to_retrieve=None, attributes_to_crop=None, crop_length=200, attributes_to_highlight=None, sort=None, show_matches_position=False, highlight_pre_tag='&lt;em&gt;', highlight_post_tag='&lt;/em&gt;', crop_marker='...', matching_strategy='last', hits_per_page=None, page=None, attributes_to_search_on=None, distinct=None, show_ranking_score=False, show_ranking_score_details=False, ranking_score_threshold=None, vector=None, hybrid=None, locales=None, retrieve_vectors=None, media=None, show_performance_details=False)</code>  <code>async</code>","text":"<p>Search the index.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>String containing the word(s) to search</p> <code>None</code> <code>offset</code> <code>int</code> <p>Number of documents to skip. Defaults to 0.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of documents returned. Defaults to 20.</p> <code>20</code> <code>filter</code> <code>Filter | None</code> <p>Filter queries by an attribute value. Defaults to None.</p> <code>None</code> <code>facets</code> <code>list[str] | None</code> <p>Facets for which to retrieve the matching count. Defaults to None.</p> <code>None</code> <code>attributes_to_retrieve</code> <code>list[str] | None</code> <p>Attributes to display in the returned documents. Defaults to [\"*\"].</p> <code>None</code> <code>attributes_to_crop</code> <code>list[str] | None</code> <p>Attributes whose values have to be cropped. Defaults to None.</p> <code>None</code> <code>crop_length</code> <code>int</code> <p>The maximum number of words to display. Defaults to 200.</p> <code>200</code> <code>attributes_to_highlight</code> <code>list[str] | None</code> <p>Attributes whose values will contain highlighted matching terms. Defaults to None.</p> <code>None</code> <code>sort</code> <code>list[str] | None</code> <p>Attributes by which to sort the results. Defaults to None.</p> <code>None</code> <code>show_matches_position</code> <code>bool</code> <p>Defines whether an object that contains information about the matches should be returned or not. Defaults to False.</p> <code>False</code> <code>highlight_pre_tag</code> <code>str</code> <p>The opening tag for highlighting text. Defaults to . <code>'&lt;em&gt;'</code> <code>highlight_post_tag</code> <code>str</code> <p>The closing tag for highlighting text. Defaults to </p> <code>'&lt;/em&gt;'</code> <code>crop_marker</code> <code>str</code> <p>Marker to display when the number of words exceeds the <code>crop_length</code>. Defaults to ...</p> <code>'...'</code> <code>matching_strategy</code> <code>Literal['all', 'last', 'frequency']</code> <p>Specifies the matching strategy Meilisearch should use. Defaults to <code>last</code>.</p> <code>'last'</code> <code>hits_per_page</code> <code>int | None</code> <p>Sets the number of results returned per page.</p> <code>None</code> <code>page</code> <code>int | None</code> <p>Sets the specific results page to fetch.</p> <code>None</code> <code>attributes_to_search_on</code> <code>list[str] | None</code> <p>List of field names. Allow search over a subset of searchable attributes without modifying the index settings. Defaults to None.</p> <code>None</code> <code>distinct</code> <code>str | None</code> <p>If set the distinct value will return at most one result for the filterable attribute. Note that a filterable attributes must be set for this work. Defaults to None.</p> <code>None</code> <code>show_ranking_score</code> <code>bool</code> <p>If set to True the ranking score will be returned with each document in the search. Defaults to False.</p> <code>False</code> <code>show_ranking_score_details</code> <code>bool</code> <p>If set to True the ranking details will be returned with each document in the search. Defaults to False. Note: This parameter can only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order to use this feature in Meilisearch v1.3.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"scoreDetails\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution. This feature became stable in Meiliseach v1.7.0.</p> <code>False</code> <code>ranking_score_threshold</code> <code>float | None</code> <p>If set, no document whose _rankingScore is under the rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults to None.</p> <code>None</code> <code>vector</code> <code>list[float] | None</code> <p>List of vectors for vector search. Defaults to None. Note: This parameter can only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order to use this feature in Meilisearch v1.3.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"vectorStore\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution.</p> <code>None</code> <code>hybrid</code> <code>Hybrid | None</code> <p>Hybrid search information. Defaults to None. Note: This parameter can only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0. In order to use this feature in Meilisearch v1.6.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"vectorStore\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution.</p> <code>None</code> <code>locales</code> <code>list[str] | None</code> <p>Specifies the languages for the search. This parameter can only be used with Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.</p> <code>None</code> <code>retrieve_vectors</code> <code>bool | None</code> <p>Return document vector data with search result.</p> <code>None</code> <code>media</code> <code>JsonMapping | None</code> <p>The content of media is used as if it were a document to generate request fragments from the searchFragments parameter. Defaults to None. This parameter can only be used with Meilisearch &gt;= v1.16.0. In order to use this feature in Meilisearch v1.16.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"multimodal\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution.</p> <code>None</code> <code>show_performance_details</code> <code>bool</code> <p>When set to true, the search response contains a performance trace. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>SearchResults</code> <p>Results of the search</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     search_results = await index.search(\"Tron\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def search(\n    self,\n    query: str | None = None,\n    *,\n    offset: int = 0,\n    limit: int = 20,\n    filter: Filter | None = None,\n    facets: list[str] | None = None,\n    attributes_to_retrieve: list[str] | None = None,\n    attributes_to_crop: list[str] | None = None,\n    crop_length: int = 200,\n    attributes_to_highlight: list[str] | None = None,\n    sort: list[str] | None = None,\n    show_matches_position: bool = False,\n    highlight_pre_tag: str = \"&lt;em&gt;\",\n    highlight_post_tag: str = \"&lt;/em&gt;\",\n    crop_marker: str = \"...\",\n    matching_strategy: Literal[\"all\", \"last\", \"frequency\"] = \"last\",\n    hits_per_page: int | None = None,\n    page: int | None = None,\n    attributes_to_search_on: list[str] | None = None,\n    distinct: str | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    ranking_score_threshold: float | None = None,\n    vector: list[float] | None = None,\n    hybrid: Hybrid | None = None,\n    locales: list[str] | None = None,\n    retrieve_vectors: bool | None = None,\n    media: JsonMapping | None = None,\n    show_performance_details: bool = False,\n) -&gt; SearchResults:\n    \"\"\"Search the index.\n\n    Args:\n        query: String containing the word(s) to search\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        facets: Facets for which to retrieve the matching count. Defaults to None.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n        crop_length: The maximum number of words to display. Defaults to 200.\n        attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n            Defaults to None.\n        sort: Attributes by which to sort the results. Defaults to None.\n        show_matches_position: Defines whether an object that contains information about the\n            matches should be returned or not. Defaults to False.\n        highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n        highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n        crop_marker: Marker to display when the number of words exceeds the `crop_length`.\n            Defaults to ...\n        matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to\n            `last`.\n        hits_per_page: Sets the number of results returned per page.\n        page: Sets the specific results page to fetch.\n        attributes_to_search_on: List of field names. Allow search over a subset of searchable\n            attributes without modifying the index settings. Defaults to None.\n        distinct: If set the distinct value will return at most one result for the\n            filterable attribute. Note that a filterable attributes must be set for this work.\n            Defaults to None.\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n            to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n            sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n            Because this feature is experimental it may be removed or updated causing breaking\n            changes in this library without a major version bump so use with caution. This\n            feature became stable in Meiliseach v1.7.0.\n        ranking_score_threshold: If set, no document whose _rankingScore is under the\n            rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n            to None.\n        vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n            In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n        hybrid: Hybrid search information. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n            In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n        locales: Specifies the languages for the search. This parameter can only be used with\n            Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.\n        retrieve_vectors: Return document vector data with search result.\n        media: The content of media is used as if it were a document to generate request\n            fragments from the searchFragments parameter. Defaults to None. This parameter can\n            only be used with Meilisearch &gt;= v1.16.0. In order to use this feature in\n            Meilisearch v1.16.0 you first need to enable the feature by sending a PATCH request\n            to /experimental-features with { \"multimodal\": true }. Because this feature is\n            experimental it may be removed or updated causing breaking changes in this library\n            without a major version bump so use with caution.\n        show_performance_details: When set to true, the search response contains a performance\n            trace. Default False.\n\n    Returns:\n        Results of the search\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_results = await index.search(\"Tron\")\n    \"\"\"\n    if ranking_score_threshold:\n        validate_ranking_score_threshold(ranking_score_threshold)\n\n    body = process_search_parameters(\n        q=query,\n        offset=offset,\n        limit=limit,\n        filter=filter,\n        facets=facets,\n        attributes_to_retrieve=attributes_to_retrieve,\n        attributes_to_crop=attributes_to_crop,\n        crop_length=crop_length,\n        attributes_to_highlight=attributes_to_highlight,\n        sort=sort,\n        show_matches_position=show_matches_position,\n        highlight_pre_tag=highlight_pre_tag,\n        highlight_post_tag=highlight_post_tag,\n        crop_marker=crop_marker,\n        matching_strategy=matching_strategy,\n        hits_per_page=hits_per_page,\n        page=page,\n        attributes_to_search_on=attributes_to_search_on,\n        distinct=distinct,\n        show_ranking_score=show_ranking_score,\n        show_ranking_score_details=show_ranking_score_details,\n        vector=vector,\n        hybrid=hybrid,\n        ranking_score_threshold=ranking_score_threshold,\n        locales=locales,\n        retrieve_vectors=retrieve_vectors,\n        media=media,\n        show_performance_details=show_performance_details,\n    )\n    search_url = f\"{self._base_url_with_uid}/search\"\n\n    if self._pre_search_plugins:\n        await _run_plugins(\n            self._pre_search_plugins,\n            AsyncEvent.PRE,\n            query=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            distinct=distinct,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n            hybrid=hybrid,\n        )\n\n    if self._concurrent_search_plugins:\n        if not use_task_groups():\n            concurrent_tasks: Any = []\n            for plugin in self._concurrent_search_plugins:\n                if plugin_has_method(plugin, \"run_plugin\"):\n                    concurrent_tasks.append(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            query=query,\n                            offset=offset,\n                            limit=limit,\n                            filter=filter,\n                            facets=facets,\n                            attributes_to_retrieve=attributes_to_retrieve,\n                            attributes_to_crop=attributes_to_crop,\n                            crop_length=crop_length,\n                            attributes_to_highlight=attributes_to_highlight,\n                            sort=sort,\n                            show_matches_position=show_matches_position,\n                            highlight_pre_tag=highlight_pre_tag,\n                            highlight_post_tag=highlight_post_tag,\n                            crop_marker=crop_marker,\n                            matching_strategy=matching_strategy,\n                            hits_per_page=hits_per_page,\n                            page=page,\n                            attributes_to_search_on=attributes_to_search_on,\n                            distinct=distinct,\n                            show_ranking_score=show_ranking_score,\n                            show_ranking_score_details=show_ranking_score_details,\n                            vector=vector,\n                        )\n                    )\n\n            concurrent_tasks.append(self._http_requests.post(search_url, body=body))\n\n            responses = await asyncio.gather(*concurrent_tasks)\n            result = SearchResults[self.hits_type](**responses[-1].json())  # type: ignore[name-defined]\n            if self._post_search_plugins:\n                post = await _run_plugins(\n                    self._post_search_plugins, AsyncEvent.POST, search_results=result\n                )\n                if post.get(\"search_result\"):\n                    result = post[\"search_result\"]\n\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_search_plugins:\n                if plugin_has_method(plugin, \"run_plugin\"):\n                    tg.create_task(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            query=query,\n                            offset=offset,\n                            limit=limit,\n                            filter=filter,\n                            facets=facets,\n                            attributes_to_retrieve=attributes_to_retrieve,\n                            attributes_to_crop=attributes_to_crop,\n                            crop_length=crop_length,\n                            attributes_to_highlight=attributes_to_highlight,\n                            sort=sort,\n                            show_matches_position=show_matches_position,\n                            highlight_pre_tag=highlight_pre_tag,\n                            highlight_post_tag=highlight_post_tag,\n                            crop_marker=crop_marker,\n                            matching_strategy=matching_strategy,\n                            hits_per_page=hits_per_page,\n                            page=page,\n                            attributes_to_search_on=attributes_to_search_on,\n                            distinct=distinct,\n                            show_ranking_score=show_ranking_score,\n                            show_ranking_score_details=show_ranking_score_details,\n                            vector=vector,\n                        )\n                    )\n\n            response_coroutine = tg.create_task(self._http_requests.post(search_url, body=body))\n\n        response = await response_coroutine\n        result = SearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n        if self._post_search_plugins:\n            post = await _run_plugins(\n                self._post_search_plugins, AsyncEvent.POST, search_results=result\n            )\n            if post.get(\"search_result\"):\n                result = post[\"search_result\"]\n\n        return result\n\n    response = await self._http_requests.post(search_url, body=body)\n    result = SearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n\n    if self._post_search_plugins:\n        post = await _run_plugins(\n            self._post_search_plugins, AsyncEvent.POST, search_results=result\n        )\n        if post.get(\"search_result\"):\n            result = post[\"search_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.search_similar_documents","title":"<code>search_similar_documents(id, *, offset=None, limit=None, filter=None, embedder='default', attributes_to_retrieve=None, show_ranking_score=False, show_ranking_score_details=False, ranking_score_threshold=None)</code>  <code>async</code>","text":"<p>Search the index.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id for the target document that is being used to find similar documents.</p> required <code>offset</code> <code>int | None</code> <p>Number of documents to skip. Defaults to 0.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of documents returned. Defaults to 20.</p> <code>None</code> <code>filter</code> <code>str | None</code> <p>Filter queries by an attribute value. Defaults to None.</p> <code>None</code> <code>embedder</code> <code>str</code> <p>The vector DB to use for the search.</p> <code>'default'</code> <code>attributes_to_retrieve</code> <code>list[str] | None</code> <p>Attributes to display in the returned documents. Defaults to [\"*\"].</p> <code>None</code> <code>show_ranking_score</code> <code>bool</code> <p>If set to True the ranking score will be returned with each document in the search. Defaults to False.</p> <code>False</code> <code>show_ranking_score_details</code> <code>bool</code> <p>If set to True the ranking details will be returned with each document in the search. Defaults to False.</p> <code>False</code> <code>ranking_score_threshold</code> <code>float | None</code> <p>If set, no document whose _rankingScore is under the rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>SimilarSearchResults</code> <p>Results of the search</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     search_results = await index.search_similar_documents(\"123\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def search_similar_documents(\n    self,\n    id: str,\n    *,\n    offset: int | None = None,\n    limit: int | None = None,\n    filter: str | None = None,\n    embedder: str = \"default\",\n    attributes_to_retrieve: list[str] | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    ranking_score_threshold: float | None = None,\n) -&gt; SimilarSearchResults:\n    \"\"\"Search the index.\n\n    Args:\n        id: The id for the target document that is being used to find similar documents.\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        embedder: The vector DB to use for the search.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False.\n        ranking_score_threshold: If set, no document whose _rankingScore is under the\n            rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n            to None.\n\n    Returns:\n        Results of the search\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_results = await index.search_similar_documents(\"123\")\n    \"\"\"\n    payload = {\n        \"id\": id,\n        \"filter\": filter,\n        \"embedder\": embedder,\n        \"attributesToRetrieve\": attributes_to_retrieve,\n        \"showRankingScore\": show_ranking_score,\n        \"showRankingScoreDetails\": show_ranking_score_details,\n        \"rankingScoreThreshold\": ranking_score_threshold,\n    }\n\n    if offset:\n        payload[\"offset\"] = offset\n\n    if limit:\n        payload[\"limit\"] = limit\n\n    response = await self._http_requests.post(\n        f\"{self._base_url_with_uid}/similar\", body=payload\n    )\n\n    return SimilarSearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update","title":"<code>update(primary_key)</code>  <code>async</code>","text":"<p>Update the index primary key.</p> <p>Parameters:</p> Name Type Description Default <code>primary_key</code> <code>str</code> <p>The primary key of the documents.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the AsyncIndex with the updated information.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     updated_index = await index.update()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update(self, primary_key: str) -&gt; Self:\n    \"\"\"Update the index primary key.\n\n    Args:\n        primary_key: The primary key of the documents.\n\n    Returns:\n        An instance of the AsyncIndex with the updated information.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     updated_index = await index.update()\n    \"\"\"\n    payload = {\"primaryKey\": primary_key}\n    response = await self._http_requests.patch(self._base_url_with_uid, payload)\n    await async_wait_for_task(\n        self.http_client,\n        self._http_requests.parse_json(response)[\"taskUid\"],\n        timeout_in_ms=100000,\n    )\n    index_response = await self._http_requests.get(f\"{self._base_url_with_uid}\")\n    self.primary_key = self._http_requests.parse_json(index_response)[\"primaryKey\"]\n    return self\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_displayed_attributes","title":"<code>update_displayed_attributes(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update displayed attributes of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[str]</code> <p>List containing the displayed attributes.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_displayed_attributes(     &gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_displayed_attributes(\n    self, body: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update displayed attributes of the index.\n\n    Args:\n        body: List containing the displayed attributes.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_displayed_attributes(\n        &gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]\n        &gt;&gt;&gt;     )\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/displayed-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_distinct_attribute","title":"<code>update_distinct_attribute(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update distinct attribute of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>Distinct attribute.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_distinct_attribute(\"url\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_distinct_attribute(self, body: str, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update distinct attribute of the index.\n\n    Args:\n        body: Distinct attribute.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_distinct_attribute(\"url\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/distinct-attribute\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents","title":"<code>update_documents(documents, primary_key=None, *, custom_metadata=None, skip_creation=False, compress=False)</code>  <code>async</code>","text":"<p>Update documents in the index.</p> <p>Parameters:</p> Name Type Description Default <code>documents</code> <code>Sequence[JsonMapping]</code> <p>List of documents.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_documents(documents)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_documents(\n    self,\n    documents: Sequence[JsonMapping],\n    primary_key: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Update documents in the index.\n\n    Args:\n        documents: List of documents.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents(documents)\n    \"\"\"\n    params = {}\n    if primary_key:\n        params[\"primaryKey\"] = primary_key\n    if custom_metadata:\n        params[\"customMetadata\"] = custom_metadata\n    if skip_creation:\n        params[\"skipCreation\"] = \"true\"\n\n    if params:\n        url = build_encoded_url(self._documents_url, params)\n    else:\n        url = self._documents_url\n\n    if self._pre_update_documents_plugins:\n        pre = await _run_plugins(\n            self._pre_update_documents_plugins,\n            AsyncEvent.PRE,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if pre.get(\"document_result\"):\n            documents = pre[\"document_result\"]\n\n    if self._concurrent_update_documents_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_update_documents_plugins:\n                if plugin_has_method(plugin, \"run_plugin\"):\n                    tasks.append(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n                if plugin_has_method(plugin, \"run_document_plugin\"):\n                    tasks.append(\n                        plugin.run_document_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n\n            tasks.append(self._http_requests.put(url, documents, compress=compress))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_update_documents_plugins:\n                post = await _run_plugins(\n                    self._post_update_documents_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                    documents=documents,\n                    primary_key=primary_key,\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_update_documents_plugins:\n                if plugin_has_method(plugin, \"run_plugin\"):\n                    tg.create_task(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n                if plugin_has_method(plugin, \"run_document_plugin\"):\n                    tg.create_task(\n                        plugin.run_document_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n\n            response_coroutine = tg.create_task(\n                self._http_requests.put(url, documents, compress=compress)\n            )\n\n        response = await response_coroutine\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_update_documents_plugins:\n            post = await _run_plugins(\n                self._post_update_documents_plugins,\n                AsyncEvent.POST,\n                result=result,\n                documents=documents,\n                primary_key=primary_key,\n            )\n\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    response = await self._http_requests.put(url, documents, compress=compress)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_update_documents_plugins:\n        post = await _run_plugins(\n            self._post_update_documents_plugins,\n            AsyncEvent.POST,\n            result=result,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if isinstance(post[\"generic_result\"], TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_directory","title":"<code>update_documents_from_directory(directory_path, *, primary_key=None, custom_metadata=None, document_type='json', csv_delimiter=None, combine_documents=True, skip_creation=False, compress=False)</code>  <code>async</code>","text":"<p>Load all json files from a directory and update the documents.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | str</code> <p>Path to the directory that contains the json files.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>document_type</code> <code>str</code> <p>The type of document being added. Accepted types are json, csv, and ndjson. For csv files the first row of the document should be a header row containing the field names, and ever for should have a title.</p> <code>'json'</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>combine_documents</code> <code>bool</code> <p>If set to True this will combine the documents from all the files before indexing them. Defaults to True.</p> <code>True</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_documents_from_directory(directory_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_documents_from_directory(\n    self,\n    directory_path: Path | str,\n    *,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and update the documents.\n\n    Args:\n        directory_path: Path to the directory that contains the json files.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row containing\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_directory(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                all_documents.append(documents)\n\n        raise_on_no_documents(all_documents, document_type, directory_path)\n\n        loop = asyncio.get_running_loop()\n        combined = await loop.run_in_executor(None, partial(combine_documents_, all_documents))\n\n        response = await self.update_documents(\n            combined,\n            primary_key,\n            custom_metadata=custom_metadata,\n            skip_creation=skip_creation,\n            compress=compress,\n        )\n        return [response]\n\n    if not use_task_groups():\n        update_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                update_documents.append(\n                    self.update_documents(\n                        documents,\n                        primary_key,\n                        custom_metadata=custom_metadata,\n                        skip_creation=skip_creation,\n                        compress=compress,\n                    )\n                )\n\n        raise_on_no_documents(update_documents, document_type, directory_path)\n\n        if len(update_documents) &gt; 1:\n            # Send the first document on its own before starting the gather. Otherwise Meilisearch\n            # returns an error because it thinks all entries are trying to create the same index.\n            first_response = [await update_documents.pop()]\n            responses = await asyncio.gather(*update_documents)\n            responses = [*first_response, *responses]\n        else:\n            responses = [await update_documents[0]]\n\n        return responses\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tasks = []\n        results = []\n        for i, path in enumerate(directory.iterdir()):\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                if i == 0:\n                    results = [\n                        await self.update_documents(\n                            documents,\n                            primary_key,\n                            custom_metadata=custom_metadata,\n                            skip_creation=skip_creation,\n                            compress=compress,\n                        )\n                    ]\n                else:\n                    tasks.append(\n                        tg.create_task(\n                            self.update_documents(\n                                documents,\n                                primary_key,\n                                custom_metadata=custom_metadata,\n                                skip_creation=skip_creation,\n                                compress=compress,\n                            )\n                        )\n                    )\n\n    results = [*results, *[x.result() for x in tasks]]\n    raise_on_no_documents(results, document_type, directory_path)\n    return results\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_directory_in_batches","title":"<code>update_documents_from_directory_in_batches(directory_path, *, batch_size=1000, primary_key=None, custom_metadata=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False, skip_creation=False, concurrency_limit=None)</code>  <code>async</code>","text":"<p>Load all json files from a directory and update the documents.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | str</code> <p>Path to the directory that contains the json files.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>document_type</code> <code>str</code> <p>The type of document being added. Accepted types are json, csv, and ndjson. For csv files the first row of the document should be a header row containing the field names, and ever for should have a title.</p> <code>'json'</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>combine_documents</code> <code>bool</code> <p>If set to True this will combine the documents from all the files before indexing them. Defaults to True.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>concurrency_limit</code> <code>int | None</code> <p>If set this will limit the number of batches that will be sent concurrently. This can be helpful if you find you are overloading the Meilisearch server with requests. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_documents_from_directory_in_batches(directory_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_documents_from_directory_in_batches(\n    self,\n    directory_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n    skip_creation: bool = False,\n    concurrency_limit: int | None = None,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and update the documents.\n\n    Args:\n        directory_path: Path to the directory that contains the json files.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row containing\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        concurrency_limit: If set this will limit the number of batches that will be sent\n            concurrently. This can be helpful if you find you are overloading the Meilisearch\n            server with requests. Defaults to None.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_directory_in_batches(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                all_documents.append(documents)\n\n        raise_on_no_documents(all_documents, document_type, directory_path)\n\n        loop = asyncio.get_running_loop()\n        combined = await loop.run_in_executor(None, partial(combine_documents_, all_documents))\n\n        return await self.update_documents_in_batches(\n            combined,\n            batch_size=batch_size,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            compress=compress,\n            skip_creation=skip_creation,\n            concurrency_limit=concurrency_limit,\n        )\n\n    if not use_task_groups():\n        responses: list[TaskInfo] = []\n\n        update_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                update_documents.append(\n                    self.update_documents_in_batches(\n                        documents,\n                        batch_size=batch_size,\n                        primary_key=primary_key,\n                        custom_metadata=custom_metadata,\n                        compress=compress,\n                        skip_creation=skip_creation,\n                        concurrency_limit=concurrency_limit,\n                    )\n                )\n\n        raise_on_no_documents(update_documents, document_type, directory_path)\n\n        if len(update_documents) &gt; 1:\n            # Send the first document on its own before starting the gather. Otherwise Meilisearch\n            # returns an error because it thinks all entries are trying to create the same index.\n            first_response = await update_documents.pop()\n            responses_gather = await asyncio.gather(*update_documents)\n            responses = [*first_response, *[x for y in responses_gather for x in y]]\n        else:\n            responses = await update_documents[0]\n\n        return responses\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        results = []\n        tasks = []\n        for i, path in enumerate(directory.iterdir()):\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                if i == 0:\n                    results = await self.update_documents_in_batches(\n                        documents,\n                        batch_size=batch_size,\n                        primary_key=primary_key,\n                        custom_metadata=custom_metadata,\n                        compress=compress,\n                        skip_creation=skip_creation,\n                        concurrency_limit=concurrency_limit,\n                    )\n                else:\n                    tasks.append(\n                        tg.create_task(\n                            self.update_documents_in_batches(\n                                documents,\n                                batch_size=batch_size,\n                                primary_key=primary_key,\n                                custom_metadata=custom_metadata,\n                                compress=compress,\n                                skip_creation=skip_creation,\n                                concurrency_limit=concurrency_limit,\n                            )\n                        )\n                    )\n\n    results = [*results, *[x for y in tasks for x in y.result()]]\n    raise_on_no_documents(results, document_type, directory_path)\n    return results\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_file","title":"<code>update_documents_from_file(file_path, primary_key=None, csv_delimiter=None, *, custom_metadata=None, skip_creation=False, compress=False)</code>  <code>async</code>","text":"<p>Add documents in the index from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the json file.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_documents_from_file(file_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_documents_from_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents in the index from a json file.\n\n    Args:\n        file_path: Path to the json file.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_file(file_path)\n    \"\"\"\n    documents = await _async_load_documents_from_file(\n        file_path, csv_delimiter, json_handler=self._json_handler\n    )\n\n    return await self.update_documents(\n        documents,\n        primary_key=primary_key,\n        custom_metadata=custom_metadata,\n        skip_creation=skip_creation,\n        compress=compress,\n    )\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_file_in_batches","title":"<code>update_documents_from_file_in_batches(file_path, *, batch_size=1000, primary_key=None, custom_metadata=None, compress=False, skip_creation=False, concurrency_limit=None)</code>  <code>async</code>","text":"<p>Updates documents form a json file in batches to reduce RAM usage with indexing.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the json file.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>concurrency_limit</code> <code>int | None</code> <p>If set this will limit the number of batches that will be sent concurrently. This can be helpful if you find you are overloading the Meilisearch server with requests. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_documents_from_file_in_batches(file_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_documents_from_file_in_batches(\n    self,\n    file_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    compress: bool = False,\n    skip_creation: bool = False,\n    concurrency_limit: int | None = None,\n) -&gt; list[TaskInfo]:\n    \"\"\"Updates documents form a json file in batches to reduce RAM usage with indexing.\n\n    Args:\n        file_path: Path to the json file.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        concurrency_limit: If set this will limit the number of batches that will be sent\n            concurrently. This can be helpful if you find you are overloading the Meilisearch\n            server with requests. Defaults to None.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_file_in_batches(file_path)\n    \"\"\"\n    documents = await _async_load_documents_from_file(\n        file_path, json_handler=self._json_handler\n    )\n\n    return await self.update_documents_in_batches(\n        documents,\n        batch_size=batch_size,\n        primary_key=primary_key,\n        custom_metadata=custom_metadata,\n        compress=compress,\n        skip_creation=skip_creation,\n        concurrency_limit=concurrency_limit,\n    )\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_raw_file","title":"<code>update_documents_from_raw_file(file_path, primary_key=None, csv_delimiter=None, *, custom_metadata=None, skip_creation=False, compress=False)</code>  <code>async</code>","text":"<p>Directly send csv or ndjson files to Meilisearch without pre-processing.</p> <p>The can reduce RAM usage from Meilisearch during indexing, but does not include the option for batching.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>The path to the file to send to Meilisearch. Only csv and ndjson files are allowed.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is not a csv or ndjson file, or if a csv_delimiter is sent for a non-csv file.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_documents_from_raw_file(file_path)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_documents_from_raw_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n    The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n    for batching.\n\n    Args:\n        file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n            allowed.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n            a non-csv file.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_raw_file(file_path)\n    \"\"\"\n    upload_path, content_type = prepare_raw_file_upload(file_path, csv_delimiter)\n    parameters = {}\n\n    if primary_key:\n        parameters[\"primaryKey\"] = primary_key\n    if csv_delimiter:\n        parameters[\"csvDelimiter\"] = csv_delimiter\n    if custom_metadata:\n        parameters[\"customMetadata\"] = custom_metadata\n    if skip_creation:\n        parameters[\"skipCreation\"] = \"true\"\n\n    if parameters:\n        url = build_encoded_url(self._documents_url, parameters)\n    else:\n        url = self._documents_url\n\n    async with aiofiles.open(upload_path) as f:\n        data = await f.read()\n\n    response = await self._http_requests.put(\n        url, body=data, content_type=content_type, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_in_batches","title":"<code>update_documents_in_batches(documents, *, batch_size=1000, primary_key=None, custom_metadata=None, compress=False, skip_creation=False, concurrency_limit=None)</code>  <code>async</code>","text":"<p>Update documents in batches to reduce RAM usage with indexing.</p> <p>Each batch tries to fill the max_payload_size</p> <p>Parameters:</p> Name Type Description Default <code>documents</code> <code>Sequence[JsonMapping]</code> <p>List of documents.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>concurrency_limit</code> <code>int | None</code> <p>If set this will limit the number of batches that will be sent concurrently. This can be helpful if you find you are overloading the Meilisearch server with requests. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_documents_in_batches(documents)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_documents_in_batches(\n    self,\n    documents: Sequence[JsonMapping],\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    compress: bool = False,\n    skip_creation: bool = False,\n    concurrency_limit: int | None = None,\n) -&gt; list[TaskInfo]:\n    \"\"\"Update documents in batches to reduce RAM usage with indexing.\n\n    Each batch tries to fill the max_payload_size\n\n    Args:\n        documents: List of documents.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        concurrency_limit: If set this will limit the number of batches that will be sent\n            concurrently. This can be helpful if you find you are overloading the Meilisearch\n            server with requests. Defaults to None.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_in_batches(documents)\n    \"\"\"\n    if concurrency_limit:\n        semaphore = asyncio.Semaphore(concurrency_limit)\n\n        async def update_batch_with_limit(batch_data: Sequence[JsonMapping]) -&gt; TaskInfo:\n            async with semaphore:\n                return await self.update_documents(\n                    batch_data,\n                    primary_key=primary_key,\n                    custom_metadata=custom_metadata,\n                    skip_creation=skip_creation,\n                    compress=compress,\n                )\n\n        if not use_task_groups():\n            batches = [update_batch_with_limit(x) for x in batch(documents, batch_size)]\n            return await asyncio.gather(*batches)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = [\n                tg.create_task(update_batch_with_limit(x)) for x in batch(documents, batch_size)\n            ]\n        return [x.result() for x in tasks]\n\n    if not use_task_groups():\n        batches = [\n            self.update_documents(\n                x,\n                primary_key,\n                custom_metadata=custom_metadata,\n                skip_creation=skip_creation,\n                compress=compress,\n            )\n            for x in batch(documents, batch_size)\n        ]\n        return await asyncio.gather(*batches)\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tasks = [\n            tg.create_task(\n                self.update_documents(\n                    x,\n                    primary_key,\n                    custom_metadata=custom_metadata,\n                    skip_creation=skip_creation,\n                    compress=compress,\n                )\n            )\n            for x in batch(documents, batch_size)\n        ]\n    return [x.result() for x in tasks]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_embedders","title":"<code>update_embedders(embedders, *, compress=False)</code>  <code>async</code>","text":"<p>Update the embedders settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>embedders</code> <code>Embedders</code> <p>The embedders value.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder     &gt;&gt;&gt;     &gt;&gt;&gt;     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_embedders(     &gt;&gt;&gt;         Embedders(embedders={\"default\": UserProvidedEmbedder(dimensions=512)})     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_embedders(self, embedders: Embedders, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update the embedders settings for an index.\n\n    Args:\n        embedders: The embedders value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_embedders(\n        &gt;&gt;&gt;         Embedders(embedders={\"default\": UserProvidedEmbedder(dimensions=512)})\n        &gt;&gt;&gt;     )\n    \"\"\"\n    payload = {}\n    for key, embedder in embedders.embedders.items():\n        payload[key] = {\n            k: v\n            for k, v in embedder.model_dump(by_alias=True, exclude_none=True).items()\n            if v is not None\n        }\n\n    response = await self._http_requests.patch(\n        f\"{self._settings_url}/embedders\", payload, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_facet_search","title":"<code>update_facet_search(facet_search, *, compress=False)</code>  <code>async</code>","text":"<p>Update setting for facet search opt-out.</p> <p>Parameters:</p> Name Type Description Default <code>facet_search</code> <code>bool</code> <p>Boolean indicating if facet search should be disabled.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_facet_search(True)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_facet_search(self, facet_search: bool, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update setting for facet search opt-out.\n\n    Args:\n        facet_search: Boolean indicating if facet search should be disabled.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_facet_search(True)\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/facet-search\",\n        facet_search,\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_faceting","title":"<code>update_faceting(faceting, *, compress=False)</code>  <code>async</code>","text":"<p>Partially update the faceting settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>faceting</code> <code>Faceting</code> <p>Faceting values.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_faceting(faceting=Faceting(max_values_per_facet=100))</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_faceting(self, faceting: Faceting, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Partially update the faceting settings for an index.\n\n    Args:\n        faceting: Faceting values.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n    \"\"\"\n    response = await self._http_requests.patch(\n        f\"{self._settings_url}/faceting\",\n        faceting.model_dump(by_alias=True),\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_filterable_attributes","title":"<code>update_filterable_attributes(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update filterable attributes of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[str | FilterableAttributes]</code> <p>List containing the filterable attributes of the index.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_filterable_attributes([\"genre\", \"director\"])</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_filterable_attributes(\n    self, body: list[str | FilterableAttributes], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update filterable attributes of the index.\n\n    Args:\n        body: List containing the filterable attributes of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_filterable_attributes([\"genre\", \"director\"])\n    \"\"\"\n    payload: list[str | JsonDict] = []\n\n    for b in body:\n        if isinstance(b, FilterableAttributes):\n            payload.append(b.model_dump(by_alias=True))\n        else:\n            payload.append(b)\n\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/filterable-attributes\", payload, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_localized_attributes","title":"<code>update_localized_attributes(localized_attributes, *, compress=False)</code>  <code>async</code>","text":"<p>Update the localized attributes settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>localized_attributes</code> <code>list[LocalizedAttributes]</code> <p>The localized attributes value.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import LocalizedAttributes     &gt;&gt;&gt;     &gt;&gt;&gt;     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_localized_attributes([     &gt;&gt;&gt;         LocalizedAttributes(locales=[\"eng\", \"spa\"], attribute_patterns=[\"\"]),     &gt;&gt;&gt;         LocalizedAttributes(locales=[\"ita\"], attribute_patterns=[\"_it\"]),     &gt;&gt;&gt;     ])</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_localized_attributes(\n    self, localized_attributes: list[LocalizedAttributes], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the localized attributes settings for an index.\n\n    Args:\n        localized_attributes: The localized attributes value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import LocalizedAttributes\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_localized_attributes([\n        &gt;&gt;&gt;         LocalizedAttributes(locales=[\"eng\", \"spa\"], attribute_patterns=[\"*\"]),\n        &gt;&gt;&gt;         LocalizedAttributes(locales=[\"ita\"], attribute_patterns=[\"*_it\"]),\n        &gt;&gt;&gt;     ])\n    \"\"\"\n    payload = [x.model_dump(by_alias=True) for x in localized_attributes]\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/localized-attributes\", payload, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_non_separator_tokens","title":"<code>update_non_separator_tokens(non_separator_tokens, *, compress=False)</code>  <code>async</code>","text":"<p>Update the non-separator tokens settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>non_separator_tokens</code> <code>list[str]</code> <p>List of non-separator tokens.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_non_separator_tokens(\n    self, non_separator_tokens: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the non-separator tokens settings for an index.\n\n    Args:\n        non_separator_tokens: List of non-separator tokens.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/non-separator-tokens\", non_separator_tokens, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_pagination","title":"<code>update_pagination(settings, *, compress=False)</code>  <code>async</code>","text":"<p>Partially update the pagination settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Pagination</code> <p>settings for pagination.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_pagination(settings=Pagination(max_total_hits=123))</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_pagination(self, settings: Pagination, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Partially update the pagination settings for an index.\n\n    Args:\n        settings: settings for pagination.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_pagination(settings=Pagination(max_total_hits=123))\n    \"\"\"\n    response = await self._http_requests.patch(\n        f\"{self._settings_url}/pagination\",\n        settings.model_dump(by_alias=True),\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_prefix_search","title":"<code>update_prefix_search(prefix_search, *, compress=False)</code>  <code>async</code>","text":"<p>Update setting for prefix search opt-out.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_search</code> <code>Literal['disabled', 'indexingTime', 'searchTime']</code> <p>Value indicating prefix search setting.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = await client.index(\"movies\")     &gt;&gt;&gt;     await index.update_prefix_search(\"disabled\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_prefix_search(\n    self,\n    prefix_search: Literal[\"disabled\", \"indexingTime\", \"searchTime\"],\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Update setting for prefix search opt-out.\n\n    Args:\n        prefix_search: Value indicating prefix search setting.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_prefix_search(\"disabled\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/prefix-search\",\n        prefix_search,\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_proximity_precision","title":"<code>update_proximity_precision(proximity_precision, *, compress=False)</code>  <code>async</code>","text":"<p>Update the proximity precision settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>proximity_precision</code> <code>ProximityPrecision</code> <p>The proximity precision value.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_proximity_precision(\n    self, proximity_precision: ProximityPrecision, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the proximity precision settings for an index.\n\n    Args:\n        proximity_precision: The proximity precision value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/proximity-precision\",\n        proximity_precision.value,\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_ranking_rules","title":"<code>update_ranking_rules(ranking_rules, *, compress=False)</code>  <code>async</code>","text":"<p>Update ranking rules of the index.</p> <p>Parameters:</p> Name Type Description Default <code>ranking_rules</code> <code>list[str]</code> <p>List containing the ranking rules.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; ranking_rules=[     &gt;&gt;&gt;      \"words\",     &gt;&gt;&gt;      \"typo\",     &gt;&gt;&gt;      \"proximity\",     &gt;&gt;&gt;      \"attribute\",     &gt;&gt;&gt;      \"sort\",     &gt;&gt;&gt;      \"exactness\",     &gt;&gt;&gt;      \"release_date:desc\",     &gt;&gt;&gt;      \"rank:desc\",     &gt;&gt;&gt; ],     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_ranking_rules(ranking_rules)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_ranking_rules(\n    self, ranking_rules: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update ranking rules of the index.\n\n    Args:\n        ranking_rules: List containing the ranking rules.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; ranking_rules=[\n        &gt;&gt;&gt;      \"words\",\n        &gt;&gt;&gt;      \"typo\",\n        &gt;&gt;&gt;      \"proximity\",\n        &gt;&gt;&gt;      \"attribute\",\n        &gt;&gt;&gt;      \"sort\",\n        &gt;&gt;&gt;      \"exactness\",\n        &gt;&gt;&gt;      \"release_date:desc\",\n        &gt;&gt;&gt;      \"rank:desc\",\n        &gt;&gt;&gt; ],\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_ranking_rules(ranking_rules)\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/ranking-rules\", ranking_rules, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_search_cutoff_ms","title":"<code>update_search_cutoff_ms(search_cutoff_ms, *, compress=False)</code>  <code>async</code>","text":"<p>Update the search cutoff for an index.</p> <p>Parameters:</p> Name Type Description Default <code>search_cutoff_ms</code> <code>int</code> <p>Integer value of the search cutoff time in ms.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_search_cutoff_ms(100)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_search_cutoff_ms(\n    self, search_cutoff_ms: int, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the search cutoff for an index.\n\n    Args:\n        search_cutoff_ms: Integer value of the search cutoff time in ms.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_search_cutoff_ms(100)\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/search-cutoff-ms\", search_cutoff_ms, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_searchable_attributes","title":"<code>update_searchable_attributes(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update searchable attributes of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[str]</code> <p>List containing the searchable attributes.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_searchable_attributes([\"title\", \"description\", \"genre\"])</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_searchable_attributes(\n    self, body: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update searchable attributes of the index.\n\n    Args:\n        body: List containing the searchable attributes.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/searchable-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_separator_tokens","title":"<code>update_separator_tokens(separator_tokens, *, compress=False)</code>  <code>async</code>","text":"<p>Update the separator tokens settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>separator_tokens</code> <code>list[str]</code> <p>List of separator tokens.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_separator_tokens(\n    self, separator_tokens: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the separator tokens settings for an index.\n\n    Args:\n        separator_tokens: List of separator tokens.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/separator-tokens\", separator_tokens, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_settings","title":"<code>update_settings(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update settings of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>MeilisearchSettings</code> <p>Settings of the index.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings     &gt;&gt;&gt; new_settings = MeilisearchSettings(     &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},     &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],     &gt;&gt;&gt;     ranking_rules=[     &gt;&gt;&gt;         \"words\",     &gt;&gt;&gt;         \"typo\",     &gt;&gt;&gt;         \"proximity\",     &gt;&gt;&gt;         \"attribute\",     &gt;&gt;&gt;         \"sort\",     &gt;&gt;&gt;         \"exactness\",     &gt;&gt;&gt;         \"release_date:desc\",     &gt;&gt;&gt;         \"rank:desc\",     &gt;&gt;&gt;    ],     &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],     &gt;&gt;&gt;    distinct_attribute=\"url\",     &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],     &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],     &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],     &gt;&gt;&gt; )     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_settings(new_settings)</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_settings(\n    self, body: MeilisearchSettings, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update settings of the index.\n\n    Args:\n        body: Settings of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n        &gt;&gt;&gt; new_settings = MeilisearchSettings(\n        &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n        &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n        &gt;&gt;&gt;     ranking_rules=[\n        &gt;&gt;&gt;         \"words\",\n        &gt;&gt;&gt;         \"typo\",\n        &gt;&gt;&gt;         \"proximity\",\n        &gt;&gt;&gt;         \"attribute\",\n        &gt;&gt;&gt;         \"sort\",\n        &gt;&gt;&gt;         \"exactness\",\n        &gt;&gt;&gt;         \"release_date:desc\",\n        &gt;&gt;&gt;         \"rank:desc\",\n        &gt;&gt;&gt;    ],\n        &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n        &gt;&gt;&gt;    distinct_attribute=\"url\",\n        &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n        &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n        &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_settings(new_settings)\n    \"\"\"\n    body_dict = {\n        k: v\n        for k, v in body.model_dump(by_alias=True, exclude_none=True).items()\n        if v is not None\n    }\n    response = await self._http_requests.patch(self._settings_url, body_dict, compress=compress)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_sortable_attributes","title":"<code>update_sortable_attributes(sortable_attributes, *, compress=False)</code>  <code>async</code>","text":"<p>Get sortable attributes of the AsyncIndex.</p> <p>Parameters:</p> Name Type Description Default <code>sortable_attributes</code> <code>list[str]</code> <p>List of attributes for searching.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_sortable_attributes([\"title\", \"release_date\"])</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_sortable_attributes(\n    self, sortable_attributes: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Get sortable attributes of the AsyncIndex.\n\n    Args:\n        sortable_attributes: List of attributes for searching.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_sortable_attributes([\"title\", \"release_date\"])\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/sortable-attributes\", sortable_attributes, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_stop_words","title":"<code>update_stop_words(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update stop words of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[str]</code> <p>List containing the stop words of the index.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_stop_words([\"the\", \"a\", \"an\"])</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_stop_words(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update stop words of the index.\n\n    Args:\n        body: List containing the stop words of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_stop_words([\"the\", \"a\", \"an\"])\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/stop-words\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_synonyms","title":"<code>update_synonyms(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update synonyms of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>dict[str, list[str]]</code> <p>The synonyms of the index.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_synonyms(     &gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_synonyms(\n    self, body: dict[str, list[str]], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update synonyms of the index.\n\n    Args:\n        body: The synonyms of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_synonyms(\n        &gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n        &gt;&gt;&gt;     )\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/synonyms\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_typo_tolerance","title":"<code>update_typo_tolerance(typo_tolerance, *, compress=False)</code>  <code>async</code>","text":"<p>Update typo tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>typo_tolerance</code> <code>TypoTolerance</code> <p>Typo tolerance settings.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     TypoTolerance(enabled=False)     &gt;&gt;&gt;     await index.update_typo_tolerance()</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_typo_tolerance(\n    self, typo_tolerance: TypoTolerance, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update typo tolerance.\n\n    Args:\n        typo_tolerance: Typo tolerance settings.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     TypoTolerance(enabled=False)\n        &gt;&gt;&gt;     await index.update_typo_tolerance()\n    \"\"\"\n    response = await self._http_requests.patch(\n        f\"{self._settings_url}/typo-tolerance\",\n        typo_tolerance.model_dump(by_alias=True, exclude_unset=True),\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_word_dictionary","title":"<code>update_word_dictionary(dictionary, *, compress=False)</code>  <code>async</code>","text":"<p>Update the word dictionary settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>list[str]</code> <p>List of dictionary values.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")</p> Source code in <code>meilisearch_python_sdk/index/async_index.py</code> <pre><code>async def update_word_dictionary(\n    self, dictionary: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the word dictionary settings for an index.\n\n    Args:\n        dictionary: List of dictionary values.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/dictionary\", dictionary, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/","title":"Client","text":""},{"location":"client_api/#client-usage","title":"<code>client</code> Usage","text":""},{"location":"client_api/#create-a-client-with-a-context-manager","title":"Create a client with a context manager","text":"<p>This client runs in a context manager which ensures that everything is cleaned up after the use of the client is done. To create a client:</p> <pre><code>from meilisearch-python-sdk import Client\n\n\nwith Client(\"http://localhost:7700\", \"masterKey\") as client:\n    index = client.index(\"movies\")\n    ...\n</code></pre>"},{"location":"client_api/#custom-headers","title":"Custom headers","text":"<p>Custom headers can be added to the client by adding them to <code>custom_headers</code> when creating the client.</p> <pre><code>from meilisearch_python_sdk import Client\n\nwith Client(\n    \"http://127.0.0.1:7700\",\n    \"masterKey\",\n    custom_headers={\"header_key_1\": \"header_value_1\", \"header_key_2\": \"header_value_2\"}\n) as client:\n    index = client.index(\"movies\")\n...\n</code></pre>"},{"location":"client_api/#create-a-client-without-a-context-manager","title":"Create a client without a context manager","text":"<p>It is also possible to call the client without using a context manager, but in doing so you will need to make sure to do the cleanup yourself:</p> <pre><code>from meilisearch-python-sdk import Client\n\n\ntry:\n    client = Client(\"http://localhost:7700\", \"masterKey\")\n    ...\nfinally:\n    await client.close()\n\n</code></pre>"},{"location":"client_api/#client-api","title":"<code>Client</code> API","text":"<p>               Bases: <code>BaseClient</code></p> <p>client to connect to the Meilisearch API.</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>class Client(BaseClient):\n    \"\"\"client to connect to the Meilisearch API.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        api_key: str | None = None,\n        *,\n        timeout: int | None = None,\n        verify: bool | SSLContext = True,\n        custom_headers: dict[str, str] | None = None,\n        json_handler: BuiltinHandler | OrjsonHandler | None = None,\n        http2: bool = False,\n    ) -&gt; None:\n        \"\"\"Class initializer.\n\n        Args:\n            url: The url to the Meilisearch API (ex: http://localhost:7700)\n            api_key: The optional API key for Meilisearch. Defaults to None.\n            timeout: The amount of time in seconds that the client will wait for a response before\n                timing out. Defaults to None.\n            verify: SSL certificates (a.k.a CA bundle) used to\n                verify the identity of requested hosts. Either `True` (default CA bundle),\n                a path to an SSL certificate file, or `False` (disable verification)\n            custom_headers: Custom headers to add when sending data to Meilisearch. Defaults to\n                None.\n            json_handler: The module to use for json operations. The options are BuiltinHandler\n                (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n                Note that in order use orjson the corresponding extra needs to be included.\n                Default: BuiltinHandler.\n            http2: If set to True, the client will use HTTP/2. Defaults to False.\n        \"\"\"\n        super().__init__(api_key, custom_headers, json_handler)\n\n        self.http_client = HttpxClient(\n            base_url=url, timeout=timeout, headers=self._headers, verify=verify, http2=http2\n        )\n\n        self._http_requests = HttpRequests(self.http_client, json_handler=self.json_handler)\n\n    def __enter__(self) -&gt; Self:\n        return self\n\n    def __exit__(\n        self,\n        et: type[BaseException] | None,\n        ev: type[BaseException] | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        self.close()\n\n    def close(self) -&gt; None:\n        \"\"\"Closes the client.\n\n        This only needs to be used if the client was not created with a context manager.\n        \"\"\"\n        self.http_client.close()\n\n    def add_or_update_networks(self, *, network: Network) -&gt; Network:\n        \"\"\"Set or update remote networks.\n\n        Args:\n            network: Information to use for the networks.\n\n        Returns:\n            An instance of Network containing the network information.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.client import Network, Remote\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; network = Network(\n            &gt;&gt;&gt; self_=\"remote_1\",\n            &gt;&gt;&gt;     remotes={\n            &gt;&gt;&gt;         \"remote_1\": {\"url\": \"http://localhost:7700\", \"searchApiKey\": \"xxxx\"},\n            &gt;&gt;&gt;         \"remote_2\": {\"url\": \"http://localhost:7720\", \"searchApiKey\": \"xxxx\"},\n            &gt;&gt;&gt;     },\n            &gt;&gt;&gt; )\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     response = client.add_or_update_networks(network=network)\n        \"\"\"\n        response = self._http_requests.patch(\n            \"network\", network.model_dump(by_alias=True, exclude_none=True)\n        )\n\n        return Network(**self._http_requests.parse_json(response))\n\n    def get_networks(self) -&gt; Network:\n        \"\"\"Fetches the remote-networks\n\n        Returns:\n            An instance of Network containing information about each remote.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     response = client.get_networks()\n        \"\"\"\n        response = self._http_requests.get(\"network\")\n\n        return Network(**self._http_requests.parse_json(response))\n\n    def get_webhooks(self) -&gt; Webhooks:\n        \"\"\"Get all webhooks.\n\n        Returns:\n            An instance of Webhooks containing all configured webhooks.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     webhooks = client.get_webhooks()\n        \"\"\"\n        response = self._http_requests.get(\"webhooks\")\n\n        return Webhooks(**self._http_requests.parse_json(response))\n\n    def get_webhook(self, uuid: str) -&gt; Webhook:\n        \"\"\"Get a specific webhook by UUID.\n\n        Args:\n            uuid: The webhook's unique identifier.\n\n        Returns:\n            An instance of Webhook containing the webhook information.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\"):\n            &gt;&gt;&gt;     webhook = client.get_webhook(\"abc-123\")\n        \"\"\"\n        response = self._http_requests.get(f\"webhooks/{uuid}\")\n\n        return Webhook(**self._http_requests.parse_json(response))\n\n    def create_webhook(self, webhook: WebhookCreate) -&gt; Webhook:\n        \"\"\"Create a new webhook.\n\n        Args:\n            webhook: The webhook configuration to create.\n\n        Returns:\n            The created webhook.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookCreate\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     webhook_config = WebhookCreate(\n            &gt;&gt;&gt;         url=\"https://example.com/webhook\",\n            &gt;&gt;&gt;         headers={\"Authorization\": \"Bearer token\"}\n            &gt;&gt;&gt;     )\n            &gt;&gt;&gt;     webhook = client.create_webhook(webhook_config)\n        \"\"\"\n        response = self._http_requests.post(\n            \"webhooks\", webhook.model_dump(by_alias=True, exclude_none=True)\n        )\n\n        return Webhook(**self._http_requests.parse_json(response))\n\n    def update_webhook(self, *, uuid: str, webhook: WebhookUpdate) -&gt; Webhook:\n        \"\"\"Update an existing webhook.\n\n        Args:\n            uuid: The webhook's unique identifier.\n            webhook: The webhook configuration updates.\n\n        Returns:\n            The updated webhook.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookUpdate\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     webhook_update = WebhookUpdate(url=\"https://example.com/new-webhook\")\n            &gt;&gt;&gt;     webhook = client.update_webhook(\"abc-123\", webhook_update)\n        \"\"\"\n        response = self._http_requests.patch(\n            f\"webhooks/{uuid}\", webhook.model_dump(by_alias=True, exclude_none=True)\n        )\n\n        return Webhook(**self._http_requests.parse_json(response))\n\n    def delete_webhook(self, uuid: str) -&gt; int:\n        \"\"\"Delete a webhook.\n\n        Args:\n            uuid: The webhook's unique identifier.\n\n        Returns:\n            The Response status code. 204 signifies a successful delete.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.delete_webhook(\"abc-123\")\n        \"\"\"\n        response = self._http_requests.delete(f\"webhooks/{uuid}\")\n        return response.status_code\n\n    def create_dump(self) -&gt; TaskInfo:\n        \"\"\"Trigger the creation of a Meilisearch dump.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.create_dump()\n        \"\"\"\n        response = self._http_requests.post(\"dumps\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def create_index(\n        self,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        settings: MeilisearchSettings | None = None,\n        wait: bool = True,\n        timeout_in_ms: int | None = None,\n        plugins: IndexPlugins | None = None,\n        hits_type: Any = JsonDict,  # noqa: ANN401\n    ) -&gt; Index:\n        \"\"\"Creates a new index.\n\n        Args:\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            settings: Settings for the index. The settings can also be updated independently of\n                creating the index. The advantage to updating them here is updating the settings after\n                adding documents will cause the documents to be re-indexed. Because of this it will be\n                faster to update them before adding documents. Defaults to None (i.e. default\n                Meilisearch index settings).\n            wait: If set to True and settings are being updated, the index will be returned after\n                the settings update has completed. If False it will not wait for settings to complete.\n                Default: True\n            timeout_in_ms: Amount of time in milliseconds to wait before raising a\n                MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n                if the `None` option is used the wait time could be very long. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n\n        Returns:\n            An instance of Index containing the information of the newly created index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.create_index(\"movies\")\n        \"\"\"\n        return Index.create(\n            self.http_client,\n            uid,\n            primary_key,\n            settings=settings,\n            wait=wait,\n            timeout_in_ms=timeout_in_ms,\n            plugins=plugins,\n            json_handler=self.json_handler,\n            hits_type=hits_type,\n        )\n\n    def create_snapshot(self) -&gt; TaskInfo:\n        \"\"\"Trigger the creation of a Meilisearch snapshot.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.create_snapshot()\n        \"\"\"\n        response = self._http_requests.post(\"snapshots\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def delete_index_if_exists(self, uid: str) -&gt; bool:\n        \"\"\"Deletes an index if it already exists.\n\n        Args:\n            uid: The index's unique identifier.\n\n        Returns:\n            True if an index was deleted for False if not.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.delete_index_if_exists()\n        \"\"\"\n        response = self._http_requests.delete(f\"indexes/{uid}\")\n        status = self.wait_for_task(\n            self._http_requests.parse_json(response)[\"taskUid\"], timeout_in_ms=100000\n        )\n        if status.status == \"succeeded\":\n            return True\n        return False\n\n    def get_indexes(\n        self, *, offset: int | None = None, limit: int | None = None\n    ) -&gt; list[Index] | None:\n        \"\"\"Get all indexes.\n        Args:\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns:\n            A list of all indexes.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     indexes = client.get_indexes()\n        \"\"\"\n        url = _build_offset_limit_url(\"indexes\", offset, limit)\n        response = self._http_requests.get(url)\n\n        if not self._http_requests.parse_json(response)[\"results\"]:\n            return None\n\n        return [\n            Index(\n                http_client=self.http_client,\n                uid=x[\"uid\"],\n                primary_key=x[\"primaryKey\"],\n                created_at=x[\"createdAt\"],\n                updated_at=x[\"updatedAt\"],\n                json_handler=self.json_handler,\n            )\n            for x in self._http_requests.parse_json(response)[\"results\"]\n        ]\n\n    def get_index(self, uid: str) -&gt; Index:\n        \"\"\"Gets a single index based on the uid of the index.\n\n        Args:\n            uid: The index's unique identifier.\n\n        Returns:\n            An Index instance containing the information of the fetched index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.get_index()\n        \"\"\"\n        return Index(self.http_client, uid, json_handler=self.json_handler).fetch_info()\n\n    def index(self, uid: str, *, plugins: IndexPlugins | None = None) -&gt; Index:\n        \"\"\"Create a local reference to an index identified by UID, without making an HTTP call.\n\n        Args:\n            uid: The index's unique identifier.\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n            An Index instance.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n        \"\"\"\n        return Index(self.http_client, uid=uid, plugins=plugins, json_handler=self.json_handler)\n\n    def get_all_stats(self) -&gt; ClientStats:\n        \"\"\"Get stats for all indexes.\n\n        Returns:\n            Information about database size and all indexes.\n            https://docs.meilisearch.com/reference/api/stats.html\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     stats = client.get_all_stats()\n        \"\"\"\n        response = self._http_requests.get(\"stats\")\n\n        return ClientStats(**self._http_requests.parse_json(response))\n\n    def get_or_create_index(\n        self,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        plugins: IndexPlugins | None = None,\n        hits_type: Any = JsonDict,  # noqa: ANN401\n    ) -&gt; Index:\n        \"\"\"Get an index, or create it if it doesn't exist.\n\n        Args:\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n\n        Returns:\n            An instance of Index containing the information of the retrieved or newly created index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.get_or_create_index(\"movies\")\n        \"\"\"\n        try:\n            index_instance = self.get_index(uid)\n        except MeilisearchApiError as err:\n            if \"index_not_found\" not in err.code:\n                raise\n            index_instance = self.create_index(\n                uid, primary_key, plugins=plugins, hits_type=hits_type\n            )\n        return index_instance\n\n    def create_key(self, key: KeyCreate) -&gt; Key:\n        \"\"\"Creates a new API key.\n\n        Args:\n            key: The information to use in creating the key. Note that if an expires_at value\n                is included it should be in UTC time.\n\n        Returns:\n            The new API key.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     key_info = KeyCreate(\n            &gt;&gt;&gt;         description=\"My new key\",\n            &gt;&gt;&gt;         actions=[\"search\"],\n            &gt;&gt;&gt;         indexes=[\"movies\"],\n            &gt;&gt;&gt;     )\n            &gt;&gt;&gt;     keys = client.create_key(key_info)\n        \"\"\"\n        response = self._http_requests.post(\n            \"keys\", self.json_handler.loads(key.model_dump_json(by_alias=True))\n        )  # type: ignore[attr-defined]\n\n        return Key(**self._http_requests.parse_json(response))\n\n    def delete_key(self, key: str) -&gt; int:\n        \"\"\"Deletes an API key.\n\n        Args:\n            key: The key or uid to delete.\n\n        Returns:\n            The Response status code. 204 signifies a successful delete.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.delete_key(\"abc123\")\n        \"\"\"\n        response = self._http_requests.delete(f\"keys/{key}\")\n        return response.status_code\n\n    def get_keys(self, *, offset: int | None = None, limit: int | None = None) -&gt; KeySearch:\n        \"\"\"Gets the Meilisearch API keys.\n        Args:\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns:\n            API keys.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     keys = client.get_keys()\n        \"\"\"\n        url = _build_offset_limit_url(\"keys\", offset, limit)\n        response = self._http_requests.get(url)\n\n        return KeySearch(**self._http_requests.parse_json(response))\n\n    def get_key(self, key: str) -&gt; Key:\n        \"\"\"Gets information about a specific API key.\n\n        Args:\n            key: The key for which to retrieve the information.\n\n        Returns:\n            The API key, or `None` if the key is not found.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     keys = client.get_key(\"abc123\")\n        \"\"\"\n        response = self._http_requests.get(f\"keys/{key}\")\n\n        return Key(**self._http_requests.parse_json(response))\n\n    def update_key(self, key: KeyUpdate) -&gt; Key:\n        \"\"\"Update an API key.\n\n        Args:\n            key: The information to use in updating the key. Note that if an expires_at value\n                is included it should be in UTC time.\n\n        Returns:\n            The updated API key.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     key_info = KeyUpdate(\n                        key=\"abc123\",\n            &gt;&gt;&gt;         indexes=[\"*\"],\n            &gt;&gt;&gt;     )\n            &gt;&gt;&gt;     keys = client.update_key(key_info)\n        \"\"\"\n        payload = _build_update_key_payload(key, self.json_handler)\n        response = self._http_requests.patch(f\"keys/{key.key}\", payload)\n\n        return Key(**self._http_requests.parse_json(response))\n\n    def multi_search(\n        self,\n        queries: list[SearchParams],\n        *,\n        federation: Federation | FederationMerged | None = None,\n        hits_type: Any = JsonDict,  # noqa: ANN401\n    ) -&gt; list[SearchResultsWithUID] | SearchResultsFederated:\n        \"\"\"Multi-index search.\n\n        Args:\n            queries: List of SearchParameters\n            federation: If included a single search result with hits built from all queries will\n                be returned. This parameter can only be used with Meilisearch &gt;= v1.10.0. Defaults\n                to None.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n\n        Returns:\n            Results of the search\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     queries = [\n            &gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n            &gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n            &gt;&gt;&gt;     ]\n            &gt;&gt;&gt;     search_results = client.search(queries)\n        \"\"\"\n        url = \"multi-search\"\n        processed_queries = []\n        for query in queries:\n            q = query.model_dump(by_alias=True)\n\n            if query.retrieve_vectors is None:\n                del q[\"retrieveVectors\"]\n\n            if federation:\n                del q[\"limit\"]\n                del q[\"offset\"]\n\n            if query.media is None:\n                del q[\"media\"]\n\n            if query.show_performance_details is None:\n                del q[\"showPerformanceDetails\"]\n\n            processed_queries.append(q)\n\n        if federation:\n            federation_payload = federation.model_dump(by_alias=True)\n            if federation.facets_by_index is None:\n                del federation_payload[\"facetsByIndex\"]\n\n        else:\n            federation_payload = None\n\n        response = self._http_requests.post(\n            url,\n            body={\n                \"federation\": federation_payload,\n                \"queries\": processed_queries,\n            },\n        )\n\n        if federation:\n            results = self._http_requests.parse_json(response)\n            return SearchResultsFederated[hits_type](**results)\n\n        return [\n            SearchResultsWithUID[hits_type](**x)\n            for x in self._http_requests.parse_json(response)[\"results\"]\n        ]\n\n    def get_raw_index(self, uid: str) -&gt; IndexInfo | None:\n        \"\"\"Gets the index and returns all the index information rather than an Index instance.\n\n        Args:\n            uid: The index's unique identifier.\n\n        Returns:\n            Index information rather than an Index instance.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.get_raw_index(\"movies\")\n        \"\"\"\n        response = self.http_client.get(f\"indexes/{uid}\")\n\n        if response.status_code == 404:\n            return None\n\n        return IndexInfo(**self._http_requests.parse_json(response))\n\n    def get_raw_indexes(\n        self, *, offset: int | None = None, limit: int | None = None\n    ) -&gt; list[IndexInfo] | None:\n        \"\"\"Gets all the indexes.\n        Args:\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns all the index information rather than an AsyncIndex instance.\n\n        Returns:\n            A list of the Index information rather than an AsyncIndex instances.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.get_raw_indexes()\n        \"\"\"\n        url = _build_offset_limit_url(\"indexes\", offset, limit)\n        response = self._http_requests.get(url)\n\n        if not self._http_requests.parse_json(response)[\"results\"]:\n            return None\n\n        return [IndexInfo(**x) for x in self._http_requests.parse_json(response)[\"results\"]]\n\n    def get_version(self) -&gt; Version:\n        \"\"\"Get the Meilisearch version.\n\n        Returns:\n            Information about the version of Meilisearch.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     version = client.get_version()\n        \"\"\"\n        response = self._http_requests.get(\"version\")\n\n        return Version(**self._http_requests.parse_json(response))\n\n    def health(self) -&gt; Health:\n        \"\"\"Get health of the Meilisearch server.\n\n        Returns:\n            The status of the Meilisearch server.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     health = client.get_health()\n        \"\"\"\n        response = self._http_requests.get(\"health\")\n\n        return Health(**self._http_requests.parse_json(response))\n\n    def swap_indexes(self, indexes: list[tuple[str, str]], rename: bool = False) -&gt; TaskInfo:\n        \"\"\"Swap two indexes.\n\n        Args:\n            indexes: A list of tuples, each tuple should contain the indexes to swap.\n            rename: Use rename false if you are swapping two existing indexes. Use rename true if\n                the second index in your array does not exist. Default = False\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.swap_indexes([(\"index_a\", \"index_b\")])\n        \"\"\"\n        if rename:\n            processed_indexes = [{\"indexes\": x, \"rename\": True} for x in indexes]\n        else:\n            processed_indexes = [{\"indexes\": x} for x in indexes]\n        response = self._http_requests.post(\"swap-indexes\", processed_indexes)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_batch(self, batch_uid: int) -&gt; BatchResult | None:\n        return _get_batch(self, batch_uid)\n\n    def get_batches(\n        self,\n        *,\n        uids: list[int] | None = None,\n        batch_uids: list[int] | None = None,\n        index_uids: list[int] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        limit: int = 20,\n        from_: str | None = None,\n        reverse: bool = False,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; BatchStatus:\n        return _get_batches(\n            self,\n            uids=uids,\n            batch_uids=batch_uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            limit=limit,\n            from_=from_,\n            reverse=reverse,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    def cancel_tasks(\n        self,\n        *,\n        uids: list[int] | None = None,\n        index_uids: list[int] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Cancel a list of enqueued or processing tasks.\n\n        Defaults to cancelling all tasks.\n\n        Args:\n            uids: A list of task UIDs to cancel.\n            index_uids: A list of index UIDs for which to cancel tasks.\n            statuses: A list of statuses to cancel.\n            types: A list of types to cancel.\n            before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n            after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n            before_started_at: Cancel tasks that were started before the specified date time.\n            after_finished_at: Cancel tasks that were finished after the specified date time.\n\n        Returns:\n            The details of the task\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.task import cancel_tasks\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.cancel_tasks(uids=[1, 2])\n        \"\"\"\n        return _task.cancel_tasks(\n            self.http_client,\n            uids=uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    def delete_tasks(\n        self,\n        *,\n        uids: list[int] | None = None,\n        index_uids: list[int] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Delete a list of tasks.\n\n        Defaults to deleting all tasks.\n\n        Args:\n            uids: A list of task UIDs to delete.\n            index_uids: A list of index UIDs for which to delete tasks.\n            statuses: A list of statuses to delete.\n            types: A list of types to delete.\n            before_enqueued_at: Delete tasks that were enqueued before the specified date time.\n            after_enqueued_at: Delete tasks that were enqueued after the specified date time.\n            before_started_at: Delete tasks that were started before the specified date time.\n            after_finished_at: Delete tasks that were finished after the specified date time.\n\n        Returns:\n            The details of the task\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.delete_tasks(client, uids=[1, 2])\n        \"\"\"\n        return _task.delete_tasks(\n            self.http_client,\n            uids=uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    def get_task(self, task_id: int) -&gt; TaskResult:\n        \"\"\"Get a single task from it's task id.\n\n        Args:\n            task_id: Identifier of the task to retrieve.\n\n        Returns:\n            Results of a task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.get_task(client, 1244)\n        \"\"\"\n        return _task.get_task(self.http_client, task_id=task_id)\n\n    def get_tasks(\n        self,\n        *,\n        index_ids: list[str] | None = None,\n        types: str | list[str] | None = None,\n        reverse: bool | None = None,\n    ) -&gt; TaskStatus:\n        \"\"\"Get multiple tasks.\n\n        Args:\n            index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n                tasks only for the specified indexes, if not all tasks will be returned. Default = None\n            types: Specify specific task types to retrieve. Default = None\n            reverse: If True the tasks will be returned in reverse order. Default = None\n\n        Returns:\n            Task statuses.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     client.get_tasks(client)\n        \"\"\"\n        return _task.get_tasks(self.http_client, index_ids=index_ids, types=types, reverse=reverse)\n\n    def wait_for_task(\n        self,\n        task_id: int,\n        *,\n        timeout_in_ms: int | None = 5000,\n        interval_in_ms: int = 50,\n        raise_for_status: bool = False,\n    ) -&gt; TaskResult:\n        \"\"\"Wait until Meilisearch processes a task, and get its status.\n\n        Args:\n            task_id: Identifier of the task to retrieve.\n            timeout_in_ms: Amount of time in milliseconds to wait before raising a\n                MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n                if the `None` option is used the wait time could be very long. Defaults to 5000.\n            interval_in_ms: Time interval in milliseconds to sleep between requests. Defaults to 50.\n            raise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n                has a failed status. Defaults to False.\n\n        Returns:\n            Details of the processed update status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n            MeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     response = await index.add_documents(documents)\n            &gt;&gt;&gt;     client.wait_for_task(response.update_id)\n        \"\"\"\n        return _task.wait_for_task(\n            self.http_client,\n            task_id=task_id,\n            timeout_in_ms=timeout_in_ms,\n            interval_in_ms=interval_in_ms,\n            raise_for_status=raise_for_status,\n        )\n\n    # No cover because it requires multiple instances of Meilisearch\n    def transfer_documents(  # pragma: no cover\n        self,\n        url: str,\n        *,\n        api_key: str | None = None,\n        payload_size: str | None = None,\n        indexes: JsonMapping | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Transfer settings and documents from one Meilisearch instance to another.\n\n        Args:\n            url: Where to send our settings and documents.\n            api_key: The API key with the rights to send the requests. Usually the master key of\n                the remote machine. Defaults to None.\n            payload_size: Human readable size defining the size of the payloads to send. Defaults\n                to 50\u00a0MiB.\n            indexes: A set of patterns of matching the indexes you want to export. Defaults to all\n                indexes without filter.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index.transfer_documents(\"https://another-instance.com\", api_key=\"otherMasterKey\")\n        \"\"\"\n        payload: JsonDict = {\"url\": url}\n\n        if api_key:\n            payload[\"apiKey\"] = api_key\n\n        if payload:\n            payload[\"payloadSize\"] = payload_size\n\n        if indexes:\n            payload[\"indexes\"] = indexes\n\n        response = self._http_requests.post(url, body=payload)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_experimental_features(self) -&gt; dict[str, bool]:\n        \"\"\"Gets all experimental features and if they are enabled or not.\n\n        Returns:\n            The status of the experimental features.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index.get_experimental_feature()\n        \"\"\"\n\n        response = self._http_requests.get(\"/experimental-features\")\n        return self._http_requests.parse_json(response)\n\n    def update_experimental_features(self, features: dict[str, bool]) -&gt; dict[str, bool]:\n        \"\"\"Update the status of an experimental feature.\n\n        Args:\n            features: Dictionary of features to enable/disable. The dictionary keys can be in either\n                camel case or snake case, the conversion to the correct type will be handed for you by\n                the program. For example {\"logsRoute\": True} and {\"logs_route\": True} will both work.\n\n        Returns:\n            The status of the experimental features.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index.update_experimental_features({\"logsRoute\": True})\n        \"\"\"\n        payload = dict_to_camel(features)\n        response = self._http_requests.patch(\"/experimental-features\", body=payload)\n\n        return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.__init__","title":"<code>__init__(url, api_key=None, *, timeout=None, verify=True, custom_headers=None, json_handler=None, http2=False)</code>","text":"<p>Class initializer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to the Meilisearch API (ex: http://localhost:7700)</p> required <code>api_key</code> <code>str | None</code> <p>The optional API key for Meilisearch. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>The amount of time in seconds that the client will wait for a response before timing out. Defaults to None.</p> <code>None</code> <code>verify</code> <code>bool | SSLContext</code> <p>SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts. Either <code>True</code> (default CA bundle), a path to an SSL certificate file, or <code>False</code> (disable verification)</p> <code>True</code> <code>custom_headers</code> <code>dict[str, str] | None</code> <p>Custom headers to add when sending data to Meilisearch. Defaults to None.</p> <code>None</code> <code>json_handler</code> <code>BuiltinHandler | OrjsonHandler | None</code> <p>The module to use for json operations. The options are BuiltinHandler (uses the json module from the standard library), or OrjsonHandler (uses orjson). Note that in order use orjson the corresponding extra needs to be included. Default: BuiltinHandler.</p> <code>None</code> <code>http2</code> <code>bool</code> <p>If set to True, the client will use HTTP/2. Defaults to False.</p> <code>False</code> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    api_key: str | None = None,\n    *,\n    timeout: int | None = None,\n    verify: bool | SSLContext = True,\n    custom_headers: dict[str, str] | None = None,\n    json_handler: BuiltinHandler | OrjsonHandler | None = None,\n    http2: bool = False,\n) -&gt; None:\n    \"\"\"Class initializer.\n\n    Args:\n        url: The url to the Meilisearch API (ex: http://localhost:7700)\n        api_key: The optional API key for Meilisearch. Defaults to None.\n        timeout: The amount of time in seconds that the client will wait for a response before\n            timing out. Defaults to None.\n        verify: SSL certificates (a.k.a CA bundle) used to\n            verify the identity of requested hosts. Either `True` (default CA bundle),\n            a path to an SSL certificate file, or `False` (disable verification)\n        custom_headers: Custom headers to add when sending data to Meilisearch. Defaults to\n            None.\n        json_handler: The module to use for json operations. The options are BuiltinHandler\n            (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n            Note that in order use orjson the corresponding extra needs to be included.\n            Default: BuiltinHandler.\n        http2: If set to True, the client will use HTTP/2. Defaults to False.\n    \"\"\"\n    super().__init__(api_key, custom_headers, json_handler)\n\n    self.http_client = HttpxClient(\n        base_url=url, timeout=timeout, headers=self._headers, verify=verify, http2=http2\n    )\n\n    self._http_requests = HttpRequests(self.http_client, json_handler=self.json_handler)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.add_or_update_networks","title":"<code>add_or_update_networks(*, network)</code>","text":"<p>Set or update remote networks.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Network</code> <p>Information to use for the networks.</p> required <p>Returns:</p> Type Description <code>Network</code> <p>An instance of Network containing the network information.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.models.client import Network, Remote\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; network = Network(\n&gt;&gt;&gt; self_=\"remote_1\",\n&gt;&gt;&gt;     remotes={\n&gt;&gt;&gt;         \"remote_1\": {\"url\": \"http://localhost:7700\", \"searchApiKey\": \"xxxx\"},\n&gt;&gt;&gt;         \"remote_2\": {\"url\": \"http://localhost:7720\", \"searchApiKey\": \"xxxx\"},\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     response = client.add_or_update_networks(network=network)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def add_or_update_networks(self, *, network: Network) -&gt; Network:\n    \"\"\"Set or update remote networks.\n\n    Args:\n        network: Information to use for the networks.\n\n    Returns:\n        An instance of Network containing the network information.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.client import Network, Remote\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; network = Network(\n        &gt;&gt;&gt; self_=\"remote_1\",\n        &gt;&gt;&gt;     remotes={\n        &gt;&gt;&gt;         \"remote_1\": {\"url\": \"http://localhost:7700\", \"searchApiKey\": \"xxxx\"},\n        &gt;&gt;&gt;         \"remote_2\": {\"url\": \"http://localhost:7720\", \"searchApiKey\": \"xxxx\"},\n        &gt;&gt;&gt;     },\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     response = client.add_or_update_networks(network=network)\n    \"\"\"\n    response = self._http_requests.patch(\n        \"network\", network.model_dump(by_alias=True, exclude_none=True)\n    )\n\n    return Network(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.cancel_tasks","title":"<code>cancel_tasks(*, uids=None, index_uids=None, statuses=None, types=None, before_enqueued_at=None, after_enqueued_at=None, before_started_at=None, after_finished_at=None)</code>","text":"<p>Cancel a list of enqueued or processing tasks.</p> <p>Defaults to cancelling all tasks.</p> <p>Parameters:</p> Name Type Description Default <code>uids</code> <code>list[int] | None</code> <p>A list of task UIDs to cancel.</p> <code>None</code> <code>index_uids</code> <code>list[int] | None</code> <p>A list of index UIDs for which to cancel tasks.</p> <code>None</code> <code>statuses</code> <code>list[str] | None</code> <p>A list of statuses to cancel.</p> <code>None</code> <code>types</code> <code>list[str] | None</code> <p>A list of types to cancel.</p> <code>None</code> <code>before_enqueued_at</code> <code>datetime | None</code> <p>Cancel tasks that were enqueued before the specified date time.</p> <code>None</code> <code>after_enqueued_at</code> <code>datetime | None</code> <p>Cancel tasks that were enqueued after the specified date time.</p> <code>None</code> <code>before_started_at</code> <code>datetime | None</code> <p>Cancel tasks that were started before the specified date time.</p> <code>None</code> <code>after_finished_at</code> <code>datetime | None</code> <p>Cancel tasks that were finished after the specified date time.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilisearch_python_sdk.task import cancel_tasks     &gt;&gt;&gt;     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     client.cancel_tasks(uids=[1, 2])</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def cancel_tasks(\n    self,\n    *,\n    uids: list[int] | None = None,\n    index_uids: list[int] | None = None,\n    statuses: list[str] | None = None,\n    types: list[str] | None = None,\n    before_enqueued_at: datetime | None = None,\n    after_enqueued_at: datetime | None = None,\n    before_started_at: datetime | None = None,\n    after_finished_at: datetime | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Cancel a list of enqueued or processing tasks.\n\n    Defaults to cancelling all tasks.\n\n    Args:\n        uids: A list of task UIDs to cancel.\n        index_uids: A list of index UIDs for which to cancel tasks.\n        statuses: A list of statuses to cancel.\n        types: A list of types to cancel.\n        before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n        after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n        before_started_at: Cancel tasks that were started before the specified date time.\n        after_finished_at: Cancel tasks that were finished after the specified date time.\n\n    Returns:\n        The details of the task\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.task import cancel_tasks\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.cancel_tasks(uids=[1, 2])\n    \"\"\"\n    return _task.cancel_tasks(\n        self.http_client,\n        uids=uids,\n        index_uids=index_uids,\n        statuses=statuses,\n        types=types,\n        before_enqueued_at=before_enqueued_at,\n        after_enqueued_at=after_enqueued_at,\n        before_started_at=before_started_at,\n        after_finished_at=after_finished_at,\n    )\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.close","title":"<code>close()</code>","text":"<p>Closes the client.</p> <p>This only needs to be used if the client was not created with a context manager.</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the client.\n\n    This only needs to be used if the client was not created with a context manager.\n    \"\"\"\n    self.http_client.close()\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_dump","title":"<code>create_dump()</code>","text":"<p>Trigger the creation of a Meilisearch dump.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     client.create_dump()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_dump(self) -&gt; TaskInfo:\n    \"\"\"Trigger the creation of a Meilisearch dump.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.create_dump()\n    \"\"\"\n    response = self._http_requests.post(\"dumps\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_index","title":"<code>create_index(uid, primary_key=None, *, settings=None, wait=True, timeout_in_ms=None, plugins=None, hits_type=JsonDict)</code>","text":"<p>Creates a new index.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. Defaults to None.</p> <code>None</code> <code>settings</code> <code>MeilisearchSettings | None</code> <p>Settings for the index. The settings can also be updated independently of creating the index. The advantage to updating them here is updating the settings after adding documents will cause the documents to be re-indexed. Because of this it will be faster to update them before adding documents. Defaults to None (i.e. default Meilisearch index settings).</p> <code>None</code> <code>wait</code> <code>bool</code> <p>If set to True and settings are being updated, the index will be returned after the settings update has completed. If False it will not wait for settings to complete. Default: True</p> <code>True</code> <code>timeout_in_ms</code> <code>int | None</code> <p>Amount of time in milliseconds to wait before raising a MeilisearchTimeoutError. <code>None</code> can also be passed to wait indefinitely. Be aware that if the <code>None</code> option is used the wait time could be very long. Defaults to None.</p> <code>None</code> <code>plugins</code> <code>IndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <code>hits_type</code> <code>Any</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> <p>Returns:</p> Type Description <code>Index</code> <p>An instance of Index containing the information of the newly created index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.create_index(\"movies\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_index(\n    self,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    settings: MeilisearchSettings | None = None,\n    wait: bool = True,\n    timeout_in_ms: int | None = None,\n    plugins: IndexPlugins | None = None,\n    hits_type: Any = JsonDict,  # noqa: ANN401\n) -&gt; Index:\n    \"\"\"Creates a new index.\n\n    Args:\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        settings: Settings for the index. The settings can also be updated independently of\n            creating the index. The advantage to updating them here is updating the settings after\n            adding documents will cause the documents to be re-indexed. Because of this it will be\n            faster to update them before adding documents. Defaults to None (i.e. default\n            Meilisearch index settings).\n        wait: If set to True and settings are being updated, the index will be returned after\n            the settings update has completed. If False it will not wait for settings to complete.\n            Default: True\n        timeout_in_ms: Amount of time in milliseconds to wait before raising a\n            MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n            if the `None` option is used the wait time could be very long. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n\n    Returns:\n        An instance of Index containing the information of the newly created index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.create_index(\"movies\")\n    \"\"\"\n    return Index.create(\n        self.http_client,\n        uid,\n        primary_key,\n        settings=settings,\n        wait=wait,\n        timeout_in_ms=timeout_in_ms,\n        plugins=plugins,\n        json_handler=self.json_handler,\n        hits_type=hits_type,\n    )\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_key","title":"<code>create_key(key)</code>","text":"<p>Creates a new API key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>KeyCreate</code> <p>The information to use in creating the key. Note that if an expires_at value is included it should be in UTC time.</p> required <p>Returns:</p> Type Description <code>Key</code> <p>The new API key.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     key_info = KeyCreate(     &gt;&gt;&gt;         description=\"My new key\",     &gt;&gt;&gt;         actions=[\"search\"],     &gt;&gt;&gt;         indexes=[\"movies\"],     &gt;&gt;&gt;     )     &gt;&gt;&gt;     keys = client.create_key(key_info)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_key(self, key: KeyCreate) -&gt; Key:\n    \"\"\"Creates a new API key.\n\n    Args:\n        key: The information to use in creating the key. Note that if an expires_at value\n            is included it should be in UTC time.\n\n    Returns:\n        The new API key.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     key_info = KeyCreate(\n        &gt;&gt;&gt;         description=\"My new key\",\n        &gt;&gt;&gt;         actions=[\"search\"],\n        &gt;&gt;&gt;         indexes=[\"movies\"],\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt;     keys = client.create_key(key_info)\n    \"\"\"\n    response = self._http_requests.post(\n        \"keys\", self.json_handler.loads(key.model_dump_json(by_alias=True))\n    )  # type: ignore[attr-defined]\n\n    return Key(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_snapshot","title":"<code>create_snapshot()</code>","text":"<p>Trigger the creation of a Meilisearch snapshot.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     client.create_snapshot()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_snapshot(self) -&gt; TaskInfo:\n    \"\"\"Trigger the creation of a Meilisearch snapshot.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.create_snapshot()\n    \"\"\"\n    response = self._http_requests.post(\"snapshots\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_webhook","title":"<code>create_webhook(webhook)</code>","text":"<p>Create a new webhook.</p> <p>Parameters:</p> Name Type Description Default <code>webhook</code> <code>WebhookCreate</code> <p>The webhook configuration to create.</p> required <p>Returns:</p> Type Description <code>Webhook</code> <p>The created webhook.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookCreate\n&gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     webhook_config = WebhookCreate(\n&gt;&gt;&gt;         url=\"https://example.com/webhook\",\n&gt;&gt;&gt;         headers={\"Authorization\": \"Bearer token\"}\n&gt;&gt;&gt;     )\n&gt;&gt;&gt;     webhook = client.create_webhook(webhook_config)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_webhook(self, webhook: WebhookCreate) -&gt; Webhook:\n    \"\"\"Create a new webhook.\n\n    Args:\n        webhook: The webhook configuration to create.\n\n    Returns:\n        The created webhook.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookCreate\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     webhook_config = WebhookCreate(\n        &gt;&gt;&gt;         url=\"https://example.com/webhook\",\n        &gt;&gt;&gt;         headers={\"Authorization\": \"Bearer token\"}\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt;     webhook = client.create_webhook(webhook_config)\n    \"\"\"\n    response = self._http_requests.post(\n        \"webhooks\", webhook.model_dump(by_alias=True, exclude_none=True)\n    )\n\n    return Webhook(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.delete_index_if_exists","title":"<code>delete_index_if_exists(uid)</code>","text":"<p>Deletes an index if it already exists.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if an index was deleted for False if not.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     client.delete_index_if_exists()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def delete_index_if_exists(self, uid: str) -&gt; bool:\n    \"\"\"Deletes an index if it already exists.\n\n    Args:\n        uid: The index's unique identifier.\n\n    Returns:\n        True if an index was deleted for False if not.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.delete_index_if_exists()\n    \"\"\"\n    response = self._http_requests.delete(f\"indexes/{uid}\")\n    status = self.wait_for_task(\n        self._http_requests.parse_json(response)[\"taskUid\"], timeout_in_ms=100000\n    )\n    if status.status == \"succeeded\":\n        return True\n    return False\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.delete_key","title":"<code>delete_key(key)</code>","text":"<p>Deletes an API key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key or uid to delete.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The Response status code. 204 signifies a successful delete.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     client.delete_key(\"abc123\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def delete_key(self, key: str) -&gt; int:\n    \"\"\"Deletes an API key.\n\n    Args:\n        key: The key or uid to delete.\n\n    Returns:\n        The Response status code. 204 signifies a successful delete.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.delete_key(\"abc123\")\n    \"\"\"\n    response = self._http_requests.delete(f\"keys/{key}\")\n    return response.status_code\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.delete_tasks","title":"<code>delete_tasks(*, uids=None, index_uids=None, statuses=None, types=None, before_enqueued_at=None, after_enqueued_at=None, before_started_at=None, after_finished_at=None)</code>","text":"<p>Delete a list of tasks.</p> <p>Defaults to deleting all tasks.</p> <p>Parameters:</p> Name Type Description Default <code>uids</code> <code>list[int] | None</code> <p>A list of task UIDs to delete.</p> <code>None</code> <code>index_uids</code> <code>list[int] | None</code> <p>A list of index UIDs for which to delete tasks.</p> <code>None</code> <code>statuses</code> <code>list[str] | None</code> <p>A list of statuses to delete.</p> <code>None</code> <code>types</code> <code>list[str] | None</code> <p>A list of types to delete.</p> <code>None</code> <code>before_enqueued_at</code> <code>datetime | None</code> <p>Delete tasks that were enqueued before the specified date time.</p> <code>None</code> <code>after_enqueued_at</code> <code>datetime | None</code> <p>Delete tasks that were enqueued after the specified date time.</p> <code>None</code> <code>before_started_at</code> <code>datetime | None</code> <p>Delete tasks that were started before the specified date time.</p> <code>None</code> <code>after_finished_at</code> <code>datetime | None</code> <p>Delete tasks that were finished after the specified date time.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt;     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     client.delete_tasks(client, uids=[1, 2])</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def delete_tasks(\n    self,\n    *,\n    uids: list[int] | None = None,\n    index_uids: list[int] | None = None,\n    statuses: list[str] | None = None,\n    types: list[str] | None = None,\n    before_enqueued_at: datetime | None = None,\n    after_enqueued_at: datetime | None = None,\n    before_started_at: datetime | None = None,\n    after_finished_at: datetime | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Delete a list of tasks.\n\n    Defaults to deleting all tasks.\n\n    Args:\n        uids: A list of task UIDs to delete.\n        index_uids: A list of index UIDs for which to delete tasks.\n        statuses: A list of statuses to delete.\n        types: A list of types to delete.\n        before_enqueued_at: Delete tasks that were enqueued before the specified date time.\n        after_enqueued_at: Delete tasks that were enqueued after the specified date time.\n        before_started_at: Delete tasks that were started before the specified date time.\n        after_finished_at: Delete tasks that were finished after the specified date time.\n\n    Returns:\n        The details of the task\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.delete_tasks(client, uids=[1, 2])\n    \"\"\"\n    return _task.delete_tasks(\n        self.http_client,\n        uids=uids,\n        index_uids=index_uids,\n        statuses=statuses,\n        types=types,\n        before_enqueued_at=before_enqueued_at,\n        after_enqueued_at=after_enqueued_at,\n        before_started_at=before_started_at,\n        after_finished_at=after_finished_at,\n    )\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.delete_webhook","title":"<code>delete_webhook(uuid)</code>","text":"<p>Delete a webhook.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The webhook's unique identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The Response status code. 204 signifies a successful delete.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     client.delete_webhook(\"abc-123\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def delete_webhook(self, uuid: str) -&gt; int:\n    \"\"\"Delete a webhook.\n\n    Args:\n        uuid: The webhook's unique identifier.\n\n    Returns:\n        The Response status code. 204 signifies a successful delete.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.delete_webhook(\"abc-123\")\n    \"\"\"\n    response = self._http_requests.delete(f\"webhooks/{uuid}\")\n    return response.status_code\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_all_stats","title":"<code>get_all_stats()</code>","text":"<p>Get stats for all indexes.</p> <p>Returns:</p> Name Type Description <code>ClientStats</code> <p>Information about database size and all indexes.</p> <code>https</code> <code>ClientStats</code> <p>//docs.meilisearch.com/reference/api/stats.html</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     stats = client.get_all_stats()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_all_stats(self) -&gt; ClientStats:\n    \"\"\"Get stats for all indexes.\n\n    Returns:\n        Information about database size and all indexes.\n        https://docs.meilisearch.com/reference/api/stats.html\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     stats = client.get_all_stats()\n    \"\"\"\n    response = self._http_requests.get(\"stats\")\n\n    return ClientStats(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_experimental_features","title":"<code>get_experimental_features()</code>","text":"<p>Gets all experimental features and if they are enabled or not.</p> <p>Returns:</p> Type Description <code>dict[str, bool]</code> <p>The status of the experimental features.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index.get_experimental_feature()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_experimental_features(self) -&gt; dict[str, bool]:\n    \"\"\"Gets all experimental features and if they are enabled or not.\n\n    Returns:\n        The status of the experimental features.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index.get_experimental_feature()\n    \"\"\"\n\n    response = self._http_requests.get(\"/experimental-features\")\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_index","title":"<code>get_index(uid)</code>","text":"<p>Gets a single index based on the uid of the index.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <p>Returns:</p> Type Description <code>Index</code> <p>An Index instance containing the information of the fetched index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.get_index()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_index(self, uid: str) -&gt; Index:\n    \"\"\"Gets a single index based on the uid of the index.\n\n    Args:\n        uid: The index's unique identifier.\n\n    Returns:\n        An Index instance containing the information of the fetched index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.get_index()\n    \"\"\"\n    return Index(self.http_client, uid, json_handler=self.json_handler).fetch_info()\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_indexes","title":"<code>get_indexes(*, offset=None, limit=None)</code>","text":"<p>Get all indexes. Args:     offset: Number of indexes to skip. The default of None will use the Meilisearch         default.     limit: Number of indexes to return. The default of None will use the Meilisearch         default.</p> <p>Returns:</p> Type Description <code>list[Index] | None</code> <p>A list of all indexes.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     indexes = client.get_indexes()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_indexes(\n    self, *, offset: int | None = None, limit: int | None = None\n) -&gt; list[Index] | None:\n    \"\"\"Get all indexes.\n    Args:\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns:\n        A list of all indexes.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     indexes = client.get_indexes()\n    \"\"\"\n    url = _build_offset_limit_url(\"indexes\", offset, limit)\n    response = self._http_requests.get(url)\n\n    if not self._http_requests.parse_json(response)[\"results\"]:\n        return None\n\n    return [\n        Index(\n            http_client=self.http_client,\n            uid=x[\"uid\"],\n            primary_key=x[\"primaryKey\"],\n            created_at=x[\"createdAt\"],\n            updated_at=x[\"updatedAt\"],\n            json_handler=self.json_handler,\n        )\n        for x in self._http_requests.parse_json(response)[\"results\"]\n    ]\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_key","title":"<code>get_key(key)</code>","text":"<p>Gets information about a specific API key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for which to retrieve the information.</p> required <p>Returns:</p> Type Description <code>Key</code> <p>The API key, or <code>None</code> if the key is not found.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     keys = client.get_key(\"abc123\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_key(self, key: str) -&gt; Key:\n    \"\"\"Gets information about a specific API key.\n\n    Args:\n        key: The key for which to retrieve the information.\n\n    Returns:\n        The API key, or `None` if the key is not found.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     keys = client.get_key(\"abc123\")\n    \"\"\"\n    response = self._http_requests.get(f\"keys/{key}\")\n\n    return Key(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_keys","title":"<code>get_keys(*, offset=None, limit=None)</code>","text":"<p>Gets the Meilisearch API keys. Args:     offset: Number of indexes to skip. The default of None will use the Meilisearch         default.     limit: Number of indexes to return. The default of None will use the Meilisearch         default.</p> <p>Returns:</p> Type Description <code>KeySearch</code> <p>API keys.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     keys = client.get_keys()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_keys(self, *, offset: int | None = None, limit: int | None = None) -&gt; KeySearch:\n    \"\"\"Gets the Meilisearch API keys.\n    Args:\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns:\n        API keys.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     keys = client.get_keys()\n    \"\"\"\n    url = _build_offset_limit_url(\"keys\", offset, limit)\n    response = self._http_requests.get(url)\n\n    return KeySearch(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_networks","title":"<code>get_networks()</code>","text":"<p>Fetches the remote-networks</p> <p>Returns:</p> Type Description <code>Network</code> <p>An instance of Network containing information about each remote.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     response = client.get_networks()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_networks(self) -&gt; Network:\n    \"\"\"Fetches the remote-networks\n\n    Returns:\n        An instance of Network containing information about each remote.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     response = client.get_networks()\n    \"\"\"\n    response = self._http_requests.get(\"network\")\n\n    return Network(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_or_create_index","title":"<code>get_or_create_index(uid, primary_key=None, *, plugins=None, hits_type=JsonDict)</code>","text":"<p>Get an index, or create it if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. Defaults to None.</p> <code>None</code> <code>plugins</code> <code>IndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <code>hits_type</code> <code>Any</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> <p>Returns:</p> Type Description <code>Index</code> <p>An instance of Index containing the information of the retrieved or newly created index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.get_or_create_index(\"movies\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_or_create_index(\n    self,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    plugins: IndexPlugins | None = None,\n    hits_type: Any = JsonDict,  # noqa: ANN401\n) -&gt; Index:\n    \"\"\"Get an index, or create it if it doesn't exist.\n\n    Args:\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n\n    Returns:\n        An instance of Index containing the information of the retrieved or newly created index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.get_or_create_index(\"movies\")\n    \"\"\"\n    try:\n        index_instance = self.get_index(uid)\n    except MeilisearchApiError as err:\n        if \"index_not_found\" not in err.code:\n            raise\n        index_instance = self.create_index(\n            uid, primary_key, plugins=plugins, hits_type=hits_type\n        )\n    return index_instance\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_raw_index","title":"<code>get_raw_index(uid)</code>","text":"<p>Gets the index and returns all the index information rather than an Index instance.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <p>Returns:</p> Type Description <code>IndexInfo | None</code> <p>Index information rather than an Index instance.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.get_raw_index(\"movies\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_raw_index(self, uid: str) -&gt; IndexInfo | None:\n    \"\"\"Gets the index and returns all the index information rather than an Index instance.\n\n    Args:\n        uid: The index's unique identifier.\n\n    Returns:\n        Index information rather than an Index instance.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.get_raw_index(\"movies\")\n    \"\"\"\n    response = self.http_client.get(f\"indexes/{uid}\")\n\n    if response.status_code == 404:\n        return None\n\n    return IndexInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_raw_indexes","title":"<code>get_raw_indexes(*, offset=None, limit=None)</code>","text":"<p>Gets all the indexes. Args:     offset: Number of indexes to skip. The default of None will use the Meilisearch         default.     limit: Number of indexes to return. The default of None will use the Meilisearch         default.</p> <p>Returns all the index information rather than an AsyncIndex instance.</p> <p>Returns:</p> Type Description <code>list[IndexInfo] | None</code> <p>A list of the Index information rather than an AsyncIndex instances.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.get_raw_indexes()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_raw_indexes(\n    self, *, offset: int | None = None, limit: int | None = None\n) -&gt; list[IndexInfo] | None:\n    \"\"\"Gets all the indexes.\n    Args:\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns all the index information rather than an AsyncIndex instance.\n\n    Returns:\n        A list of the Index information rather than an AsyncIndex instances.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.get_raw_indexes()\n    \"\"\"\n    url = _build_offset_limit_url(\"indexes\", offset, limit)\n    response = self._http_requests.get(url)\n\n    if not self._http_requests.parse_json(response)[\"results\"]:\n        return None\n\n    return [IndexInfo(**x) for x in self._http_requests.parse_json(response)[\"results\"]]\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_task","title":"<code>get_task(task_id)</code>","text":"<p>Get a single task from it's task id.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>Identifier of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>TaskResult</code> <p>Results of a task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt;     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     client.get_task(client, 1244)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_task(self, task_id: int) -&gt; TaskResult:\n    \"\"\"Get a single task from it's task id.\n\n    Args:\n        task_id: Identifier of the task to retrieve.\n\n    Returns:\n        Results of a task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.get_task(client, 1244)\n    \"\"\"\n    return _task.get_task(self.http_client, task_id=task_id)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_tasks","title":"<code>get_tasks(*, index_ids=None, types=None, reverse=None)</code>","text":"<p>Get multiple tasks.</p> <p>Parameters:</p> Name Type Description Default <code>index_ids</code> <code>list[str] | None</code> <p>A list of index UIDs for which to get the tasks. If provided this will get the tasks only for the specified indexes, if not all tasks will be returned. Default = None</p> <code>None</code> <code>types</code> <code>str | list[str] | None</code> <p>Specify specific task types to retrieve. Default = None</p> <code>None</code> <code>reverse</code> <code>bool | None</code> <p>If True the tasks will be returned in reverse order. Default = None</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskStatus</code> <p>Task statuses.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt;     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     client.get_tasks(client)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_tasks(\n    self,\n    *,\n    index_ids: list[str] | None = None,\n    types: str | list[str] | None = None,\n    reverse: bool | None = None,\n) -&gt; TaskStatus:\n    \"\"\"Get multiple tasks.\n\n    Args:\n        index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n            tasks only for the specified indexes, if not all tasks will be returned. Default = None\n        types: Specify specific task types to retrieve. Default = None\n        reverse: If True the tasks will be returned in reverse order. Default = None\n\n    Returns:\n        Task statuses.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     client.get_tasks(client)\n    \"\"\"\n    return _task.get_tasks(self.http_client, index_ids=index_ids, types=types, reverse=reverse)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_version","title":"<code>get_version()</code>","text":"<p>Get the Meilisearch version.</p> <p>Returns:</p> Type Description <code>Version</code> <p>Information about the version of Meilisearch.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     version = client.get_version()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_version(self) -&gt; Version:\n    \"\"\"Get the Meilisearch version.\n\n    Returns:\n        Information about the version of Meilisearch.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     version = client.get_version()\n    \"\"\"\n    response = self._http_requests.get(\"version\")\n\n    return Version(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_webhook","title":"<code>get_webhook(uuid)</code>","text":"<p>Get a specific webhook by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The webhook's unique identifier.</p> required <p>Returns:</p> Type Description <code>Webhook</code> <p>An instance of Webhook containing the webhook information.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\"):\n&gt;&gt;&gt;     webhook = client.get_webhook(\"abc-123\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_webhook(self, uuid: str) -&gt; Webhook:\n    \"\"\"Get a specific webhook by UUID.\n\n    Args:\n        uuid: The webhook's unique identifier.\n\n    Returns:\n        An instance of Webhook containing the webhook information.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\"):\n        &gt;&gt;&gt;     webhook = client.get_webhook(\"abc-123\")\n    \"\"\"\n    response = self._http_requests.get(f\"webhooks/{uuid}\")\n\n    return Webhook(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_webhooks","title":"<code>get_webhooks()</code>","text":"<p>Get all webhooks.</p> <p>Returns:</p> Type Description <code>Webhooks</code> <p>An instance of Webhooks containing all configured webhooks.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     webhooks = client.get_webhooks()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_webhooks(self) -&gt; Webhooks:\n    \"\"\"Get all webhooks.\n\n    Returns:\n        An instance of Webhooks containing all configured webhooks.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     webhooks = client.get_webhooks()\n    \"\"\"\n    response = self._http_requests.get(\"webhooks\")\n\n    return Webhooks(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.health","title":"<code>health()</code>","text":"<p>Get health of the Meilisearch server.</p> <p>Returns:</p> Type Description <code>Health</code> <p>The status of the Meilisearch server.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     health = client.get_health()</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def health(self) -&gt; Health:\n    \"\"\"Get health of the Meilisearch server.\n\n    Returns:\n        The status of the Meilisearch server.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     health = client.get_health()\n    \"\"\"\n    response = self._http_requests.get(\"health\")\n\n    return Health(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.index","title":"<code>index(uid, *, plugins=None)</code>","text":"<p>Create a local reference to an index identified by UID, without making an HTTP call.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>plugins</code> <code>IndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <p>Returns:</p> Type Description <code>Index</code> <p>An Index instance.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def index(self, uid: str, *, plugins: IndexPlugins | None = None) -&gt; Index:\n    \"\"\"Create a local reference to an index identified by UID, without making an HTTP call.\n\n    Args:\n        uid: The index's unique identifier.\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n        An Index instance.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n    \"\"\"\n    return Index(self.http_client, uid=uid, plugins=plugins, json_handler=self.json_handler)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.multi_search","title":"<code>multi_search(queries, *, federation=None, hits_type=JsonDict)</code>","text":"<p>Multi-index search.</p> <p>Parameters:</p> Name Type Description Default <code>queries</code> <code>list[SearchParams]</code> <p>List of SearchParameters</p> required <code>federation</code> <code>Federation | FederationMerged | None</code> <p>If included a single search result with hits built from all queries will be returned. This parameter can only be used with Meilisearch &gt;= v1.10.0. Defaults to None.</p> <code>None</code> <code>hits_type</code> <code>Any</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> <p>Returns:</p> Type Description <code>list[SearchResultsWithUID] | SearchResultsFederated</code> <p>Results of the search</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     queries = [     &gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),     &gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")     &gt;&gt;&gt;     ]     &gt;&gt;&gt;     search_results = client.search(queries)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def multi_search(\n    self,\n    queries: list[SearchParams],\n    *,\n    federation: Federation | FederationMerged | None = None,\n    hits_type: Any = JsonDict,  # noqa: ANN401\n) -&gt; list[SearchResultsWithUID] | SearchResultsFederated:\n    \"\"\"Multi-index search.\n\n    Args:\n        queries: List of SearchParameters\n        federation: If included a single search result with hits built from all queries will\n            be returned. This parameter can only be used with Meilisearch &gt;= v1.10.0. Defaults\n            to None.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n\n    Returns:\n        Results of the search\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     queries = [\n        &gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n        &gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n        &gt;&gt;&gt;     ]\n        &gt;&gt;&gt;     search_results = client.search(queries)\n    \"\"\"\n    url = \"multi-search\"\n    processed_queries = []\n    for query in queries:\n        q = query.model_dump(by_alias=True)\n\n        if query.retrieve_vectors is None:\n            del q[\"retrieveVectors\"]\n\n        if federation:\n            del q[\"limit\"]\n            del q[\"offset\"]\n\n        if query.media is None:\n            del q[\"media\"]\n\n        if query.show_performance_details is None:\n            del q[\"showPerformanceDetails\"]\n\n        processed_queries.append(q)\n\n    if federation:\n        federation_payload = federation.model_dump(by_alias=True)\n        if federation.facets_by_index is None:\n            del federation_payload[\"facetsByIndex\"]\n\n    else:\n        federation_payload = None\n\n    response = self._http_requests.post(\n        url,\n        body={\n            \"federation\": federation_payload,\n            \"queries\": processed_queries,\n        },\n    )\n\n    if federation:\n        results = self._http_requests.parse_json(response)\n        return SearchResultsFederated[hits_type](**results)\n\n    return [\n        SearchResultsWithUID[hits_type](**x)\n        for x in self._http_requests.parse_json(response)[\"results\"]\n    ]\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.swap_indexes","title":"<code>swap_indexes(indexes, rename=False)</code>","text":"<p>Swap two indexes.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>list[tuple[str, str]]</code> <p>A list of tuples, each tuple should contain the indexes to swap.</p> required <code>rename</code> <code>bool</code> <p>Use rename false if you are swapping two existing indexes. Use rename true if the second index in your array does not exist. Default = False</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.swap_indexes([(\"index_a\", \"index_b\")])</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def swap_indexes(self, indexes: list[tuple[str, str]], rename: bool = False) -&gt; TaskInfo:\n    \"\"\"Swap two indexes.\n\n    Args:\n        indexes: A list of tuples, each tuple should contain the indexes to swap.\n        rename: Use rename false if you are swapping two existing indexes. Use rename true if\n            the second index in your array does not exist. Default = False\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.swap_indexes([(\"index_a\", \"index_b\")])\n    \"\"\"\n    if rename:\n        processed_indexes = [{\"indexes\": x, \"rename\": True} for x in indexes]\n    else:\n        processed_indexes = [{\"indexes\": x} for x in indexes]\n    response = self._http_requests.post(\"swap-indexes\", processed_indexes)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.transfer_documents","title":"<code>transfer_documents(url, *, api_key=None, payload_size=None, indexes=None)</code>","text":"<p>Transfer settings and documents from one Meilisearch instance to another.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Where to send our settings and documents.</p> required <code>api_key</code> <code>str | None</code> <p>The API key with the rights to send the requests. Usually the master key of the remote machine. Defaults to None.</p> <code>None</code> <code>payload_size</code> <code>str | None</code> <p>Human readable size defining the size of the payloads to send. Defaults to 50\u00a0MiB.</p> <code>None</code> <code>indexes</code> <code>JsonMapping | None</code> <p>A set of patterns of matching the indexes you want to export. Defaults to all indexes without filter.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index.transfer_documents(\"https://another-instance.com\", api_key=\"otherMasterKey\")</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def transfer_documents(  # pragma: no cover\n    self,\n    url: str,\n    *,\n    api_key: str | None = None,\n    payload_size: str | None = None,\n    indexes: JsonMapping | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Transfer settings and documents from one Meilisearch instance to another.\n\n    Args:\n        url: Where to send our settings and documents.\n        api_key: The API key with the rights to send the requests. Usually the master key of\n            the remote machine. Defaults to None.\n        payload_size: Human readable size defining the size of the payloads to send. Defaults\n            to 50\u00a0MiB.\n        indexes: A set of patterns of matching the indexes you want to export. Defaults to all\n            indexes without filter.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index.transfer_documents(\"https://another-instance.com\", api_key=\"otherMasterKey\")\n    \"\"\"\n    payload: JsonDict = {\"url\": url}\n\n    if api_key:\n        payload[\"apiKey\"] = api_key\n\n    if payload:\n        payload[\"payloadSize\"] = payload_size\n\n    if indexes:\n        payload[\"indexes\"] = indexes\n\n    response = self._http_requests.post(url, body=payload)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.update_experimental_features","title":"<code>update_experimental_features(features)</code>","text":"<p>Update the status of an experimental feature.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>dict[str, bool]</code> <p>Dictionary of features to enable/disable. The dictionary keys can be in either camel case or snake case, the conversion to the correct type will be handed for you by the program. For example {\"logsRoute\": True} and {\"logs_route\": True} will both work.</p> required <p>Returns:</p> Type Description <code>dict[str, bool]</code> <p>The status of the experimental features.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index.update_experimental_features({\"logsRoute\": True})</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def update_experimental_features(self, features: dict[str, bool]) -&gt; dict[str, bool]:\n    \"\"\"Update the status of an experimental feature.\n\n    Args:\n        features: Dictionary of features to enable/disable. The dictionary keys can be in either\n            camel case or snake case, the conversion to the correct type will be handed for you by\n            the program. For example {\"logsRoute\": True} and {\"logs_route\": True} will both work.\n\n    Returns:\n        The status of the experimental features.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index.update_experimental_features({\"logsRoute\": True})\n    \"\"\"\n    payload = dict_to_camel(features)\n    response = self._http_requests.patch(\"/experimental-features\", body=payload)\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.update_key","title":"<code>update_key(key)</code>","text":"<p>Update an API key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>KeyUpdate</code> <p>The information to use in updating the key. Note that if an expires_at value is included it should be in UTC time.</p> required <p>Returns:</p> Type Description <code>Key</code> <p>The updated API key.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     key_info = KeyUpdate(                 key=\"abc123\",     &gt;&gt;&gt;         indexes=[\"*\"],     &gt;&gt;&gt;     )     &gt;&gt;&gt;     keys = client.update_key(key_info)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def update_key(self, key: KeyUpdate) -&gt; Key:\n    \"\"\"Update an API key.\n\n    Args:\n        key: The information to use in updating the key. Note that if an expires_at value\n            is included it should be in UTC time.\n\n    Returns:\n        The updated API key.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     key_info = KeyUpdate(\n                    key=\"abc123\",\n        &gt;&gt;&gt;         indexes=[\"*\"],\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt;     keys = client.update_key(key_info)\n    \"\"\"\n    payload = _build_update_key_payload(key, self.json_handler)\n    response = self._http_requests.patch(f\"keys/{key.key}\", payload)\n\n    return Key(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.update_webhook","title":"<code>update_webhook(*, uuid, webhook)</code>","text":"<p>Update an existing webhook.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The webhook's unique identifier.</p> required <code>webhook</code> <code>WebhookUpdate</code> <p>The webhook configuration updates.</p> required <p>Returns:</p> Type Description <code>Webhook</code> <p>The updated webhook.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookUpdate\n&gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     webhook_update = WebhookUpdate(url=\"https://example.com/new-webhook\")\n&gt;&gt;&gt;     webhook = client.update_webhook(\"abc-123\", webhook_update)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def update_webhook(self, *, uuid: str, webhook: WebhookUpdate) -&gt; Webhook:\n    \"\"\"Update an existing webhook.\n\n    Args:\n        uuid: The webhook's unique identifier.\n        webhook: The webhook configuration updates.\n\n    Returns:\n        The updated webhook.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.webhook import WebhookUpdate\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     webhook_update = WebhookUpdate(url=\"https://example.com/new-webhook\")\n        &gt;&gt;&gt;     webhook = client.update_webhook(\"abc-123\", webhook_update)\n    \"\"\"\n    response = self._http_requests.patch(\n        f\"webhooks/{uuid}\", webhook.model_dump(by_alias=True, exclude_none=True)\n    )\n\n    return Webhook(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.wait_for_task","title":"<code>wait_for_task(task_id, *, timeout_in_ms=5000, interval_in_ms=50, raise_for_status=False)</code>","text":"<p>Wait until Meilisearch processes a task, and get its status.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>Identifier of the task to retrieve.</p> required <code>timeout_in_ms</code> <code>int | None</code> <p>Amount of time in milliseconds to wait before raising a MeilisearchTimeoutError. <code>None</code> can also be passed to wait indefinitely. Be aware that if the <code>None</code> option is used the wait time could be very long. Defaults to 5000.</p> <code>5000</code> <code>interval_in_ms</code> <code>int</code> <p>Time interval in milliseconds to sleep between requests. Defaults to 50.</p> <code>50</code> <code>raise_for_status</code> <code>bool</code> <p>When set to <code>True</code> a MeilisearchTaskFailedError will be raised if a task has a failed status. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskResult</code> <p>Details of the processed update status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>MeilisearchTimeoutError</code> <p>If the connection times out.</p> <code>MeilisearchTaskFailedError</code> <p>If <code>raise_for_status</code> is <code>True</code> and a task has a failed status.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     response = await index.add_documents(documents)     &gt;&gt;&gt;     client.wait_for_task(response.update_id)</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def wait_for_task(\n    self,\n    task_id: int,\n    *,\n    timeout_in_ms: int | None = 5000,\n    interval_in_ms: int = 50,\n    raise_for_status: bool = False,\n) -&gt; TaskResult:\n    \"\"\"Wait until Meilisearch processes a task, and get its status.\n\n    Args:\n        task_id: Identifier of the task to retrieve.\n        timeout_in_ms: Amount of time in milliseconds to wait before raising a\n            MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n            if the `None` option is used the wait time could be very long. Defaults to 5000.\n        interval_in_ms: Time interval in milliseconds to sleep between requests. Defaults to 50.\n        raise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n            has a failed status. Defaults to False.\n\n    Returns:\n        Details of the processed update status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n        MeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     response = await index.add_documents(documents)\n        &gt;&gt;&gt;     client.wait_for_task(response.update_id)\n    \"\"\"\n    return _task.wait_for_task(\n        self.http_client,\n        task_id=task_id,\n        timeout_in_ms=timeout_in_ms,\n        interval_in_ms=interval_in_ms,\n        raise_for_status=raise_for_status,\n    )\n</code></pre>"},{"location":"decorators_api/","title":"Decorators","text":""},{"location":"decorators_api/#decorator-usage","title":"Decorator Usage","text":"<p>Various decorators are provided that can be used to help with the Meilisearch interaction.</p>"},{"location":"decorators_api/#meilisearch_python_sdk.decorators.ConnectionInfo","title":"<code>ConnectionInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Information on how to connect to Meilisearch.</p> <p>url: URL for the Meilisearch server. api_key: The API key for the server.</p> Source code in <code>meilisearch_python_sdk/decorators.py</code> <pre><code>class ConnectionInfo(NamedTuple):\n    \"\"\"Information on how to connect to Meilisearch.\n\n    url: URL for the Meilisearch server.\n    api_key: The API key for the server.\n    \"\"\"\n\n    url: str\n    api_key: str\n</code></pre>"},{"location":"decorators_api/#meilisearch_python_sdk.decorators.add_documents","title":"<code>add_documents(*, index_name, connection_info, batch_size=None, primary_key=None, wait_for_task=False, verify=True)</code>","text":"<p>Decorator that takes the returned documents from a function and adds them to Meilisearch.</p> <p>It is required that either an client or url is provided.</p> <p>Parameters:</p> Name Type Description Default <code>index_name</code> <code>str</code> <p>The name of the index to which the documents should be added.</p> required <code>connection_info</code> <code>Client | ConnectionInfo</code> <p>Either an Client instance ConnectionInfo with information on how to connect to Meilisearch.</p> required <code>batch_size</code> <code>int | None</code> <p>If provided the documents will be sent in batches of the specified size. Otherwise all documents are sent at once. Default = None.</p> <code>None</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>wait_for_task</code> <code>bool</code> <p>If set to <code>True</code> the decorator will wait for the document addition to finish indexing before returning, otherwise it will return right away. Default = False.</p> <code>False</code> <code>verify</code> <code>bool</code> <p>If set to <code>False</code> the decorator will not verify the SSL certificate of the server.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The list of documents provided by the decorated function.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>ValueError</code> <p>If neither an async_client nor an url is provided.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilisearch_python_sdk.decorators import add_documents, ConnectionInfo     &gt;&gt;&gt;     &gt;&gt;&gt;     &gt;&gt;&gt; # With <code>Client</code>     &gt;&gt;&gt; client = Client(url=\"http://localhost:7700\", api_key=\"masterKey\")     &gt;&gt;&gt; @add_documents(index_name=\"movies\", connection_info=client)     &gt;&gt;&gt; def my_function() -&gt; list[dict[str, Any]]:     &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]     &gt;&gt;&gt;     &gt;&gt;&gt; # With <code>ConnectionInfo</code>     &gt;&gt;&gt; @add_documents(             index_name=\"movies\",             connection_info=ConnectionInfo(url=\"http://localhost:7700\", api_key=\"masterKey\"),         )     &gt;&gt;&gt; def my_function() -&gt; list[dict[str, Any]]:     &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]</p> Source code in <code>meilisearch_python_sdk/decorators.py</code> <pre><code>def add_documents(\n    *,\n    index_name: str,\n    connection_info: Client | ConnectionInfo,\n    batch_size: int | None = None,\n    primary_key: str | None = None,\n    wait_for_task: bool = False,\n    verify: bool = True,\n) -&gt; Callable:\n    \"\"\"Decorator that takes the returned documents from a function and adds them to Meilisearch.\n\n    It is required that either an client or url is provided.\n\n    Args:\n        index_name: The name of the index to which the documents should be added.\n        connection_info: Either an Client instance ConnectionInfo with information on how to\n            connect to Meilisearch.\n        batch_size: If provided the documents will be sent in batches of the specified size.\n            Otherwise all documents are sent at once. Default = None.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        wait_for_task: If set to `True` the decorator will wait for the document addition to finish\n            indexing before returning, otherwise it will return right away. Default = False.\n        verify: If set to `False` the decorator will not verify the SSL certificate of the server.\n\n    Returns:\n        The list of documents provided by the decorated function.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        ValueError: If neither an async_client nor an url is provided.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.decorators import add_documents, ConnectionInfo\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With `Client`\n        &gt;&gt;&gt; client = Client(url=\"http://localhost:7700\", api_key=\"masterKey\")\n        &gt;&gt;&gt; @add_documents(index_name=\"movies\", connection_info=client)\n        &gt;&gt;&gt; def my_function() -&gt; list[dict[str, Any]]:\n        &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With `ConnectionInfo`\n        &gt;&gt;&gt; @add_documents(\n                index_name=\"movies\",\n                connection_info=ConnectionInfo(url=\"http://localhost:7700\", api_key=\"masterKey\"),\n            )\n        &gt;&gt;&gt; def my_function() -&gt; list[dict[str, Any]]:\n        &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:  # noqa: ANN401\n            result = func(*args, **kwargs)\n            if isinstance(connection_info, Client):\n                _add_documents(\n                    connection_info,\n                    index_name,\n                    result,\n                    batch_size,\n                    primary_key,\n                    wait_for_task,\n                )\n                return result\n\n            decorator_client = Client(\n                url=connection_info.url, api_key=connection_info.api_key, verify=verify\n            )\n            _add_documents(\n                decorator_client,\n                index_name,\n                result,\n                batch_size,\n                primary_key,\n                wait_for_task,\n            )\n\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"decorators_api/#meilisearch_python_sdk.decorators.async_add_documents","title":"<code>async_add_documents(*, index_name, connection_info, batch_size=None, primary_key=None, wait_for_task=False, verify=True)</code>","text":"<p>Decorator that takes the returned documents from a function and asynchronously adds them to Meilisearch.</p> <p>It is required that either an async_client or url is provided.</p> <p>Parameters:</p> Name Type Description Default <code>index_name</code> <code>str</code> <p>The name of the index to which the documents should be added.</p> required <code>connection_info</code> <code>AsyncClient | ConnectionInfo</code> <p>Either an AsyncClient instance ConnectionInfo with information on how to connect to Meilisearch.</p> required <code>batch_size</code> <code>int | None</code> <p>If provided the documents will be sent in batches of the specified size. Otherwise all documents are sent at once. Default = None.</p> <code>None</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>wait_for_task</code> <code>bool</code> <p>If set to <code>True</code> the decorator will wait for the document addition to finish indexing before returning, otherwise it will return right away. Default = False.</p> <code>False</code> <code>verify</code> <code>bool</code> <p>If set to <code>False</code> the decorator will not verify the SSL certificate of the server.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The list of documents provided by the decorated function.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <code>ValueError</code> <p>If neither an async_client nor an url is provided.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.decorators import async_add_documents, ConnectionInfo     &gt;&gt;&gt;     &gt;&gt;&gt;     &gt;&gt;&gt; # with <code>AsyncClient</code>     &gt;&gt;&gt; client = AsyncClient(url=\"http://localhost:7700\", api_key=\"masterKey\")     &gt;&gt;&gt; @async_add_documents(index_name=\"movies\", connection_info=client)     &gt;&gt;&gt; async def my_function() -&gt; list[dict[str, Any]]:     &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]     &gt;&gt;&gt;     &gt;&gt;&gt; # with <code>ConnectionInfo</code>     &gt;&gt;&gt; @async_add_documents(             index_name=\"movies\",             connection_info=ConnectionInfo(url=\"http://localhost:7700\", api_key=\"masterKey\"),         )     &gt;&gt;&gt; async def my_function() -&gt; list[dict[str, Any]]:     &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]</p> Source code in <code>meilisearch_python_sdk/decorators.py</code> <pre><code>def async_add_documents(\n    *,\n    index_name: str,\n    connection_info: AsyncClient | ConnectionInfo,\n    batch_size: int | None = None,\n    primary_key: str | None = None,\n    wait_for_task: bool = False,\n    verify: bool = True,\n) -&gt; Callable:\n    \"\"\"Decorator that takes the returned documents from a function and asynchronously adds them to Meilisearch.\n\n    It is required that either an async_client or url is provided.\n\n    Args:\n        index_name: The name of the index to which the documents should be added.\n        connection_info: Either an AsyncClient instance ConnectionInfo with information on how to\n            connect to Meilisearch.\n        batch_size: If provided the documents will be sent in batches of the specified size.\n            Otherwise all documents are sent at once. Default = None.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        wait_for_task: If set to `True` the decorator will wait for the document addition to finish\n            indexing before returning, otherwise it will return right away. Default = False.\n        verify: If set to `False` the decorator will not verify the SSL certificate of the server.\n\n    Returns:\n        The list of documents provided by the decorated function.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        ValueError: If neither an async_client nor an url is provided.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.decorators import async_add_documents, ConnectionInfo\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # with `AsyncClient`\n        &gt;&gt;&gt; client = AsyncClient(url=\"http://localhost:7700\", api_key=\"masterKey\")\n        &gt;&gt;&gt; @async_add_documents(index_name=\"movies\", connection_info=client)\n        &gt;&gt;&gt; async def my_function() -&gt; list[dict[str, Any]]:\n        &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # with `ConnectionInfo`\n        &gt;&gt;&gt; @async_add_documents(\n                index_name=\"movies\",\n                connection_info=ConnectionInfo(url=\"http://localhost:7700\", api_key=\"masterKey\"),\n            )\n        &gt;&gt;&gt; async def my_function() -&gt; list[dict[str, Any]]:\n        &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        async def wrapper(*args: Any, **kwargs: Any) -&gt; Any:  # noqa: ANN401\n            result = await func(*args, **kwargs)\n            if isinstance(connection_info, AsyncClient):\n                await _async_add_documents(\n                    connection_info,\n                    index_name,\n                    result,\n                    batch_size,\n                    primary_key,\n                    wait_for_task,\n                )\n                return result\n\n            async with AsyncClient(\n                connection_info.url, connection_info.api_key, verify=verify\n            ) as client:\n                await _async_add_documents(\n                    client, index_name, result, batch_size, primary_key, wait_for_task\n                )\n\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"index_api/","title":"Index","text":""},{"location":"index_api/#index-usage","title":"<code>Index</code> Usage","text":"<p>The <code>Index</code> uses blocking methods, and and should be used when using the <code>Client</code>. When you create a new index with the <code>Client</code> it will create an <code>Index</code> instance.</p>"},{"location":"index_api/#index-api","title":"<code>Index</code> API","text":"<p>               Bases: <code>BaseIndex</code></p> <p>Index class gives access to all indexes routes and child routes.</p> <p>https://docs.meilisearch.com/reference/api/indexes.html</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>class Index(BaseIndex):\n    \"\"\"Index class gives access to all indexes routes and child routes.\n\n    https://docs.meilisearch.com/reference/api/indexes.html\n    \"\"\"\n\n    def __init__(\n        self,\n        http_client: Client,\n        uid: str,\n        primary_key: str | None = None,\n        created_at: str | datetime | None = None,\n        updated_at: str | datetime | None = None,\n        plugins: IndexPlugins | None = None,\n        json_handler: BuiltinHandler | OrjsonHandler | None = None,\n        *,\n        hits_type: type[Any] = JsonDict,\n    ) -&gt; None:\n        \"\"\"Class initializer.\n\n        Args:\n            http_client: An instance of the Client. This automatically gets passed by the\n                Client when creating and Index instance.\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            created_at: The date and time the index was created. Defaults to None.\n            updated_at: The date and time the index was last updated. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n            json_handler: The module to use for json operations. The options are BuiltinHandler\n                (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n                Note that in order use orjson the corresponding extra needs to be included.\n                Default: BuiltinHandler.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n        \"\"\"\n        super().__init__(\n            uid=uid,\n            primary_key=primary_key,\n            created_at=created_at,\n            updated_at=updated_at,\n            json_handler=json_handler,\n            hits_type=hits_type,\n        )\n        self.http_client = http_client\n        self._http_requests = HttpRequests(http_client, json_handler=self._json_handler)\n        self.plugins = plugins\n\n    @cached_property\n    def _post_add_documents_plugins(self) -&gt; list[Plugin | DocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.add_documents_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_add_documents_plugins(self) -&gt; list[Plugin | DocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.add_documents_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _post_delete_all_documents_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_all_documents_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_delete_all_documents_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_all_documents_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _post_delete_document_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_document_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_delete_document_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_document_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _post_delete_documents_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_delete_documents_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _post_delete_documents_by_filter_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_by_filter_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_delete_documents_by_filter_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        return filter_plugins(self.plugins.delete_documents_by_filter_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _post_facet_search_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.facet_search_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_facet_search_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.facet_search_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _post_search_plugins(self) -&gt; list[Plugin | PostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.search_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_search_plugins(self) -&gt; list[Plugin | PostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        return filter_plugins(self.plugins.search_plugins, \"PRE_EVENT\")\n\n    @cached_property\n    def _post_update_documents_plugins(self) -&gt; list[Plugin | DocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.update_documents_plugins, \"POST_EVENT\")\n\n    @cached_property\n    def _pre_update_documents_plugins(self) -&gt; list[Plugin | DocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        return filter_plugins(self.plugins.update_documents_plugins, \"PRE_EVENT\")\n\n    def compact(self) -&gt; TaskInfo:\n        \"\"\"Appends a new task to the queue to compact the database.\n\n        This defragments the LMDB database potentially speeds up indexing and searching.\n        NOTE: This is only available in Meilisearch v1.23.0+\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.compact()\n        \"\"\"\n        response = self._http_requests.post(f\"{self._base_url_with_uid}/compact\")\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def delete(self) -&gt; TaskInfo:\n        \"\"\"Deletes the index.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.delete()\n        \"\"\"\n        response = self._http_requests.delete(self._base_url_with_uid)\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def delete_if_exists(self) -&gt; bool:\n        \"\"\"Delete the index if it already exists.\n\n        Returns:\n            True if the index was deleted or False if not.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.delete_if_exists()\n        \"\"\"\n        response = self.delete()\n        status = wait_for_task(self.http_client, response.task_uid, timeout_in_ms=100000)\n        if status.status == \"succeeded\":\n            return True\n\n        return False\n\n    def update(self, primary_key: str) -&gt; Self:\n        \"\"\"Update the index primary key.\n\n        Args:\n            primary_key: The primary key of the documents.\n\n        Returns:\n            An instance of the AsyncIndex with the updated information.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     updated_index = index.update()\n        \"\"\"\n        payload = {\"primaryKey\": primary_key}\n        response = self._http_requests.patch(self._base_url_with_uid, payload)\n        wait_for_task(\n            self.http_client,\n            self._http_requests.parse_json(response)[\"taskUid\"],\n            timeout_in_ms=100000,\n        )\n        index_response = self._http_requests.get(self._base_url_with_uid)\n        self.primary_key = self._http_requests.parse_json(index_response)[\"primaryKey\"]\n        return self\n\n    def fetch_info(self) -&gt; Self:\n        \"\"\"Gets the information about the index.\n\n        Returns:\n            An instance of the AsyncIndex containing the retrieved information.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index_info = index.fetch_info()\n        \"\"\"\n        response = self._http_requests.get(self._base_url_with_uid)\n        index_dict = self._http_requests.parse_json(response)\n        self._set_fetch_info(\n            index_dict[\"primaryKey\"], index_dict[\"createdAt\"], index_dict[\"updatedAt\"]\n        )\n        return self\n\n    def get_primary_key(self) -&gt; str | None:\n        \"\"\"Get the primary key.\n\n        Returns:\n            The primary key for the documents in the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     primary_key = index.get_primary_key()\n        \"\"\"\n        info = self.fetch_info()\n        return info.primary_key\n\n    @classmethod\n    def create(\n        cls,\n        http_client: Client,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        settings: MeilisearchSettings | None = None,\n        wait: bool = True,\n        timeout_in_ms: int | None = None,\n        plugins: IndexPlugins | None = None,\n        json_handler: BuiltinHandler | OrjsonHandler | None = None,\n        hits_type: type[Any] = JsonDict,\n    ) -&gt; Self:\n        \"\"\"Creates a new index.\n\n        In general this method should not be used directly and instead the index should be created\n        through the `Client`.\n\n        Args:\n            http_client: An instance of the Client. This automatically gets passed by the Client\n                when creating an Index instance.\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            settings: Settings for the index. The settings can also be updated independently of\n                creating the index. The advantage to updating them here is updating the settings after\n                adding documents will cause the documents to be re-indexed. Because of this it will be\n                faster to update them before adding documents. Defaults to None (i.e. default\n                Meilisearch index settings).\n            wait: If set to True and settings are being updated, the index will be returned after\n                the settings update has completed. If False it will not wait for settings to complete.\n                Default: True\n            timeout_in_ms: Amount of time in milliseconds to wait before raising a\n                MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n                if the `None` option is used the wait time could be very long. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n            json_handler: The module to use for json operations. The options are BuiltinHandler\n                (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n                Note that in order use orjson the corresponding extra needs to be included.\n                Default: BuiltinHandler.\n            hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n                JsonDict\n\n        Returns:\n            An instance of Index containing the information of the newly created index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = index.create(client, \"movies\")\n        \"\"\"\n        if not primary_key:\n            payload = {\"uid\": uid}\n        else:\n            payload = {\"primaryKey\": primary_key, \"uid\": uid}\n\n        url = \"indexes\"\n        handler = json_handler if json_handler else BuiltinHandler()\n        http_request = HttpRequests(http_client, handler)\n        response = http_request.post(url, payload)\n        wait_for_task(\n            http_client, http_request.parse_json(response)[\"taskUid\"], timeout_in_ms=timeout_in_ms\n        )\n        index_response = http_request.get(f\"{url}/{uid}\")\n        index_dict = http_request.parse_json(index_response)\n        index = cls(\n            http_client=http_client,\n            uid=index_dict[\"uid\"],\n            primary_key=index_dict[\"primaryKey\"],\n            created_at=index_dict[\"createdAt\"],\n            updated_at=index_dict[\"updatedAt\"],\n            plugins=plugins,\n            json_handler=json_handler,\n            hits_type=hits_type,\n        )\n\n        if settings:\n            settings_task = index.update_settings(settings)\n            if wait:\n                wait_for_task(http_client, settings_task.task_uid, timeout_in_ms=timeout_in_ms)\n\n        return index\n\n    def get_stats(self) -&gt; IndexStats:\n        \"\"\"Get stats of the index.\n\n        Returns:\n            Stats of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     stats = index.get_stats()\n        \"\"\"\n        response = self._http_requests.get(self._stats_url)\n\n        return IndexStats(**self._http_requests.parse_json(response))\n\n    def search(\n        self,\n        query: str | None = None,\n        *,\n        offset: int = 0,\n        limit: int = 20,\n        filter: Filter | None = None,\n        facets: list[str] | None = None,\n        attributes_to_retrieve: list[str] | None = None,\n        attributes_to_crop: list[str] | None = None,\n        crop_length: int = 200,\n        attributes_to_highlight: list[str] | None = None,\n        sort: list[str] | None = None,\n        show_matches_position: bool = False,\n        highlight_pre_tag: str = \"&lt;em&gt;\",\n        highlight_post_tag: str = \"&lt;/em&gt;\",\n        crop_marker: str = \"...\",\n        matching_strategy: Literal[\"all\", \"last\", \"frequency\"] = \"last\",\n        hits_per_page: int | None = None,\n        page: int | None = None,\n        attributes_to_search_on: list[str] | None = None,\n        distinct: str | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        ranking_score_threshold: float | None = None,\n        vector: list[float] | None = None,\n        hybrid: Hybrid | None = None,\n        locales: list[str] | None = None,\n        retrieve_vectors: bool | None = None,\n        media: JsonMapping | None = None,\n        show_performance_details: bool = False,\n    ) -&gt; SearchResults:\n        \"\"\"Search the index.\n\n        Args:\n            query: String containing the word(s) to search\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            facets: Facets for which to retrieve the matching count. Defaults to None.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n            crop_length: The maximum number of words to display. Defaults to 200.\n            attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n                Defaults to None.\n            sort: Attributes by which to sort the results. Defaults to None.\n            show_matches_position: Defines whether an object that contains information about the\n                matches should be returned or not. Defaults to False.\n            highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n            highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n            crop_marker: Marker to display when the number of words exceeds the `crop_length`.\n                Defaults to ...\n            matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to\n                `last`.\n            hits_per_page: Sets the number of results returned per page.\n            page: Sets the specific results page to fetch.\n            attributes_to_search_on: List of field names. Allow search over a subset of searchable\n                attributes without modifying the index settings. Defaults to None.\n            distinct: If set the distinct value will return at most one result for the\n                filterable attribute. Note that a filterable attributes must be set for this work.\n                Defaults to None.\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n                to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n                sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n                Because this feature is experimental it may be removed or updated causing breaking\n                changes in this library without a major version bump so use with caution. This\n                feature became stable in Meiliseach v1.7.0.\n            ranking_score_threshold: If set, no document whose _rankingScore is under the\n                rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n                to None.\n            vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n                In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n            hybrid: Hybrid search information. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n                In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n            locales: Specifies the languages for the search. This parameter can only be used with\n                Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.\n            retrieve_vectors: Return document vector data with search result.\n            media: The content of media is used as if it were a document to generate request\n                fragments from the searchFragments parameter. Defaults to None. This parameter can\n                only be used with Meilisearch &gt;= v1.16.0. In order to use this feature in\n                Meilisearch v1.16.0 you first need to enable the feature by sending a PATCH request\n                to /experimental-features with { \"multimodal\": true }. Because this feature is\n                experimental it may be removed or updated causing breaking changes in this library\n                without a major version bump so use with caution.\n            show_performance_details: When set to true, the search response contains a performance\n                trace. Default False.\n\n        Returns:\n            Results of the search\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_results = index.search(\"Tron\")\n        \"\"\"\n        if ranking_score_threshold:\n            validate_ranking_score_threshold(ranking_score_threshold)\n\n        body = process_search_parameters(\n            q=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            distinct=distinct,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n            hybrid=hybrid,\n            ranking_score_threshold=ranking_score_threshold,\n            locales=locales,\n            retrieve_vectors=retrieve_vectors,\n            media=media,\n            show_performance_details=show_performance_details,\n        )\n\n        if self._pre_search_plugins:\n            _run_plugins(\n                self._pre_search_plugins,\n                Event.PRE,\n                query=query,\n                offset=offset,\n                limit=limit,\n                filter=filter,\n                facets=facets,\n                attributes_to_retrieve=attributes_to_retrieve,\n                attributes_to_crop=attributes_to_crop,\n                crop_length=crop_length,\n                attributes_to_highlight=attributes_to_highlight,\n                sort=sort,\n                show_matches_position=show_matches_position,\n                highlight_pre_tag=highlight_pre_tag,\n                highlight_post_tag=highlight_post_tag,\n                crop_marker=crop_marker,\n                matching_strategy=matching_strategy,\n                hits_per_page=hits_per_page,\n                page=page,\n                attributes_to_search_on=attributes_to_search_on,\n                distinct=distinct,\n                show_ranking_score=show_ranking_score,\n                show_ranking_score_details=show_ranking_score_details,\n                vector=vector,\n                hybrid=hybrid,\n            )\n\n        response = self._http_requests.post(f\"{self._base_url_with_uid}/search\", body=body)\n        result = SearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n        if self._post_search_plugins:\n            post = _run_plugins(self._post_search_plugins, Event.POST, search_results=result)\n            if post.get(\"search_result\"):\n                result = post[\"search_result\"]\n\n        return result\n\n    def facet_search(\n        self,\n        query: str | None = None,\n        *,\n        facet_name: str,\n        facet_query: str,\n        offset: int = 0,\n        limit: int = 20,\n        filter: Filter | None = None,\n        facets: list[str] | None = None,\n        attributes_to_retrieve: list[str] | None = None,\n        attributes_to_crop: list[str] | None = None,\n        crop_length: int = 200,\n        attributes_to_highlight: list[str] | None = None,\n        sort: list[str] | None = None,\n        show_matches_position: bool = False,\n        highlight_pre_tag: str = \"&lt;em&gt;\",\n        highlight_post_tag: str = \"&lt;/em&gt;\",\n        crop_marker: str = \"...\",\n        matching_strategy: Literal[\"all\", \"last\", \"frequency\"] = \"last\",\n        hits_per_page: int | None = None,\n        page: int | None = None,\n        attributes_to_search_on: list[str] | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        ranking_score_threshold: float | None = None,\n        vector: list[float] | None = None,\n        locales: list[str] | None = None,\n        retrieve_vectors: bool | None = None,\n        exhaustive_facet_count: bool | None = None,\n    ) -&gt; FacetSearchResults:\n        \"\"\"Search the index.\n\n        Args:\n            query: String containing the word(s) to search\n            facet_name: The name of the facet to search\n            facet_query: The facet search value\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            facets: Facets for which to retrieve the matching count. Defaults to None.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n            crop_length: The maximum number of words to display. Defaults to 200.\n            attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n                Defaults to None.\n            sort: Attributes by which to sort the results. Defaults to None.\n            show_matches_position: Defines whether an object that contains information about the\n                matches should be returned or not. Defaults to False.\n            highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n            highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n            crop_marker: Marker to display when the number of words exceeds the `crop_length`.\n                Defaults to ...\n            matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to\n                `last`.\n            hits_per_page: Sets the number of results returned per page.\n            page: Sets the specific results page to fetch.\n            attributes_to_search_on: List of field names. Allow search over a subset of searchable\n                attributes without modifying the index settings. Defaults to None.\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n                to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n                sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n                Because this feature is experimental it may be removed or updated causing breaking\n                changes in this library without a major version bump so use with caution. This\n                feature became stable in Meiliseach v1.7.0.\n            ranking_score_threshold: If set, no document whose _rankingScore is under the\n                rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n                to None.\n            vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n                In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n            locales: Specifies the languages for the search. This parameter can only be used with\n                Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.\n            retrieve_vectors: Return document vector data with search result.\n            exhaustive_facet_count: forcing the facet search to compute the facet counts the same\n                way as the paginated search. This parameter can only be used with Milisearch &gt;=\n                v1.14.0. Defaults to None.\n\n        Returns:\n            Results of the search\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_results = index.search(\n            &gt;&gt;&gt;         \"Tron\",\n            &gt;&gt;&gt;         facet_name=\"genre\",\n            &gt;&gt;&gt;         facet_query=\"Sci-fi\"\n            &gt;&gt;&gt;     )\n        \"\"\"\n        if ranking_score_threshold:\n            validate_ranking_score_threshold(ranking_score_threshold)\n\n        body = process_search_parameters(\n            q=query,\n            facet_name=facet_name,\n            facet_query=facet_query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            ranking_score_threshold=ranking_score_threshold,\n            vector=vector,\n            locales=locales,\n            retrieve_vectors=retrieve_vectors,\n            exhaustive_facet_count=exhaustive_facet_count,\n        )\n\n        if self._pre_facet_search_plugins:\n            _run_plugins(\n                self._pre_facet_search_plugins,\n                Event.PRE,\n                query=query,\n                offset=offset,\n                limit=limit,\n                filter=filter,\n                facets=facets,\n                attributes_to_retrieve=attributes_to_retrieve,\n                attributes_to_crop=attributes_to_crop,\n                crop_length=crop_length,\n                attributes_to_highlight=attributes_to_highlight,\n                sort=sort,\n                show_matches_position=show_matches_position,\n                highlight_pre_tag=highlight_pre_tag,\n                highlight_post_tag=highlight_post_tag,\n                crop_marker=crop_marker,\n                matching_strategy=matching_strategy,\n                hits_per_page=hits_per_page,\n                page=page,\n                attributes_to_search_on=attributes_to_search_on,\n                show_ranking_score=show_ranking_score,\n                show_ranking_score_details=show_ranking_score_details,\n                ranking_score_threshold=ranking_score_threshold,\n                vector=vector,\n                exhaustive_facet_count=exhaustive_facet_count,\n            )\n\n        response = self._http_requests.post(f\"{self._base_url_with_uid}/facet-search\", body=body)\n        result = FacetSearchResults(**self._http_requests.parse_json(response))\n        if self._post_facet_search_plugins:\n            post = _run_plugins(self._post_facet_search_plugins, Event.POST, result=result)\n            if isinstance(post[\"generic_result\"], FacetSearchResults):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def search_similar_documents(\n        self,\n        id: str,\n        *,\n        offset: int | None = None,\n        limit: int | None = None,\n        filter: str | None = None,\n        embedder: str = \"default\",\n        attributes_to_retrieve: list[str] | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        ranking_score_threshold: float | None = None,\n    ) -&gt; SimilarSearchResults:\n        \"\"\"Search the index.\n\n        Args:\n            id: The id for the target document that is being used to find similar documents.\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            embedder: The vector DB to use for the search.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False.\n            ranking_score_threshold: If set, no document whose _rankingScore is under the\n                rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n                to None.\n\n        Returns:\n            Results of the search\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_results = index.search_similar_documents(\"123\")\n        \"\"\"\n        payload = {\n            \"id\": id,\n            \"filter\": filter,\n            \"embedder\": embedder,\n            \"attributesToRetrieve\": attributes_to_retrieve,\n            \"showRankingScore\": show_ranking_score,\n            \"showRankingScoreDetails\": show_ranking_score_details,\n            \"rankingScoreThreshold\": ranking_score_threshold,\n        }\n\n        if offset:\n            payload[\"offset\"] = offset\n\n        if limit:\n            payload[\"limit\"] = limit\n\n        response = self._http_requests.post(f\"{self._base_url_with_uid}/similar\", body=payload)\n\n        return SimilarSearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n\n    def get_document(\n        self,\n        document_id: str,\n        *,\n        fields: list[str] | None = None,\n        retrieve_vectors: bool = False,\n    ) -&gt; JsonDict:\n        \"\"\"Get one document with given document identifier.\n\n        Args:\n            document_id: Unique identifier of the document.\n            fields: Document attributes to show. If this value is None then all\n                attributes are retrieved. Defaults to None.\n            retrieve_vectors: If set to True the embedding vectors will be returned with the document.\n                Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.13.0\n        Returns:\n            The document information\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     document = index.get_document(\"1234\")\n        \"\"\"\n        parameters: JsonDict = {}\n\n        if fields:\n            parameters[\"fields\"] = \",\".join(fields)\n        if retrieve_vectors:\n            parameters[\"retrieveVectors\"] = \"true\"\n\n        url = build_encoded_url(f\"{self._documents_url}/{document_id}\", parameters)\n\n        response = self._http_requests.get(url)\n        return self._http_requests.parse_json(response)\n\n    def get_documents(\n        self,\n        *,\n        ids: list[str] | None = None,\n        offset: int = 0,\n        limit: int = 20,\n        fields: list[str] | None = None,\n        filter: Filter | None = None,\n        retrieve_vectors: bool = False,\n        sort: str | None = None,\n    ) -&gt; DocumentsInfo:\n        \"\"\"Get a batch documents from the index.\n\n        Args:\n            ids: Array of document primary keys to retrieve. Defaults to None (Gets all documents).\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returnedd. Defaults to 20.\n            fields: Document attributes to show. If this value is None then all\n                attributes are retrieved. Defaults to None.\n            filter: Filter value information. Defaults to None. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.2.0\n            retrieve_vectors: If set to True the vectors will be returned with each document.\n                Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.13.0\n            sort: Attribute by which to sort the results. Defaults to None.\n\n        Returns:\n            Documents info.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     documents = index.get_documents()\n        \"\"\"\n        parameters: JsonDict = {\n            \"offset\": offset,\n            \"limit\": limit,\n        }\n\n        if sort:\n            parameters[\"sort\"] = sort\n\n        if not filter and not ids:\n            if retrieve_vectors:\n                parameters[\"retrieveVectors\"] = \"true\"\n            if fields:\n                parameters[\"fields\"] = \",\".join(fields)\n\n            url = build_encoded_url(self._documents_url, parameters)\n            response = self._http_requests.get(url)\n\n            return DocumentsInfo(**self._http_requests.parse_json(response))\n\n        if retrieve_vectors:\n            parameters[\"retrieveVectors\"] = True\n\n        if fields:\n            parameters[\"fields\"] = fields\n\n        parameters[\"filter\"] = filter\n\n        if ids:\n            parameters[\"ids\"] = ids\n\n        response = self._http_requests.post(f\"{self._documents_url}/fetch\", body=parameters)\n\n        return DocumentsInfo(**self._http_requests.parse_json(response))\n\n    def add_documents(\n        self,\n        documents: Sequence[JsonMapping],\n        primary_key: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents to the index.\n\n        Args:\n            documents: List of documents.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.add_documents(documents)\n        \"\"\"\n        params = {}\n\n        if primary_key:\n            params[\"primaryKey\"] = primary_key\n        if custom_metadata:\n            params[\"customMetadata\"] = custom_metadata\n\n        if params:\n            url = build_encoded_url(self._documents_url, params)\n        else:\n            url = self._documents_url\n\n        if self._pre_add_documents_plugins:\n            pre = _run_plugins(\n                self._pre_add_documents_plugins,\n                Event.PRE,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if pre.get(\"document_result\"):\n                documents = pre[\"document_result\"]\n\n        response = self._http_requests.post(url, documents, compress=compress)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_add_documents_plugins:\n            post = _run_plugins(self._post_add_documents_plugins, Event.POST, result=result)\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def add_documents_in_batches(\n        self,\n        documents: Sequence[JsonMapping],\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Adds documents in batches to reduce RAM usage with indexing.\n\n        Args:\n            documents: List of documents.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.add_documents_in_batches(documents)\n        \"\"\"\n        return [\n            self.add_documents(x, primary_key, custom_metadata=custom_metadata, compress=compress)\n            for x in batch(documents, batch_size)\n        ]\n\n    def add_documents_from_directory(\n        self,\n        directory_path: Path | str,\n        *,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and add the documents to the index.\n\n        Args:\n            directory_path: Path to the directory that contains the json files.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row containing\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.add_documents_from_directory(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = _load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    all_documents.append(documents)\n\n            raise_on_no_documents(all_documents, document_type, directory_path)\n\n            combined = combine_documents_(all_documents)\n\n            response = self.add_documents(\n                combined, primary_key, custom_metadata=custom_metadata, compress=compress\n            )\n\n            return [response]\n\n        responses = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                responses.append(\n                    self.add_documents(\n                        documents, primary_key, custom_metadata=custom_metadata, compress=compress\n                    )\n                )\n\n        raise_on_no_documents(responses, document_type, directory_path)\n\n        return responses\n\n    def add_documents_from_directory_in_batches(\n        self,\n        directory_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and add the documents to the index in batches.\n\n        Args:\n            directory_path: Path to the directory that contains the json files.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row containing\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.add_documents_from_directory_in_batches(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = _load_documents_from_file(\n                        path, csv_delimiter=csv_delimiter, json_handler=self._json_handler\n                    )\n                    all_documents.append(documents)\n\n            raise_on_no_documents(all_documents, document_type, directory_path)\n\n            combined = combine_documents_(all_documents)\n\n            return self.add_documents_in_batches(\n                combined,\n                batch_size=batch_size,\n                primary_key=primary_key,\n                custom_metadata=custom_metadata,\n                compress=compress,\n            )\n\n        responses: list[TaskInfo] = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                responses.extend(\n                    self.add_documents_in_batches(\n                        documents,\n                        batch_size=batch_size,\n                        primary_key=primary_key,\n                        custom_metadata=custom_metadata,\n                        compress=compress,\n                    )\n                )\n\n        raise_on_no_documents(responses, document_type, directory_path)\n\n        return responses\n\n    def add_documents_from_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents to the index from a json file.\n\n        Args:\n            file_path: Path to the json file.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.add_documents_from_file(file_path)\n        \"\"\"\n        documents = _load_documents_from_file(file_path, json_handler=self._json_handler)\n\n        return self.add_documents(\n            documents, primary_key=primary_key, custom_metadata=custom_metadata, compress=compress\n        )\n\n    def add_documents_from_file_in_batches(\n        self,\n        file_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        csv_delimiter: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Adds documents form a json file in batches to reduce RAM usage with indexing.\n\n        Args:\n            file_path: Path to the json file.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.add_documents_from_file_in_batches(file_path)\n        \"\"\"\n        documents = _load_documents_from_file(\n            file_path, csv_delimiter, json_handler=self._json_handler\n        )\n\n        return self.add_documents_in_batches(\n            documents,\n            batch_size=batch_size,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            compress=compress,\n        )\n\n    def add_documents_from_raw_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        csv_delimiter: str | None = None,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n        The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n        for batching.\n\n        Args:\n            file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n                allowed.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n                a non-csv file.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.add_documents_from_raw_file(file_path)\n        \"\"\"\n        upload_path, content_type = prepare_raw_file_upload(file_path, csv_delimiter)\n        parameters = {}\n\n        if primary_key:\n            parameters[\"primaryKey\"] = primary_key\n        if csv_delimiter:\n            parameters[\"csvDelimiter\"] = csv_delimiter\n        if custom_metadata:\n            parameters[\"customMetadata\"] = custom_metadata\n\n        if parameters:\n            url = build_encoded_url(self._documents_url, parameters)\n        else:\n            url = self._documents_url\n\n        with open(upload_path) as f:\n            data = f.read()\n\n        response = self._http_requests.post(\n            url, body=data, content_type=content_type, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def edit_documents(\n        self,\n        function: str,\n        *,\n        context: JsonDict | None = None,\n        filter: str | None = None,\n        custom_metadata: str | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Edit documents with a function.\n\n        Edit documents is only available in Meilisearch &gt;= v1.10.0, and is experimental in\n        Meilisearch v1.10.0. In order to use this feature you first need to enable it by\n        sending a PATCH request to /experimental-features with { \"editDocumentsByFunction\": true }.\n\n        Args:\n            function: Rhai function to use to update the documents.\n            context: Parameters to use in the function. Defaults to None.\n            filter: Filter the documents before applying the function. Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.edit_documents(\"doc.title = `${doc.title.to_upper()}`\")\n        \"\"\"\n        url = f\"{self._documents_url}/edit\"\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        payload: JsonDict = {\"function\": function}\n\n        if context:\n            payload[\"context\"] = context\n\n        if filter:\n            payload[\"filter\"] = filter\n\n        response = self._http_requests.post(url, payload)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def update_documents(\n        self,\n        documents: Sequence[JsonMapping],\n        primary_key: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Update documents in the index.\n\n        Args:\n            documents: List of documents.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_documents(documents)\n        \"\"\"\n        params = {}\n\n        if primary_key:\n            params[\"primaryKey\"] = primary_key\n        if custom_metadata:\n            params[\"customMetadata\"] = custom_metadata\n        if skip_creation:\n            params[\"skipCreation\"] = \"true\"\n\n        if params:\n            url = build_encoded_url(self._documents_url, params)\n        else:\n            url = self._documents_url\n\n        if self._pre_update_documents_plugins:\n            pre = _run_plugins(\n                self._pre_update_documents_plugins,\n                Event.PRE,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if pre.get(\"document_result\"):\n                documents = pre[\"document_result\"]\n\n        response = self._http_requests.put(url, documents, compress=compress)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_update_documents_plugins:\n            post = _run_plugins(self._post_update_documents_plugins, Event.POST, result=result)\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def update_documents_in_batches(\n        self,\n        documents: Sequence[JsonMapping],\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Update documents in batches to reduce RAM usage with indexing.\n\n        Each batch tries to fill the max_payload_size\n\n        Args:\n            documents: List of documents.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_documents_in_batches(documents)\n        \"\"\"\n        return [\n            self.update_documents(\n                x,\n                primary_key,\n                custom_metadata=custom_metadata,\n                skip_creation=skip_creation,\n                compress=compress,\n            )\n            for x in batch(documents, batch_size)\n        ]\n\n    def update_documents_from_directory(\n        self,\n        directory_path: Path | str,\n        *,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and update the documents.\n\n        Args:\n            directory_path: Path to the directory that contains the json files.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row containing\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_documents_from_directory(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = _load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    all_documents.append(documents)\n\n            raise_on_no_documents(all_documents, document_type, directory_path)\n\n            combined = combine_documents_(all_documents)\n\n            response = self.update_documents(\n                combined,\n                primary_key,\n                custom_metadata=custom_metadata,\n                skip_creation=skip_creation,\n                compress=compress,\n            )\n            return [response]\n\n        responses = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                responses.append(\n                    self.update_documents(\n                        documents,\n                        primary_key,\n                        custom_metadata=custom_metadata,\n                        skip_creation=skip_creation,\n                        compress=compress,\n                    )\n                )\n\n        raise_on_no_documents(responses, document_type, directory_path)\n\n        return responses\n\n    def update_documents_from_directory_in_batches(\n        self,\n        directory_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and update the documents.\n\n        Args:\n            directory_path: Path to the directory that contains the json files.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row\n                containing the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_documents_from_directory_in_batches(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = _load_documents_from_file(\n                        path, csv_delimiter, json_handler=self._json_handler\n                    )\n                    all_documents.append(documents)\n\n            raise_on_no_documents(all_documents, document_type, directory_path)\n\n            combined = combine_documents_(all_documents)\n\n            return self.update_documents_in_batches(\n                combined,\n                batch_size=batch_size,\n                primary_key=primary_key,\n                custom_metadata=custom_metadata,\n                skip_creation=skip_creation,\n                compress=compress,\n            )\n\n        responses: list[TaskInfo] = []\n\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                responses.extend(\n                    self.update_documents_in_batches(\n                        documents,\n                        batch_size=batch_size,\n                        primary_key=primary_key,\n                        custom_metadata=custom_metadata,\n                        skip_creation=skip_creation,\n                        compress=compress,\n                    )\n                )\n\n        raise_on_no_documents(responses, document_type, directory_path)\n\n        return responses\n\n    def update_documents_from_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents in the index from a json file.\n\n        Args:\n            file_path: Path to the json file.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_documents_from_file(file_path)\n        \"\"\"\n        documents = _load_documents_from_file(\n            file_path, csv_delimiter, json_handler=self._json_handler\n        )\n\n        return self.update_documents(\n            documents,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            skip_creation=skip_creation,\n            compress=compress,\n        )\n\n    def update_documents_from_file_in_batches(\n        self,\n        file_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        custom_metadata: str | None = None,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Updates documents form a json file in batches to reduce RAM usage with indexing.\n\n        Args:\n            file_path: Path to the json file.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_documents_from_file_in_batches(file_path)\n        \"\"\"\n        documents = _load_documents_from_file(file_path, json_handler=self._json_handler)\n\n        return self.update_documents_in_batches(\n            documents,\n            batch_size=batch_size,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            skip_creation=skip_creation,\n            compress=compress,\n        )\n\n    def update_documents_from_raw_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        *,\n        custom_metadata: str | None = None,\n        skip_creation: bool = False,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n        The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n        for batching.\n\n        Args:\n            file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n                allowed.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n            skip_creation: When set to true, documents that don't exist in the index are silently\n                ignored rather than created. Default = False.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n                a non-csv file.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_documents_from_raw_file(file_path)\n        \"\"\"\n        upload_path, content_type = prepare_raw_file_upload(file_path, csv_delimiter)\n        parameters = {}\n\n        if primary_key:\n            parameters[\"primaryKey\"] = primary_key\n        if csv_delimiter:\n            parameters[\"csvDelimiter\"] = csv_delimiter\n        if custom_metadata:\n            parameters[\"customMetadata\"] = custom_metadata\n        if skip_creation:\n            parameters[\"skipCreation\"] = \"true\"\n\n        if parameters:\n            url = build_encoded_url(self._documents_url, parameters)\n        else:\n            url = self._documents_url\n\n        with open(upload_path) as f:\n            data = f.read()\n\n        response = self._http_requests.put(\n            url, body=data, content_type=content_type, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def delete_document(self, document_id: str, *, custom_metadata: str | None = None) -&gt; TaskInfo:\n        \"\"\"Delete one document from the index.\n\n        Args:\n            document_id: Unique identifier of the document.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.delete_document(\"1234\")\n        \"\"\"\n        if self._pre_delete_document_plugins:\n            _run_plugins(self._pre_delete_document_plugins, Event.PRE, document_id=document_id)\n\n        url = f\"{self._documents_url}/{document_id}\"\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        response = self._http_requests.delete(url)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_document_plugins:\n            post = _run_plugins(self._post_delete_document_plugins, Event.POST, result=result)\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def delete_documents(self, ids: list[str], *, custom_metadata: str | None = None) -&gt; TaskInfo:\n        \"\"\"Delete multiple documents from the index.\n\n        Args:\n            ids: List of unique identifiers of documents.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            List of update ids to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.delete_documents([\"1234\", \"5678\"])\n        \"\"\"\n        if self._pre_delete_documents_plugins:\n            _run_plugins(self._pre_delete_documents_plugins, Event.PRE, ids=ids)\n\n        url = f\"{self._documents_url}/delete-batch\"\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        response = self._http_requests.post(url, ids)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_documents_plugins:\n            post = _run_plugins(self._post_delete_documents_plugins, Event.POST, result=result)\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def delete_documents_by_filter(\n        self, filter: Filter, *, custom_metadata: str | None = None\n    ) -&gt; TaskInfo:\n        \"\"\"Delete documents from the index by filter.\n\n        Args:\n            filter: The filter value information.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.delete_documents_by_filter(\"genre=horor\"))\n        \"\"\"\n        if self._pre_delete_documents_by_filter_plugins:\n            _run_plugins(self._pre_delete_documents_by_filter_plugins, Event.PRE, filter=filter)\n\n        url = f\"{self._documents_url}/delete\"\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        response = self._http_requests.post(url, body={\"filter\": filter})\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_documents_by_filter_plugins:\n            post = _run_plugins(\n                self._post_delete_documents_by_filter_plugins, Event.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def delete_documents_in_batches_by_filter(\n        self, filters: list[str | list[str | list[str]]], *, custom_metadata: str | None = None\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Delete batches of documents from the index by filter.\n\n        Args:\n            filters: A list of filter value information.\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The a list of details of the task statuses.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.delete_documents_in_batches_by_filter(\n            &gt;&gt;&gt;         [\n            &gt;&gt;&gt;             \"genre=horor\"),\n            &gt;&gt;&gt;             \"release_date=1520035200\"),\n            &gt;&gt;&gt;         ]\n            &gt;&gt;&gt;     )\n        \"\"\"\n        return [\n            self.delete_documents_by_filter(filter, custom_metadata=custom_metadata)\n            for filter in filters\n        ]\n\n    def delete_all_documents(self, *, custom_metadata: str | None = None) -&gt; TaskInfo:\n        \"\"\"Delete all documents from the index.\n\n        Args:\n            custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.delete_all_document()\n        \"\"\"\n        if self._pre_delete_all_documents_plugins:\n            _run_plugins(self._pre_delete_all_documents_plugins, Event.PRE)\n\n        url = self._documents_url\n\n        if custom_metadata:\n            url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n        response = self._http_requests.delete(url)\n        result = TaskInfo(**self._http_requests.parse_json(response))\n        if self._post_delete_all_documents_plugins:\n            post = _run_plugins(self._post_delete_all_documents_plugins, Event.POST, result=result)\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def get_settings(self) -&gt; MeilisearchSettings:\n        \"\"\"Get settings of the index.\n\n        Returns:\n            Settings of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     settings = index.get_settings()\n        \"\"\"\n        response = self._http_requests.get(self._settings_url)\n        response_json = self._http_requests.parse_json(response)\n        settings = MeilisearchSettings(**response_json)\n\n        if response_json.get(\"embedders\"):\n            # Not coverted because it times out. It isn't an issue with the code here.\n            # https://github.com/meilisearch/meilisearch/issues/4585\n            settings.embedders = embedder_json_to_settings_model(  # pragma: no cover\n                response_json[\"embedders\"]\n            )\n\n        return settings\n\n    def update_settings(self, body: MeilisearchSettings, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update settings of the index.\n\n        Args:\n            body: Settings of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n            &gt;&gt;&gt; new_settings = MeilisearchSettings(\n            &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n            &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n            &gt;&gt;&gt;     ranking_rules=[\n            &gt;&gt;&gt;         \"words\",\n            &gt;&gt;&gt;         \"typo\",\n            &gt;&gt;&gt;         \"proximity\",\n            &gt;&gt;&gt;         \"attribute\",\n            &gt;&gt;&gt;         \"sort\",\n            &gt;&gt;&gt;         \"exactness\",\n            &gt;&gt;&gt;         \"release_date:desc\",\n            &gt;&gt;&gt;         \"rank:desc\",\n            &gt;&gt;&gt;    ],\n            &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n            &gt;&gt;&gt;    distinct_attribute=\"url\",\n            &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n            &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n            &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n            &gt;&gt;&gt; )\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_settings(new_settings)\n        \"\"\"\n        body_dict = {\n            k: v\n            for k, v in body.model_dump(by_alias=True, exclude_none=True).items()\n            if v is not None\n        }\n        response = self._http_requests.patch(self._settings_url, body_dict, compress=compress)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_settings(self) -&gt; TaskInfo:\n        \"\"\"Reset settings of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_settings()\n        \"\"\"\n        response = self._http_requests.delete(self._settings_url)\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_ranking_rules(self) -&gt; list[str]:\n        \"\"\"Get ranking rules of the index.\n\n        Returns:\n            List containing the ranking rules of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     ranking_rules = index.get_ranking_rules()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/ranking-rules\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_ranking_rules(self, ranking_rules: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update ranking rules of the index.\n\n        Args:\n            ranking_rules: List containing the ranking rules.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; ranking_rules=[\n            &gt;&gt;&gt;      \"words\",\n            &gt;&gt;&gt;      \"typo\",\n            &gt;&gt;&gt;      \"proximity\",\n            &gt;&gt;&gt;      \"attribute\",\n            &gt;&gt;&gt;      \"sort\",\n            &gt;&gt;&gt;      \"exactness\",\n            &gt;&gt;&gt;      \"release_date:desc\",\n            &gt;&gt;&gt;      \"rank:desc\",\n            &gt;&gt;&gt; ],\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_ranking_rules(ranking_rules)\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/ranking-rules\", ranking_rules, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_ranking_rules(self) -&gt; TaskInfo:\n        \"\"\"Reset ranking rules of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_ranking_rules()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/ranking-rules\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_distinct_attribute(self) -&gt; str | None:\n        \"\"\"Get distinct attribute of the index.\n\n        Returns:\n            String containing the distinct attribute of the index. If no distinct attribute\n                `None` is returned.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     distinct_attribute = index.get_distinct_attribute()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/distinct-attribute\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        return self._http_requests.parse_json(response)\n\n    def update_distinct_attribute(self, body: str, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update distinct attribute of the index.\n\n        Args:\n            body: Distinct attribute.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_distinct_attribute(\"url\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/distinct-attribute\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_distinct_attribute(self) -&gt; TaskInfo:\n        \"\"\"Reset distinct attribute of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_distinct_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/distinct-attribute\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_searchable_attributes(self) -&gt; list[str]:\n        \"\"\"Get searchable attributes of the index.\n\n        Returns:\n            List containing the searchable attributes of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     searchable_attributes = index.get_searchable_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/searchable-attributes\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_searchable_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update searchable attributes of the index.\n\n        Args:\n            body: List containing the searchable attributes.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/searchable-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_searchable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset searchable attributes of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_searchable_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/searchable-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_displayed_attributes(self) -&gt; list[str]:\n        \"\"\"Get displayed attributes of the index.\n\n        Returns:\n            List containing the displayed attributes of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     displayed_attributes = index.get_displayed_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/displayed-attributes\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_displayed_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update displayed attributes of the index.\n\n        Args:\n            body: List containing the displayed attributes.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_displayed_attributes(\n            &gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]\n            &gt;&gt;&gt;     )\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/displayed-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_displayed_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset displayed attributes of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_displayed_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/displayed-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_stop_words(self) -&gt; list[str] | None:\n        \"\"\"Get stop words of the index.\n\n        Returns:\n            List containing the stop words of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     stop_words = index.get_stop_words()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/stop-words\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        return self._http_requests.parse_json(response)\n\n    def update_stop_words(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update stop words of the index.\n\n        Args:\n            body: List containing the stop words of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_stop_words([\"the\", \"a\", \"an\"])\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/stop-words\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_stop_words(self) -&gt; TaskInfo:\n        \"\"\"Reset stop words of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_stop_words()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/stop-words\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_synonyms(self) -&gt; dict[str, list[str]] | None:\n        \"\"\"Get synonyms of the index.\n\n        Returns:\n            The synonyms of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     synonyms = index.get_synonyms()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/synonyms\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        return self._http_requests.parse_json(response)\n\n    def update_synonyms(self, body: dict[str, list[str]], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update synonyms of the index.\n\n        Args:\n            body: The synonyms of the index.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_synonyms(\n            &gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n            &gt;&gt;&gt;     )\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/synonyms\", body, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_synonyms(self) -&gt; TaskInfo:\n        \"\"\"Reset synonyms of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_synonyms()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/synonyms\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_filterable_attributes(self) -&gt; list[str | FilterableAttributes] | None:\n        \"\"\"Get filterable attributes of the index.\n\n        Returns:\n            List containing the filterable attributes of the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     filterable_attributes = index.get_filterable_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/filterable-attributes\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        response_json = self._http_requests.parse_json(response)\n\n        filterable_attributes: list[str | FilterableAttributes] = []\n        for r in response_json:\n            if isinstance(r, str):\n                filterable_attributes.append(r)\n            else:\n                filterable_attributes.append(\n                    FilterableAttributes(\n                        attribute_patterns=r[\"attributePatterns\"],\n                        features=FilterableAttributeFeatures(**r[\"features\"]),\n                    )\n                )\n\n        return filterable_attributes\n\n    def update_filterable_attributes(\n        self, body: list[str | FilterableAttributes], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update filterable attributes of the index.\n\n        Args:\n            body: List containing the filterable attributes of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_filterable_attributes([\"genre\", \"director\"])\n        \"\"\"\n        payload: list[str | JsonDict] = []\n\n        for b in body:\n            if isinstance(b, FilterableAttributes):\n                payload.append(b.model_dump(by_alias=True))\n            else:\n                payload.append(b)\n\n        response = self._http_requests.put(\n            f\"{self._settings_url}/filterable-attributes\", payload, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_filterable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset filterable attributes of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_filterable_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/filterable-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_sortable_attributes(self) -&gt; list[str]:\n        \"\"\"Get sortable attributes of the AsyncIndex.\n\n        Returns:\n            List containing the sortable attributes of the AsyncIndex.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     sortable_attributes = index.get_sortable_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/sortable-attributes\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_sortable_attributes(\n        self, sortable_attributes: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Get sortable attributes of the AsyncIndex.\n\n        Args:\n            sortable_attributes: List of attributes for searching.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_sortable_attributes([\"title\", \"release_date\"])\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/sortable-attributes\", sortable_attributes, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_sortable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset sortable attributes of the index to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_sortable_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/sortable-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_typo_tolerance(self) -&gt; TypoTolerance:\n        \"\"\"Get typo tolerance for the index.\n\n        Returns:\n            TypoTolerance for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     sortable_attributes = index.get_typo_tolerance()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/typo-tolerance\")\n\n        return TypoTolerance(**self._http_requests.parse_json(response))\n\n    def update_typo_tolerance(\n        self, typo_tolerance: TypoTolerance, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update typo tolerance.\n\n        Args:\n            typo_tolerance: Typo tolerance settings.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     TypoTolerance(enabled=False)\n            &gt;&gt;&gt;     index.update_typo_tolerance()\n        \"\"\"\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/typo-tolerance\",\n            typo_tolerance.model_dump(by_alias=True, exclude_unset=True),\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_typo_tolerance(self) -&gt; TaskInfo:\n        \"\"\"Reset typo tolerance to default values.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_typo_tolerance()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/typo-tolerance\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_faceting(self) -&gt; Faceting:\n        \"\"\"Get faceting for the index.\n\n        Returns:\n            Faceting for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     faceting = index.get_faceting()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/faceting\")\n\n        return Faceting(**self._http_requests.parse_json(response))\n\n    def update_faceting(self, faceting: Faceting, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Partially update the faceting settings for an index.\n\n        Args:\n            faceting: Faceting values.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n        \"\"\"\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/faceting\",\n            faceting.model_dump(by_alias=True),\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_faceting(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's faceting settings to their default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_faceting()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/faceting\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_pagination(self) -&gt; Pagination:\n        \"\"\"Get pagination settings for the index.\n\n        Returns:\n            Pagination for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     pagination_settings = index.get_pagination()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/pagination\")\n\n        return Pagination(**self._http_requests.parse_json(response))\n\n    def update_pagination(self, settings: Pagination, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Partially update the pagination settings for an index.\n\n        Args:\n            settings: settings for pagination.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_pagination(settings=Pagination(max_total_hits=123))\n        \"\"\"\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/pagination\",\n            settings.model_dump(by_alias=True),\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_pagination(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's pagination settings to their default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_pagination()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/pagination\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_separator_tokens(self) -&gt; list[str]:\n        \"\"\"Get separator token settings for the index.\n\n        Returns:\n            Separator tokens for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     separator_token_settings = index.get_separator_tokens()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/separator-tokens\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_separator_tokens(\n        self, separator_tokens: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the separator tokens settings for an index.\n\n        Args:\n            separator_tokens: List of separator tokens.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/separator-tokens\", separator_tokens, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_separator_tokens(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's separator tokens settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_separator_tokens()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/separator-tokens\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_non_separator_tokens(self) -&gt; list[str]:\n        \"\"\"Get non-separator token settings for the index.\n\n        Returns:\n            Non-separator tokens for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     non_separator_token_settings = index.get_non_separator_tokens()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/non-separator-tokens\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_non_separator_tokens(\n        self, non_separator_tokens: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the non-separator tokens settings for an index.\n\n        Args:\n            non_separator_tokens: List of non-separator tokens.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/non-separator-tokens\", non_separator_tokens, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_non_separator_tokens(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's non-separator tokens settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_non_separator_tokens()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/non-separator-tokens\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_search_cutoff_ms(self) -&gt; int | None:\n        \"\"\"Get search cutoff time in ms.\n\n        Returns:\n            Integer representing the search cutoff time in ms, or None.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_cutoff_ms_settings = index.get_search_cutoff_ms()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/search-cutoff-ms\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_search_cutoff_ms(self, search_cutoff_ms: int, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update the search cutoff for an index.\n\n        Args:\n            search_cutoff_ms: Integer value of the search cutoff time in ms.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_search_cutoff_ms(100)\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/search-cutoff-ms\", search_cutoff_ms, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_search_cutoff_ms(self) -&gt; TaskInfo:\n        \"\"\"Reset the search cutoff time to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_search_cutoff_ms()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/search-cutoff-ms\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_word_dictionary(self) -&gt; list[str]:\n        \"\"\"Get word dictionary settings for the index.\n\n        Returns:\n            Word dictionary for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     word_dictionary = index.get_word_dictionary()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/dictionary\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_word_dictionary(self, dictionary: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update the word dictionary settings for an index.\n\n        Args:\n            dictionary: List of dictionary values.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/dictionary\", dictionary, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_word_dictionary(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's word dictionary settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_word_dictionary()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/dictionary\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_proximity_precision(self) -&gt; ProximityPrecision:\n        \"\"\"Get proximity precision settings for the index.\n\n        Returns:\n            Proximity precision for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     proximity_precision = index.get_proximity_precision()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/proximity-precision\")\n\n        return ProximityPrecision[to_snake(self._http_requests.parse_json(response)).upper()]\n\n    def update_proximity_precision(\n        self, proximity_precision: ProximityPrecision, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the proximity precision settings for an index.\n\n        Args:\n            proximity_precision: The proximity precision value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/proximity-precision\",\n            proximity_precision.value,\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_proximity_precision(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's proximity precision settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_proximity_precision()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/proximity-precision\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_embedders(self) -&gt; Embedders | None:\n        \"\"\"Get embedder settings for the index.\n\n        Returns:\n            Embedders for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     embedders = await index.get_embedders()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/embedders\")\n\n        return embedder_json_to_embedders_model(self._http_requests.parse_json(response))\n\n    def update_embedders(self, embedders: Embedders, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update the embedders settings for an index.\n\n        Args:\n            embedders: The embedders value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_embedders(\n            &gt;&gt;&gt;         Embedders(embedders={dimensions=512)})\n            &gt;&gt;&gt;     )\n        \"\"\"\n        payload = {}\n        for key, embedder in embedders.embedders.items():\n            payload[key] = {\n                k: v\n                for k, v in embedder.model_dump(by_alias=True, exclude_none=True).items()\n                if v is not None\n            }\n\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/embedders\", payload, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    # Not coverted because it times out. It isn't an issue with the code here.\n    # https://github.com/meilisearch/meilisearch/issues/4585\n    def reset_embedders(self) -&gt; TaskInfo:  # pragma: no cover\n        \"\"\"Reset an index's embedders settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_embedders()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/embedders\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_localized_attributes(self) -&gt; list[LocalizedAttributes] | None:\n        \"\"\"Get localized attributes settings for the index.\n\n        Returns:\n            Localized attributes for the index.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     localized_attributes = await index.get_localized_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/localized-attributes\")\n\n        if not self._http_requests.parse_json(response):\n            return None\n\n        return [LocalizedAttributes(**x) for x in self._http_requests.parse_json(response)]\n\n    def update_localized_attributes(\n        self, localized_attributes: list[LocalizedAttributes], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the localized attributes settings for an index.\n\n        Args:\n            localized_attributes: The localized attributes value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            Task to track the action.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import LocalizedAttributes\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_localized_attributes([\n            &gt;&gt;&gt;         LocalizedAttributes(locales=[\"eng\", \"spa\"], attribute_patterns=[\"*\"]),\n            &gt;&gt;&gt;         LocalizedAttributes(locales=[\"ita\"], attribute_patterns=[\"*_it\"]),\n            &gt;&gt;&gt;     ])\n        \"\"\"\n        payload = [x.model_dump(by_alias=True) for x in localized_attributes]\n        response = self._http_requests.put(\n            f\"{self._settings_url}/localized-attributes\", payload, compress=compress\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_localized_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's localized attributes settings to the default value.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_localized_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/localized-attributes\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_facet_search(self) -&gt; bool:\n        \"\"\"Get setting for facet search opt-out.\n\n        Returns:\n            True if facet search is enabled or False if not.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     facet_search = await index.get_facet_search()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/facet-search\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_facet_search(self, facet_search: bool, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update setting for facet search opt-out.\n\n        Args:\n            facet_search: Boolean indicating if facet search should be disabled.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_facet_search(True)\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/facet-search\",\n            facet_search,\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_facet_search(self) -&gt; TaskInfo:\n        \"\"\"Reset the facet search opt-out settings.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_facet_search()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/facet-search\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def get_prefix_search(self) -&gt; bool:\n        \"\"\"Get setting for prefix search opt-out.\n\n        Returns:\n            True if prefix search is enabled or False if not.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     prefix_search = index.get_prefix_search()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/prefix-search\")\n\n        return self._http_requests.parse_json(response)\n\n    def update_prefix_search(\n        self,\n        prefix_search: Literal[\"disabled\", \"indexingTime\", \"searchTime\"],\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Update setting for prefix search opt-out.\n\n        Args:\n            prefix_search: Value indicating prefix search setting.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.update_prefix_search(\"disabled\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/prefix-search\",\n            prefix_search,\n            compress=compress,\n        )\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def reset_prefix_search(self) -&gt; TaskInfo:\n        \"\"\"Reset the prefix search opt-out settings.\n\n        Returns:\n            The details of the task status.\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.reset_prefix_search()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/prefix-search\")\n\n        return TaskInfo(**self._http_requests.parse_json(response))\n\n    def fields(\n        self, offset: int = 0, limit: int = 20, filter: FieldsFilter | None = None\n    ) -&gt; FieldResults:\n        \"\"\"Get the field properties on an index.\n\n        Args:\n            offset: Number of fields to skip. Defaults to 0.\n            limit: Maximum number of fields returned. Defaults to 20.\n            filter: Filter fields to return based on properties. Defaults to None.\n\n        Returns:\n            Field properties\n\n        Raises:\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     docs = [{\"id\": 1, \"title\": \"Some Title}]\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index.add_documents(docs)\n            &gt;&gt;&gt;     fields = index.fields()\n        \"\"\"\n        filter_value = filter.model_dump(by_alias=True) if filter else None\n        response = self._http_requests.post(\n            f\"{self._base_url_with_uid}/fields\",\n            body={\"offset\": offset, \"limit\": limit, \"filter\": filter_value},\n        )\n        response_json = response.json()\n        fields = [Field(**field) for field in response_json[\"results\"]]\n\n        return FieldResults(\n            fields=fields,\n            offset=response_json[\"offset\"],\n            limit=response_json[\"limit\"],\n            total=response_json[\"total\"],\n        )\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.__init__","title":"<code>__init__(http_client, uid, primary_key=None, created_at=None, updated_at=None, plugins=None, json_handler=None, *, hits_type=JsonDict)</code>","text":"<p>Class initializer.</p> <p>Parameters:</p> Name Type Description Default <code>http_client</code> <code>Client</code> <p>An instance of the Client. This automatically gets passed by the Client when creating and Index instance.</p> required <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. Defaults to None.</p> <code>None</code> <code>created_at</code> <code>str | datetime | None</code> <p>The date and time the index was created. Defaults to None.</p> <code>None</code> <code>updated_at</code> <code>str | datetime | None</code> <p>The date and time the index was last updated. Defaults to None.</p> <code>None</code> <code>plugins</code> <code>IndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <code>json_handler</code> <code>BuiltinHandler | OrjsonHandler | None</code> <p>The module to use for json operations. The options are BuiltinHandler (uses the json module from the standard library), or OrjsonHandler (uses orjson). Note that in order use orjson the corresponding extra needs to be included. Default: BuiltinHandler.</p> <code>None</code> <code>hits_type</code> <code>type[Any]</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def __init__(\n    self,\n    http_client: Client,\n    uid: str,\n    primary_key: str | None = None,\n    created_at: str | datetime | None = None,\n    updated_at: str | datetime | None = None,\n    plugins: IndexPlugins | None = None,\n    json_handler: BuiltinHandler | OrjsonHandler | None = None,\n    *,\n    hits_type: type[Any] = JsonDict,\n) -&gt; None:\n    \"\"\"Class initializer.\n\n    Args:\n        http_client: An instance of the Client. This automatically gets passed by the\n            Client when creating and Index instance.\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        created_at: The date and time the index was created. Defaults to None.\n        updated_at: The date and time the index was last updated. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n        json_handler: The module to use for json operations. The options are BuiltinHandler\n            (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n            Note that in order use orjson the corresponding extra needs to be included.\n            Default: BuiltinHandler.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n    \"\"\"\n    super().__init__(\n        uid=uid,\n        primary_key=primary_key,\n        created_at=created_at,\n        updated_at=updated_at,\n        json_handler=json_handler,\n        hits_type=hits_type,\n    )\n    self.http_client = http_client\n    self._http_requests = HttpRequests(http_client, json_handler=self._json_handler)\n    self.plugins = plugins\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents","title":"<code>add_documents(documents, primary_key=None, *, custom_metadata=None, compress=False)</code>","text":"<p>Add documents to the index.</p> <p>Parameters:</p> Name Type Description Default <code>documents</code> <code>Sequence[JsonMapping]</code> <p>List of documents.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.add_documents(documents)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def add_documents(\n    self,\n    documents: Sequence[JsonMapping],\n    primary_key: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents to the index.\n\n    Args:\n        documents: List of documents.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.add_documents(documents)\n    \"\"\"\n    params = {}\n\n    if primary_key:\n        params[\"primaryKey\"] = primary_key\n    if custom_metadata:\n        params[\"customMetadata\"] = custom_metadata\n\n    if params:\n        url = build_encoded_url(self._documents_url, params)\n    else:\n        url = self._documents_url\n\n    if self._pre_add_documents_plugins:\n        pre = _run_plugins(\n            self._pre_add_documents_plugins,\n            Event.PRE,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if pre.get(\"document_result\"):\n            documents = pre[\"document_result\"]\n\n    response = self._http_requests.post(url, documents, compress=compress)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_add_documents_plugins:\n        post = _run_plugins(self._post_add_documents_plugins, Event.POST, result=result)\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_directory","title":"<code>add_documents_from_directory(directory_path, *, primary_key=None, custom_metadata=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>","text":"<p>Load all json files from a directory and add the documents to the index.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | str</code> <p>Path to the directory that contains the json files.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>document_type</code> <code>str</code> <p>The type of document being added. Accepted types are json, csv, and ndjson. For csv files the first row of the document should be a header row containing the field names, and ever for should have a title.</p> <code>'json'</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>combine_documents</code> <code>bool</code> <p>If set to True this will combine the documents from all the files before indexing them. Defaults to True.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.add_documents_from_directory(directory_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def add_documents_from_directory(\n    self,\n    directory_path: Path | str,\n    *,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and add the documents to the index.\n\n    Args:\n        directory_path: Path to the directory that contains the json files.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row containing\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.add_documents_from_directory(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                all_documents.append(documents)\n\n        raise_on_no_documents(all_documents, document_type, directory_path)\n\n        combined = combine_documents_(all_documents)\n\n        response = self.add_documents(\n            combined, primary_key, custom_metadata=custom_metadata, compress=compress\n        )\n\n        return [response]\n\n    responses = []\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = _load_documents_from_file(\n                path, csv_delimiter, json_handler=self._json_handler\n            )\n            responses.append(\n                self.add_documents(\n                    documents, primary_key, custom_metadata=custom_metadata, compress=compress\n                )\n            )\n\n    raise_on_no_documents(responses, document_type, directory_path)\n\n    return responses\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_directory_in_batches","title":"<code>add_documents_from_directory_in_batches(directory_path, *, batch_size=1000, primary_key=None, custom_metadata=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>","text":"<p>Load all json files from a directory and add the documents to the index in batches.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | str</code> <p>Path to the directory that contains the json files.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>document_type</code> <code>str</code> <p>The type of document being added. Accepted types are json, csv, and ndjson. For csv files the first row of the document should be a header row containing the field names, and ever for should have a title.</p> <code>'json'</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>combine_documents</code> <code>bool</code> <p>If set to True this will combine the documents from all the files before indexing them. Defaults to True.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.add_documents_from_directory_in_batches(directory_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def add_documents_from_directory_in_batches(\n    self,\n    directory_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and add the documents to the index in batches.\n\n    Args:\n        directory_path: Path to the directory that contains the json files.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row containing\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.add_documents_from_directory_in_batches(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(\n                    path, csv_delimiter=csv_delimiter, json_handler=self._json_handler\n                )\n                all_documents.append(documents)\n\n        raise_on_no_documents(all_documents, document_type, directory_path)\n\n        combined = combine_documents_(all_documents)\n\n        return self.add_documents_in_batches(\n            combined,\n            batch_size=batch_size,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            compress=compress,\n        )\n\n    responses: list[TaskInfo] = []\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = _load_documents_from_file(\n                path, csv_delimiter, json_handler=self._json_handler\n            )\n            responses.extend(\n                self.add_documents_in_batches(\n                    documents,\n                    batch_size=batch_size,\n                    primary_key=primary_key,\n                    custom_metadata=custom_metadata,\n                    compress=compress,\n                )\n            )\n\n    raise_on_no_documents(responses, document_type, directory_path)\n\n    return responses\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_file","title":"<code>add_documents_from_file(file_path, primary_key=None, *, custom_metadata=None, compress=False)</code>","text":"<p>Add documents to the index from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the json file.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.add_documents_from_file(file_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def add_documents_from_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents to the index from a json file.\n\n    Args:\n        file_path: Path to the json file.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.add_documents_from_file(file_path)\n    \"\"\"\n    documents = _load_documents_from_file(file_path, json_handler=self._json_handler)\n\n    return self.add_documents(\n        documents, primary_key=primary_key, custom_metadata=custom_metadata, compress=compress\n    )\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_file_in_batches","title":"<code>add_documents_from_file_in_batches(file_path, *, batch_size=1000, primary_key=None, custom_metadata=None, csv_delimiter=None, compress=False)</code>","text":"<p>Adds documents form a json file in batches to reduce RAM usage with indexing.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the json file.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.add_documents_from_file_in_batches(file_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def add_documents_from_file_in_batches(\n    self,\n    file_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    csv_delimiter: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Adds documents form a json file in batches to reduce RAM usage with indexing.\n\n    Args:\n        file_path: Path to the json file.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.add_documents_from_file_in_batches(file_path)\n    \"\"\"\n    documents = _load_documents_from_file(\n        file_path, csv_delimiter, json_handler=self._json_handler\n    )\n\n    return self.add_documents_in_batches(\n        documents,\n        batch_size=batch_size,\n        primary_key=primary_key,\n        custom_metadata=custom_metadata,\n        compress=compress,\n    )\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_raw_file","title":"<code>add_documents_from_raw_file(file_path, primary_key=None, *, custom_metadata=None, csv_delimiter=None, compress=False)</code>","text":"<p>Directly send csv or ndjson files to Meilisearch without pre-processing.</p> <p>The can reduce RAM usage from Meilisearch during indexing, but does not include the option for batching.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>The path to the file to send to Meilisearch. Only csv and ndjson files are allowed.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is not a csv or ndjson file, or if a csv_delimiter is sent for a non-csv file.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.add_documents_from_raw_file(file_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def add_documents_from_raw_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    csv_delimiter: str | None = None,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n    The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n    for batching.\n\n    Args:\n        file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n            allowed.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n            a non-csv file.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.add_documents_from_raw_file(file_path)\n    \"\"\"\n    upload_path, content_type = prepare_raw_file_upload(file_path, csv_delimiter)\n    parameters = {}\n\n    if primary_key:\n        parameters[\"primaryKey\"] = primary_key\n    if csv_delimiter:\n        parameters[\"csvDelimiter\"] = csv_delimiter\n    if custom_metadata:\n        parameters[\"customMetadata\"] = custom_metadata\n\n    if parameters:\n        url = build_encoded_url(self._documents_url, parameters)\n    else:\n        url = self._documents_url\n\n    with open(upload_path) as f:\n        data = f.read()\n\n    response = self._http_requests.post(\n        url, body=data, content_type=content_type, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_in_batches","title":"<code>add_documents_in_batches(documents, *, batch_size=1000, primary_key=None, custom_metadata=None, compress=False)</code>","text":"<p>Adds documents in batches to reduce RAM usage with indexing.</p> <p>Parameters:</p> Name Type Description Default <code>documents</code> <code>Sequence[JsonMapping]</code> <p>List of documents.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.add_documents_in_batches(documents)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def add_documents_in_batches(\n    self,\n    documents: Sequence[JsonMapping],\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Adds documents in batches to reduce RAM usage with indexing.\n\n    Args:\n        documents: List of documents.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.add_documents_in_batches(documents)\n    \"\"\"\n    return [\n        self.add_documents(x, primary_key, custom_metadata=custom_metadata, compress=compress)\n        for x in batch(documents, batch_size)\n    ]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.compact","title":"<code>compact()</code>","text":"<p>Appends a new task to the queue to compact the database.</p> <p>This defragments the LMDB database potentially speeds up indexing and searching. NOTE: This is only available in Meilisearch v1.23.0+</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.compact()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def compact(self) -&gt; TaskInfo:\n    \"\"\"Appends a new task to the queue to compact the database.\n\n    This defragments the LMDB database potentially speeds up indexing and searching.\n    NOTE: This is only available in Meilisearch v1.23.0+\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.compact()\n    \"\"\"\n    response = self._http_requests.post(f\"{self._base_url_with_uid}/compact\")\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.create","title":"<code>create(http_client, uid, primary_key=None, *, settings=None, wait=True, timeout_in_ms=None, plugins=None, json_handler=None, hits_type=JsonDict)</code>  <code>classmethod</code>","text":"<p>Creates a new index.</p> <p>In general this method should not be used directly and instead the index should be created through the <code>Client</code>.</p> <p>Parameters:</p> Name Type Description Default <code>http_client</code> <code>Client</code> <p>An instance of the Client. This automatically gets passed by the Client when creating an Index instance.</p> required <code>uid</code> <code>str</code> <p>The index's unique identifier.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. Defaults to None.</p> <code>None</code> <code>settings</code> <code>MeilisearchSettings | None</code> <p>Settings for the index. The settings can also be updated independently of creating the index. The advantage to updating them here is updating the settings after adding documents will cause the documents to be re-indexed. Because of this it will be faster to update them before adding documents. Defaults to None (i.e. default Meilisearch index settings).</p> <code>None</code> <code>wait</code> <code>bool</code> <p>If set to True and settings are being updated, the index will be returned after the settings update has completed. If False it will not wait for settings to complete. Default: True</p> <code>True</code> <code>timeout_in_ms</code> <code>int | None</code> <p>Amount of time in milliseconds to wait before raising a MeilisearchTimeoutError. <code>None</code> can also be passed to wait indefinitely. Be aware that if the <code>None</code> option is used the wait time could be very long. Defaults to None.</p> <code>None</code> <code>plugins</code> <code>IndexPlugins | None</code> <p>Optional plugins can be provided to extend functionality.</p> <code>None</code> <code>json_handler</code> <code>BuiltinHandler | OrjsonHandler | None</code> <p>The module to use for json operations. The options are BuiltinHandler (uses the json module from the standard library), or OrjsonHandler (uses orjson). Note that in order use orjson the corresponding extra needs to be included. Default: BuiltinHandler.</p> <code>None</code> <code>hits_type</code> <code>type[Any]</code> <p>Allows for a custom type to be passed to use for hits. Defaults to JsonDict</p> <code>JsonDict</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of Index containing the information of the newly created index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = index.create(client, \"movies\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    http_client: Client,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    settings: MeilisearchSettings | None = None,\n    wait: bool = True,\n    timeout_in_ms: int | None = None,\n    plugins: IndexPlugins | None = None,\n    json_handler: BuiltinHandler | OrjsonHandler | None = None,\n    hits_type: type[Any] = JsonDict,\n) -&gt; Self:\n    \"\"\"Creates a new index.\n\n    In general this method should not be used directly and instead the index should be created\n    through the `Client`.\n\n    Args:\n        http_client: An instance of the Client. This automatically gets passed by the Client\n            when creating an Index instance.\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        settings: Settings for the index. The settings can also be updated independently of\n            creating the index. The advantage to updating them here is updating the settings after\n            adding documents will cause the documents to be re-indexed. Because of this it will be\n            faster to update them before adding documents. Defaults to None (i.e. default\n            Meilisearch index settings).\n        wait: If set to True and settings are being updated, the index will be returned after\n            the settings update has completed. If False it will not wait for settings to complete.\n            Default: True\n        timeout_in_ms: Amount of time in milliseconds to wait before raising a\n            MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n            if the `None` option is used the wait time could be very long. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n        json_handler: The module to use for json operations. The options are BuiltinHandler\n            (uses the json module from the standard library), or OrjsonHandler (uses orjson).\n            Note that in order use orjson the corresponding extra needs to be included.\n            Default: BuiltinHandler.\n        hits_type: Allows for a custom type to be passed to use for hits. Defaults to\n            JsonDict\n\n    Returns:\n        An instance of Index containing the information of the newly created index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = index.create(client, \"movies\")\n    \"\"\"\n    if not primary_key:\n        payload = {\"uid\": uid}\n    else:\n        payload = {\"primaryKey\": primary_key, \"uid\": uid}\n\n    url = \"indexes\"\n    handler = json_handler if json_handler else BuiltinHandler()\n    http_request = HttpRequests(http_client, handler)\n    response = http_request.post(url, payload)\n    wait_for_task(\n        http_client, http_request.parse_json(response)[\"taskUid\"], timeout_in_ms=timeout_in_ms\n    )\n    index_response = http_request.get(f\"{url}/{uid}\")\n    index_dict = http_request.parse_json(index_response)\n    index = cls(\n        http_client=http_client,\n        uid=index_dict[\"uid\"],\n        primary_key=index_dict[\"primaryKey\"],\n        created_at=index_dict[\"createdAt\"],\n        updated_at=index_dict[\"updatedAt\"],\n        plugins=plugins,\n        json_handler=json_handler,\n        hits_type=hits_type,\n    )\n\n    if settings:\n        settings_task = index.update_settings(settings)\n        if wait:\n            wait_for_task(http_client, settings_task.task_uid, timeout_in_ms=timeout_in_ms)\n\n    return index\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete","title":"<code>delete()</code>","text":"<p>Deletes the index.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.delete()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def delete(self) -&gt; TaskInfo:\n    \"\"\"Deletes the index.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.delete()\n    \"\"\"\n    response = self._http_requests.delete(self._base_url_with_uid)\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_all_documents","title":"<code>delete_all_documents(*, custom_metadata=None)</code>","text":"<p>Delete all documents from the index.</p> <p>Parameters:</p> Name Type Description Default <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.delete_all_document()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def delete_all_documents(self, *, custom_metadata: str | None = None) -&gt; TaskInfo:\n    \"\"\"Delete all documents from the index.\n\n    Args:\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.delete_all_document()\n    \"\"\"\n    if self._pre_delete_all_documents_plugins:\n        _run_plugins(self._pre_delete_all_documents_plugins, Event.PRE)\n\n    url = self._documents_url\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    response = self._http_requests.delete(url)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_delete_all_documents_plugins:\n        post = _run_plugins(self._post_delete_all_documents_plugins, Event.POST, result=result)\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_document","title":"<code>delete_document(document_id, *, custom_metadata=None)</code>","text":"<p>Delete one document from the index.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>Unique identifier of the document.</p> required <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.delete_document(\"1234\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def delete_document(self, document_id: str, *, custom_metadata: str | None = None) -&gt; TaskInfo:\n    \"\"\"Delete one document from the index.\n\n    Args:\n        document_id: Unique identifier of the document.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.delete_document(\"1234\")\n    \"\"\"\n    if self._pre_delete_document_plugins:\n        _run_plugins(self._pre_delete_document_plugins, Event.PRE, document_id=document_id)\n\n    url = f\"{self._documents_url}/{document_id}\"\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    response = self._http_requests.delete(url)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_delete_document_plugins:\n        post = _run_plugins(self._post_delete_document_plugins, Event.POST, result=result)\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_documents","title":"<code>delete_documents(ids, *, custom_metadata=None)</code>","text":"<p>Delete multiple documents from the index.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of unique identifiers of documents.</p> required <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.delete_documents([\"1234\", \"5678\"])</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def delete_documents(self, ids: list[str], *, custom_metadata: str | None = None) -&gt; TaskInfo:\n    \"\"\"Delete multiple documents from the index.\n\n    Args:\n        ids: List of unique identifiers of documents.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.delete_documents([\"1234\", \"5678\"])\n    \"\"\"\n    if self._pre_delete_documents_plugins:\n        _run_plugins(self._pre_delete_documents_plugins, Event.PRE, ids=ids)\n\n    url = f\"{self._documents_url}/delete-batch\"\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    response = self._http_requests.post(url, ids)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_delete_documents_plugins:\n        post = _run_plugins(self._post_delete_documents_plugins, Event.POST, result=result)\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_documents_by_filter","title":"<code>delete_documents_by_filter(filter, *, custom_metadata=None)</code>","text":"<p>Delete documents from the index by filter.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Filter</code> <p>The filter value information.</p> required <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.delete_documents_by_filter(\"genre=horor\"))</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def delete_documents_by_filter(\n    self, filter: Filter, *, custom_metadata: str | None = None\n) -&gt; TaskInfo:\n    \"\"\"Delete documents from the index by filter.\n\n    Args:\n        filter: The filter value information.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.delete_documents_by_filter(\"genre=horor\"))\n    \"\"\"\n    if self._pre_delete_documents_by_filter_plugins:\n        _run_plugins(self._pre_delete_documents_by_filter_plugins, Event.PRE, filter=filter)\n\n    url = f\"{self._documents_url}/delete\"\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    response = self._http_requests.post(url, body={\"filter\": filter})\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_delete_documents_by_filter_plugins:\n        post = _run_plugins(\n            self._post_delete_documents_by_filter_plugins, Event.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_documents_in_batches_by_filter","title":"<code>delete_documents_in_batches_by_filter(filters, *, custom_metadata=None)</code>","text":"<p>Delete batches of documents from the index by filter.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>list[str | list[str | list[str]]]</code> <p>A list of filter value information.</p> required <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>The a list of details of the task statuses.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.delete_documents_in_batches_by_filter(     &gt;&gt;&gt;         [     &gt;&gt;&gt;             \"genre=horor\"),     &gt;&gt;&gt;             \"release_date=1520035200\"),     &gt;&gt;&gt;         ]     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def delete_documents_in_batches_by_filter(\n    self, filters: list[str | list[str | list[str]]], *, custom_metadata: str | None = None\n) -&gt; list[TaskInfo]:\n    \"\"\"Delete batches of documents from the index by filter.\n\n    Args:\n        filters: A list of filter value information.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The a list of details of the task statuses.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.delete_documents_in_batches_by_filter(\n        &gt;&gt;&gt;         [\n        &gt;&gt;&gt;             \"genre=horor\"),\n        &gt;&gt;&gt;             \"release_date=1520035200\"),\n        &gt;&gt;&gt;         ]\n        &gt;&gt;&gt;     )\n    \"\"\"\n    return [\n        self.delete_documents_by_filter(filter, custom_metadata=custom_metadata)\n        for filter in filters\n    ]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_if_exists","title":"<code>delete_if_exists()</code>","text":"<p>Delete the index if it already exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the index was deleted or False if not.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.delete_if_exists()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def delete_if_exists(self) -&gt; bool:\n    \"\"\"Delete the index if it already exists.\n\n    Returns:\n        True if the index was deleted or False if not.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.delete_if_exists()\n    \"\"\"\n    response = self.delete()\n    status = wait_for_task(self.http_client, response.task_uid, timeout_in_ms=100000)\n    if status.status == \"succeeded\":\n        return True\n\n    return False\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.edit_documents","title":"<code>edit_documents(function, *, context=None, filter=None, custom_metadata=None)</code>","text":"<p>Edit documents with a function.</p> <p>Edit documents is only available in Meilisearch &gt;= v1.10.0, and is experimental in Meilisearch v1.10.0. In order to use this feature you first need to enable it by sending a PATCH request to /experimental-features with { \"editDocumentsByFunction\": true }.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Rhai function to use to update the documents.</p> required <code>context</code> <code>JsonDict | None</code> <p>Parameters to use in the function. Defaults to None.</p> <code>None</code> <code>filter</code> <code>str | None</code> <p>Filter the documents before applying the function. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.edit_documents(\"doc.title = <code>${doc.title.to_upper()}</code>\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def edit_documents(\n    self,\n    function: str,\n    *,\n    context: JsonDict | None = None,\n    filter: str | None = None,\n    custom_metadata: str | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Edit documents with a function.\n\n    Edit documents is only available in Meilisearch &gt;= v1.10.0, and is experimental in\n    Meilisearch v1.10.0. In order to use this feature you first need to enable it by\n    sending a PATCH request to /experimental-features with { \"editDocumentsByFunction\": true }.\n\n    Args:\n        function: Rhai function to use to update the documents.\n        context: Parameters to use in the function. Defaults to None.\n        filter: Filter the documents before applying the function. Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.edit_documents(\"doc.title = `${doc.title.to_upper()}`\")\n    \"\"\"\n    url = f\"{self._documents_url}/edit\"\n\n    if custom_metadata:\n        url = build_encoded_url(url, {\"customMetadata\": custom_metadata})\n\n    payload: JsonDict = {\"function\": function}\n\n    if context:\n        payload[\"context\"] = context\n\n    if filter:\n        payload[\"filter\"] = filter\n\n    response = self._http_requests.post(url, payload)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.facet_search","title":"<code>facet_search(query=None, *, facet_name, facet_query, offset=0, limit=20, filter=None, facets=None, attributes_to_retrieve=None, attributes_to_crop=None, crop_length=200, attributes_to_highlight=None, sort=None, show_matches_position=False, highlight_pre_tag='&lt;em&gt;', highlight_post_tag='&lt;/em&gt;', crop_marker='...', matching_strategy='last', hits_per_page=None, page=None, attributes_to_search_on=None, show_ranking_score=False, show_ranking_score_details=False, ranking_score_threshold=None, vector=None, locales=None, retrieve_vectors=None, exhaustive_facet_count=None)</code>","text":"<p>Search the index.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>String containing the word(s) to search</p> <code>None</code> <code>facet_name</code> <code>str</code> <p>The name of the facet to search</p> required <code>facet_query</code> <code>str</code> <p>The facet search value</p> required <code>offset</code> <code>int</code> <p>Number of documents to skip. Defaults to 0.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of documents returned. Defaults to 20.</p> <code>20</code> <code>filter</code> <code>Filter | None</code> <p>Filter queries by an attribute value. Defaults to None.</p> <code>None</code> <code>facets</code> <code>list[str] | None</code> <p>Facets for which to retrieve the matching count. Defaults to None.</p> <code>None</code> <code>attributes_to_retrieve</code> <code>list[str] | None</code> <p>Attributes to display in the returned documents. Defaults to [\"*\"].</p> <code>None</code> <code>attributes_to_crop</code> <code>list[str] | None</code> <p>Attributes whose values have to be cropped. Defaults to None.</p> <code>None</code> <code>crop_length</code> <code>int</code> <p>The maximum number of words to display. Defaults to 200.</p> <code>200</code> <code>attributes_to_highlight</code> <code>list[str] | None</code> <p>Attributes whose values will contain highlighted matching terms. Defaults to None.</p> <code>None</code> <code>sort</code> <code>list[str] | None</code> <p>Attributes by which to sort the results. Defaults to None.</p> <code>None</code> <code>show_matches_position</code> <code>bool</code> <p>Defines whether an object that contains information about the matches should be returned or not. Defaults to False.</p> <code>False</code> <code>highlight_pre_tag</code> <code>str</code> <p>The opening tag for highlighting text. Defaults to . <code>'&lt;em&gt;'</code> <code>highlight_post_tag</code> <code>str</code> <p>The closing tag for highlighting text. Defaults to </p> <code>'&lt;/em&gt;'</code> <code>crop_marker</code> <code>str</code> <p>Marker to display when the number of words exceeds the <code>crop_length</code>. Defaults to ...</p> <code>'...'</code> <code>matching_strategy</code> <code>Literal['all', 'last', 'frequency']</code> <p>Specifies the matching strategy Meilisearch should use. Defaults to <code>last</code>.</p> <code>'last'</code> <code>hits_per_page</code> <code>int | None</code> <p>Sets the number of results returned per page.</p> <code>None</code> <code>page</code> <code>int | None</code> <p>Sets the specific results page to fetch.</p> <code>None</code> <code>attributes_to_search_on</code> <code>list[str] | None</code> <p>List of field names. Allow search over a subset of searchable attributes without modifying the index settings. Defaults to None.</p> <code>None</code> <code>show_ranking_score</code> <code>bool</code> <p>If set to True the ranking score will be returned with each document in the search. Defaults to False.</p> <code>False</code> <code>show_ranking_score_details</code> <code>bool</code> <p>If set to True the ranking details will be returned with each document in the search. Defaults to False. Note: This parameter can only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order to use this feature in Meilisearch v1.3.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"scoreDetails\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution. This feature became stable in Meiliseach v1.7.0.</p> <code>False</code> <code>ranking_score_threshold</code> <code>float | None</code> <p>If set, no document whose _rankingScore is under the rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults to None.</p> <code>None</code> <code>vector</code> <code>list[float] | None</code> <p>List of vectors for vector search. Defaults to None. Note: This parameter can only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order to use this feature in Meilisearch v1.3.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"vectorStore\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution.</p> <code>None</code> <code>locales</code> <code>list[str] | None</code> <p>Specifies the languages for the search. This parameter can only be used with Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.</p> <code>None</code> <code>retrieve_vectors</code> <code>bool | None</code> <p>Return document vector data with search result.</p> <code>None</code> <code>exhaustive_facet_count</code> <code>bool | None</code> <p>forcing the facet search to compute the facet counts the same way as the paginated search. This parameter can only be used with Milisearch &gt;= v1.14.0. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>FacetSearchResults</code> <p>Results of the search</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     search_results = index.search(     &gt;&gt;&gt;         \"Tron\",     &gt;&gt;&gt;         facet_name=\"genre\",     &gt;&gt;&gt;         facet_query=\"Sci-fi\"     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def facet_search(\n    self,\n    query: str | None = None,\n    *,\n    facet_name: str,\n    facet_query: str,\n    offset: int = 0,\n    limit: int = 20,\n    filter: Filter | None = None,\n    facets: list[str] | None = None,\n    attributes_to_retrieve: list[str] | None = None,\n    attributes_to_crop: list[str] | None = None,\n    crop_length: int = 200,\n    attributes_to_highlight: list[str] | None = None,\n    sort: list[str] | None = None,\n    show_matches_position: bool = False,\n    highlight_pre_tag: str = \"&lt;em&gt;\",\n    highlight_post_tag: str = \"&lt;/em&gt;\",\n    crop_marker: str = \"...\",\n    matching_strategy: Literal[\"all\", \"last\", \"frequency\"] = \"last\",\n    hits_per_page: int | None = None,\n    page: int | None = None,\n    attributes_to_search_on: list[str] | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    ranking_score_threshold: float | None = None,\n    vector: list[float] | None = None,\n    locales: list[str] | None = None,\n    retrieve_vectors: bool | None = None,\n    exhaustive_facet_count: bool | None = None,\n) -&gt; FacetSearchResults:\n    \"\"\"Search the index.\n\n    Args:\n        query: String containing the word(s) to search\n        facet_name: The name of the facet to search\n        facet_query: The facet search value\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        facets: Facets for which to retrieve the matching count. Defaults to None.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n        crop_length: The maximum number of words to display. Defaults to 200.\n        attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n            Defaults to None.\n        sort: Attributes by which to sort the results. Defaults to None.\n        show_matches_position: Defines whether an object that contains information about the\n            matches should be returned or not. Defaults to False.\n        highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n        highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n        crop_marker: Marker to display when the number of words exceeds the `crop_length`.\n            Defaults to ...\n        matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to\n            `last`.\n        hits_per_page: Sets the number of results returned per page.\n        page: Sets the specific results page to fetch.\n        attributes_to_search_on: List of field names. Allow search over a subset of searchable\n            attributes without modifying the index settings. Defaults to None.\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n            to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n            sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n            Because this feature is experimental it may be removed or updated causing breaking\n            changes in this library without a major version bump so use with caution. This\n            feature became stable in Meiliseach v1.7.0.\n        ranking_score_threshold: If set, no document whose _rankingScore is under the\n            rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n            to None.\n        vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n            In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n        locales: Specifies the languages for the search. This parameter can only be used with\n            Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.\n        retrieve_vectors: Return document vector data with search result.\n        exhaustive_facet_count: forcing the facet search to compute the facet counts the same\n            way as the paginated search. This parameter can only be used with Milisearch &gt;=\n            v1.14.0. Defaults to None.\n\n    Returns:\n        Results of the search\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_results = index.search(\n        &gt;&gt;&gt;         \"Tron\",\n        &gt;&gt;&gt;         facet_name=\"genre\",\n        &gt;&gt;&gt;         facet_query=\"Sci-fi\"\n        &gt;&gt;&gt;     )\n    \"\"\"\n    if ranking_score_threshold:\n        validate_ranking_score_threshold(ranking_score_threshold)\n\n    body = process_search_parameters(\n        q=query,\n        facet_name=facet_name,\n        facet_query=facet_query,\n        offset=offset,\n        limit=limit,\n        filter=filter,\n        facets=facets,\n        attributes_to_retrieve=attributes_to_retrieve,\n        attributes_to_crop=attributes_to_crop,\n        crop_length=crop_length,\n        attributes_to_highlight=attributes_to_highlight,\n        sort=sort,\n        show_matches_position=show_matches_position,\n        highlight_pre_tag=highlight_pre_tag,\n        highlight_post_tag=highlight_post_tag,\n        crop_marker=crop_marker,\n        matching_strategy=matching_strategy,\n        hits_per_page=hits_per_page,\n        page=page,\n        attributes_to_search_on=attributes_to_search_on,\n        show_ranking_score=show_ranking_score,\n        show_ranking_score_details=show_ranking_score_details,\n        ranking_score_threshold=ranking_score_threshold,\n        vector=vector,\n        locales=locales,\n        retrieve_vectors=retrieve_vectors,\n        exhaustive_facet_count=exhaustive_facet_count,\n    )\n\n    if self._pre_facet_search_plugins:\n        _run_plugins(\n            self._pre_facet_search_plugins,\n            Event.PRE,\n            query=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            ranking_score_threshold=ranking_score_threshold,\n            vector=vector,\n            exhaustive_facet_count=exhaustive_facet_count,\n        )\n\n    response = self._http_requests.post(f\"{self._base_url_with_uid}/facet-search\", body=body)\n    result = FacetSearchResults(**self._http_requests.parse_json(response))\n    if self._post_facet_search_plugins:\n        post = _run_plugins(self._post_facet_search_plugins, Event.POST, result=result)\n        if isinstance(post[\"generic_result\"], FacetSearchResults):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.fetch_info","title":"<code>fetch_info()</code>","text":"<p>Gets the information about the index.</p> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the AsyncIndex containing the retrieved information.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index_info = index.fetch_info()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def fetch_info(self) -&gt; Self:\n    \"\"\"Gets the information about the index.\n\n    Returns:\n        An instance of the AsyncIndex containing the retrieved information.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index_info = index.fetch_info()\n    \"\"\"\n    response = self._http_requests.get(self._base_url_with_uid)\n    index_dict = self._http_requests.parse_json(response)\n    self._set_fetch_info(\n        index_dict[\"primaryKey\"], index_dict[\"createdAt\"], index_dict[\"updatedAt\"]\n    )\n    return self\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.fields","title":"<code>fields(offset=0, limit=20, filter=None)</code>","text":"<p>Get the field properties on an index.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Number of fields to skip. Defaults to 0.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of fields returned. Defaults to 20.</p> <code>20</code> <code>filter</code> <code>FieldsFilter | None</code> <p>Filter fields to return based on properties. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>FieldResults</code> <p>Field properties</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     docs = [{\"id\": 1, \"title\": \"Some Title}]     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.add_documents(docs)     &gt;&gt;&gt;     fields = index.fields()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def fields(\n    self, offset: int = 0, limit: int = 20, filter: FieldsFilter | None = None\n) -&gt; FieldResults:\n    \"\"\"Get the field properties on an index.\n\n    Args:\n        offset: Number of fields to skip. Defaults to 0.\n        limit: Maximum number of fields returned. Defaults to 20.\n        filter: Filter fields to return based on properties. Defaults to None.\n\n    Returns:\n        Field properties\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     docs = [{\"id\": 1, \"title\": \"Some Title}]\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.add_documents(docs)\n        &gt;&gt;&gt;     fields = index.fields()\n    \"\"\"\n    filter_value = filter.model_dump(by_alias=True) if filter else None\n    response = self._http_requests.post(\n        f\"{self._base_url_with_uid}/fields\",\n        body={\"offset\": offset, \"limit\": limit, \"filter\": filter_value},\n    )\n    response_json = response.json()\n    fields = [Field(**field) for field in response_json[\"results\"]]\n\n    return FieldResults(\n        fields=fields,\n        offset=response_json[\"offset\"],\n        limit=response_json[\"limit\"],\n        total=response_json[\"total\"],\n    )\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_displayed_attributes","title":"<code>get_displayed_attributes()</code>","text":"<p>Get displayed attributes of the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List containing the displayed attributes of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     displayed_attributes = index.get_displayed_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_displayed_attributes(self) -&gt; list[str]:\n    \"\"\"Get displayed attributes of the index.\n\n    Returns:\n        List containing the displayed attributes of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     displayed_attributes = index.get_displayed_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/displayed-attributes\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_distinct_attribute","title":"<code>get_distinct_attribute()</code>","text":"<p>Get distinct attribute of the index.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>String containing the distinct attribute of the index. If no distinct attribute <code>None</code> is returned.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     distinct_attribute = index.get_distinct_attribute()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_distinct_attribute(self) -&gt; str | None:\n    \"\"\"Get distinct attribute of the index.\n\n    Returns:\n        String containing the distinct attribute of the index. If no distinct attribute\n            `None` is returned.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     distinct_attribute = index.get_distinct_attribute()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/distinct-attribute\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_document","title":"<code>get_document(document_id, *, fields=None, retrieve_vectors=False)</code>","text":"<p>Get one document with given document identifier.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>Unique identifier of the document.</p> required <code>fields</code> <code>list[str] | None</code> <p>Document attributes to show. If this value is None then all attributes are retrieved. Defaults to None.</p> <code>None</code> <code>retrieve_vectors</code> <code>bool</code> <p>If set to True the embedding vectors will be returned with the document. Defaults to False. Note: This parameter can only be used with Meilisearch &gt;= v1.13.0</p> <code>False</code> <p>Returns:     The document information</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     document = index.get_document(\"1234\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_document(\n    self,\n    document_id: str,\n    *,\n    fields: list[str] | None = None,\n    retrieve_vectors: bool = False,\n) -&gt; JsonDict:\n    \"\"\"Get one document with given document identifier.\n\n    Args:\n        document_id: Unique identifier of the document.\n        fields: Document attributes to show. If this value is None then all\n            attributes are retrieved. Defaults to None.\n        retrieve_vectors: If set to True the embedding vectors will be returned with the document.\n            Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.13.0\n    Returns:\n        The document information\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     document = index.get_document(\"1234\")\n    \"\"\"\n    parameters: JsonDict = {}\n\n    if fields:\n        parameters[\"fields\"] = \",\".join(fields)\n    if retrieve_vectors:\n        parameters[\"retrieveVectors\"] = \"true\"\n\n    url = build_encoded_url(f\"{self._documents_url}/{document_id}\", parameters)\n\n    response = self._http_requests.get(url)\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_documents","title":"<code>get_documents(*, ids=None, offset=0, limit=20, fields=None, filter=None, retrieve_vectors=False, sort=None)</code>","text":"<p>Get a batch documents from the index.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str] | None</code> <p>Array of document primary keys to retrieve. Defaults to None (Gets all documents).</p> <code>None</code> <code>offset</code> <code>int</code> <p>Number of documents to skip. Defaults to 0.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of documents returnedd. Defaults to 20.</p> <code>20</code> <code>fields</code> <code>list[str] | None</code> <p>Document attributes to show. If this value is None then all attributes are retrieved. Defaults to None.</p> <code>None</code> <code>filter</code> <code>Filter | None</code> <p>Filter value information. Defaults to None. Note: This parameter can only be used with Meilisearch &gt;= v1.2.0</p> <code>None</code> <code>retrieve_vectors</code> <code>bool</code> <p>If set to True the vectors will be returned with each document. Defaults to False. Note: This parameter can only be used with Meilisearch &gt;= v1.13.0</p> <code>False</code> <code>sort</code> <code>str | None</code> <p>Attribute by which to sort the results. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DocumentsInfo</code> <p>Documents info.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     documents = index.get_documents()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_documents(\n    self,\n    *,\n    ids: list[str] | None = None,\n    offset: int = 0,\n    limit: int = 20,\n    fields: list[str] | None = None,\n    filter: Filter | None = None,\n    retrieve_vectors: bool = False,\n    sort: str | None = None,\n) -&gt; DocumentsInfo:\n    \"\"\"Get a batch documents from the index.\n\n    Args:\n        ids: Array of document primary keys to retrieve. Defaults to None (Gets all documents).\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returnedd. Defaults to 20.\n        fields: Document attributes to show. If this value is None then all\n            attributes are retrieved. Defaults to None.\n        filter: Filter value information. Defaults to None. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.2.0\n        retrieve_vectors: If set to True the vectors will be returned with each document.\n            Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.13.0\n        sort: Attribute by which to sort the results. Defaults to None.\n\n    Returns:\n        Documents info.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     documents = index.get_documents()\n    \"\"\"\n    parameters: JsonDict = {\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    if sort:\n        parameters[\"sort\"] = sort\n\n    if not filter and not ids:\n        if retrieve_vectors:\n            parameters[\"retrieveVectors\"] = \"true\"\n        if fields:\n            parameters[\"fields\"] = \",\".join(fields)\n\n        url = build_encoded_url(self._documents_url, parameters)\n        response = self._http_requests.get(url)\n\n        return DocumentsInfo(**self._http_requests.parse_json(response))\n\n    if retrieve_vectors:\n        parameters[\"retrieveVectors\"] = True\n\n    if fields:\n        parameters[\"fields\"] = fields\n\n    parameters[\"filter\"] = filter\n\n    if ids:\n        parameters[\"ids\"] = ids\n\n    response = self._http_requests.post(f\"{self._documents_url}/fetch\", body=parameters)\n\n    return DocumentsInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_embedders","title":"<code>get_embedders()</code>","text":"<p>Get embedder settings for the index.</p> <p>Returns:</p> Type Description <code>Embedders | None</code> <p>Embedders for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     embedders = await index.get_embedders()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_embedders(self) -&gt; Embedders | None:\n    \"\"\"Get embedder settings for the index.\n\n    Returns:\n        Embedders for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     embedders = await index.get_embedders()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/embedders\")\n\n    return embedder_json_to_embedders_model(self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_facet_search","title":"<code>get_facet_search()</code>","text":"<p>Get setting for facet search opt-out.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if facet search is enabled or False if not.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     facet_search = await index.get_facet_search()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_facet_search(self) -&gt; bool:\n    \"\"\"Get setting for facet search opt-out.\n\n    Returns:\n        True if facet search is enabled or False if not.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     facet_search = await index.get_facet_search()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/facet-search\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_faceting","title":"<code>get_faceting()</code>","text":"<p>Get faceting for the index.</p> <p>Returns:</p> Type Description <code>Faceting</code> <p>Faceting for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     faceting = index.get_faceting()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_faceting(self) -&gt; Faceting:\n    \"\"\"Get faceting for the index.\n\n    Returns:\n        Faceting for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     faceting = index.get_faceting()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/faceting\")\n\n    return Faceting(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_filterable_attributes","title":"<code>get_filterable_attributes()</code>","text":"<p>Get filterable attributes of the index.</p> <p>Returns:</p> Type Description <code>list[str | FilterableAttributes] | None</code> <p>List containing the filterable attributes of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     filterable_attributes = index.get_filterable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_filterable_attributes(self) -&gt; list[str | FilterableAttributes] | None:\n    \"\"\"Get filterable attributes of the index.\n\n    Returns:\n        List containing the filterable attributes of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     filterable_attributes = index.get_filterable_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/filterable-attributes\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    response_json = self._http_requests.parse_json(response)\n\n    filterable_attributes: list[str | FilterableAttributes] = []\n    for r in response_json:\n        if isinstance(r, str):\n            filterable_attributes.append(r)\n        else:\n            filterable_attributes.append(\n                FilterableAttributes(\n                    attribute_patterns=r[\"attributePatterns\"],\n                    features=FilterableAttributeFeatures(**r[\"features\"]),\n                )\n            )\n\n    return filterable_attributes\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_localized_attributes","title":"<code>get_localized_attributes()</code>","text":"<p>Get localized attributes settings for the index.</p> <p>Returns:</p> Type Description <code>list[LocalizedAttributes] | None</code> <p>Localized attributes for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     localized_attributes = await index.get_localized_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_localized_attributes(self) -&gt; list[LocalizedAttributes] | None:\n    \"\"\"Get localized attributes settings for the index.\n\n    Returns:\n        Localized attributes for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     localized_attributes = await index.get_localized_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/localized-attributes\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    return [LocalizedAttributes(**x) for x in self._http_requests.parse_json(response)]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_non_separator_tokens","title":"<code>get_non_separator_tokens()</code>","text":"<p>Get non-separator token settings for the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Non-separator tokens for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     non_separator_token_settings = index.get_non_separator_tokens()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_non_separator_tokens(self) -&gt; list[str]:\n    \"\"\"Get non-separator token settings for the index.\n\n    Returns:\n        Non-separator tokens for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     non_separator_token_settings = index.get_non_separator_tokens()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/non-separator-tokens\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_pagination","title":"<code>get_pagination()</code>","text":"<p>Get pagination settings for the index.</p> <p>Returns:</p> Type Description <code>Pagination</code> <p>Pagination for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     pagination_settings = index.get_pagination()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_pagination(self) -&gt; Pagination:\n    \"\"\"Get pagination settings for the index.\n\n    Returns:\n        Pagination for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     pagination_settings = index.get_pagination()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/pagination\")\n\n    return Pagination(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_prefix_search","title":"<code>get_prefix_search()</code>","text":"<p>Get setting for prefix search opt-out.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if prefix search is enabled or False if not.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     prefix_search = index.get_prefix_search()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_prefix_search(self) -&gt; bool:\n    \"\"\"Get setting for prefix search opt-out.\n\n    Returns:\n        True if prefix search is enabled or False if not.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     prefix_search = index.get_prefix_search()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/prefix-search\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_primary_key","title":"<code>get_primary_key()</code>","text":"<p>Get the primary key.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The primary key for the documents in the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     primary_key = index.get_primary_key()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_primary_key(self) -&gt; str | None:\n    \"\"\"Get the primary key.\n\n    Returns:\n        The primary key for the documents in the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     primary_key = index.get_primary_key()\n    \"\"\"\n    info = self.fetch_info()\n    return info.primary_key\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_proximity_precision","title":"<code>get_proximity_precision()</code>","text":"<p>Get proximity precision settings for the index.</p> <p>Returns:</p> Type Description <code>ProximityPrecision</code> <p>Proximity precision for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     proximity_precision = index.get_proximity_precision()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_proximity_precision(self) -&gt; ProximityPrecision:\n    \"\"\"Get proximity precision settings for the index.\n\n    Returns:\n        Proximity precision for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     proximity_precision = index.get_proximity_precision()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/proximity-precision\")\n\n    return ProximityPrecision[to_snake(self._http_requests.parse_json(response)).upper()]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_ranking_rules","title":"<code>get_ranking_rules()</code>","text":"<p>Get ranking rules of the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List containing the ranking rules of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     ranking_rules = index.get_ranking_rules()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_ranking_rules(self) -&gt; list[str]:\n    \"\"\"Get ranking rules of the index.\n\n    Returns:\n        List containing the ranking rules of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     ranking_rules = index.get_ranking_rules()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/ranking-rules\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_search_cutoff_ms","title":"<code>get_search_cutoff_ms()</code>","text":"<p>Get search cutoff time in ms.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>Integer representing the search cutoff time in ms, or None.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     search_cutoff_ms_settings = index.get_search_cutoff_ms()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_search_cutoff_ms(self) -&gt; int | None:\n    \"\"\"Get search cutoff time in ms.\n\n    Returns:\n        Integer representing the search cutoff time in ms, or None.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_cutoff_ms_settings = index.get_search_cutoff_ms()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/search-cutoff-ms\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_searchable_attributes","title":"<code>get_searchable_attributes()</code>","text":"<p>Get searchable attributes of the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List containing the searchable attributes of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     searchable_attributes = index.get_searchable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_searchable_attributes(self) -&gt; list[str]:\n    \"\"\"Get searchable attributes of the index.\n\n    Returns:\n        List containing the searchable attributes of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     searchable_attributes = index.get_searchable_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/searchable-attributes\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_separator_tokens","title":"<code>get_separator_tokens()</code>","text":"<p>Get separator token settings for the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Separator tokens for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     separator_token_settings = index.get_separator_tokens()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_separator_tokens(self) -&gt; list[str]:\n    \"\"\"Get separator token settings for the index.\n\n    Returns:\n        Separator tokens for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     separator_token_settings = index.get_separator_tokens()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/separator-tokens\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_settings","title":"<code>get_settings()</code>","text":"<p>Get settings of the index.</p> <p>Returns:</p> Type Description <code>MeilisearchSettings</code> <p>Settings of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     settings = index.get_settings()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_settings(self) -&gt; MeilisearchSettings:\n    \"\"\"Get settings of the index.\n\n    Returns:\n        Settings of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     settings = index.get_settings()\n    \"\"\"\n    response = self._http_requests.get(self._settings_url)\n    response_json = self._http_requests.parse_json(response)\n    settings = MeilisearchSettings(**response_json)\n\n    if response_json.get(\"embedders\"):\n        # Not coverted because it times out. It isn't an issue with the code here.\n        # https://github.com/meilisearch/meilisearch/issues/4585\n        settings.embedders = embedder_json_to_settings_model(  # pragma: no cover\n            response_json[\"embedders\"]\n        )\n\n    return settings\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_sortable_attributes","title":"<code>get_sortable_attributes()</code>","text":"<p>Get sortable attributes of the AsyncIndex.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List containing the sortable attributes of the AsyncIndex.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     sortable_attributes = index.get_sortable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_sortable_attributes(self) -&gt; list[str]:\n    \"\"\"Get sortable attributes of the AsyncIndex.\n\n    Returns:\n        List containing the sortable attributes of the AsyncIndex.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     sortable_attributes = index.get_sortable_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/sortable-attributes\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_stats","title":"<code>get_stats()</code>","text":"<p>Get stats of the index.</p> <p>Returns:</p> Type Description <code>IndexStats</code> <p>Stats of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     stats = index.get_stats()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_stats(self) -&gt; IndexStats:\n    \"\"\"Get stats of the index.\n\n    Returns:\n        Stats of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     stats = index.get_stats()\n    \"\"\"\n    response = self._http_requests.get(self._stats_url)\n\n    return IndexStats(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_stop_words","title":"<code>get_stop_words()</code>","text":"<p>Get stop words of the index.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>List containing the stop words of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     stop_words = index.get_stop_words()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_stop_words(self) -&gt; list[str] | None:\n    \"\"\"Get stop words of the index.\n\n    Returns:\n        List containing the stop words of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     stop_words = index.get_stop_words()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/stop-words\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_synonyms","title":"<code>get_synonyms()</code>","text":"<p>Get synonyms of the index.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]] | None</code> <p>The synonyms of the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     synonyms = index.get_synonyms()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_synonyms(self) -&gt; dict[str, list[str]] | None:\n    \"\"\"Get synonyms of the index.\n\n    Returns:\n        The synonyms of the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     synonyms = index.get_synonyms()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/synonyms\")\n\n    if not self._http_requests.parse_json(response):\n        return None\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_typo_tolerance","title":"<code>get_typo_tolerance()</code>","text":"<p>Get typo tolerance for the index.</p> <p>Returns:</p> Type Description <code>TypoTolerance</code> <p>TypoTolerance for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     sortable_attributes = index.get_typo_tolerance()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_typo_tolerance(self) -&gt; TypoTolerance:\n    \"\"\"Get typo tolerance for the index.\n\n    Returns:\n        TypoTolerance for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     sortable_attributes = index.get_typo_tolerance()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/typo-tolerance\")\n\n    return TypoTolerance(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_word_dictionary","title":"<code>get_word_dictionary()</code>","text":"<p>Get word dictionary settings for the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Word dictionary for the index.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     word_dictionary = index.get_word_dictionary()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def get_word_dictionary(self) -&gt; list[str]:\n    \"\"\"Get word dictionary settings for the index.\n\n    Returns:\n        Word dictionary for the index.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     word_dictionary = index.get_word_dictionary()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/dictionary\")\n\n    return self._http_requests.parse_json(response)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_displayed_attributes","title":"<code>reset_displayed_attributes()</code>","text":"<p>Reset displayed attributes of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_displayed_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_displayed_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset displayed attributes of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_displayed_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/displayed-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_distinct_attribute","title":"<code>reset_distinct_attribute()</code>","text":"<p>Reset distinct attribute of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_distinct_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_distinct_attribute(self) -&gt; TaskInfo:\n    \"\"\"Reset distinct attribute of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_distinct_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/distinct-attribute\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_embedders","title":"<code>reset_embedders()</code>","text":"<p>Reset an index's embedders settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_embedders()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_embedders(self) -&gt; TaskInfo:  # pragma: no cover\n    \"\"\"Reset an index's embedders settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_embedders()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/embedders\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_facet_search","title":"<code>reset_facet_search()</code>","text":"<p>Reset the facet search opt-out settings.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     await index.reset_facet_search()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_facet_search(self) -&gt; TaskInfo:\n    \"\"\"Reset the facet search opt-out settings.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_facet_search()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/facet-search\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_faceting","title":"<code>reset_faceting()</code>","text":"<p>Reset an index's faceting settings to their default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_faceting()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_faceting(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's faceting settings to their default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_faceting()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/faceting\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_filterable_attributes","title":"<code>reset_filterable_attributes()</code>","text":"<p>Reset filterable attributes of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_filterable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_filterable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset filterable attributes of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_filterable_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/filterable-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_localized_attributes","title":"<code>reset_localized_attributes()</code>","text":"<p>Reset an index's localized attributes settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import AsyncClient     &gt;&gt;&gt; Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt; index = client.index(\"movies\")     &gt;&gt;&gt; index.reset_localized_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_localized_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's localized attributes settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_localized_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/localized-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_non_separator_tokens","title":"<code>reset_non_separator_tokens()</code>","text":"<p>Reset an index's non-separator tokens settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_non_separator_tokens()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_non_separator_tokens(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's non-separator tokens settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_non_separator_tokens()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/non-separator-tokens\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_pagination","title":"<code>reset_pagination()</code>","text":"<p>Reset an index's pagination settings to their default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_pagination()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_pagination(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's pagination settings to their default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_pagination()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/pagination\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_prefix_search","title":"<code>reset_prefix_search()</code>","text":"<p>Reset the prefix search opt-out settings.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_prefix_search()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_prefix_search(self) -&gt; TaskInfo:\n    \"\"\"Reset the prefix search opt-out settings.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_prefix_search()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/prefix-search\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_proximity_precision","title":"<code>reset_proximity_precision()</code>","text":"<p>Reset an index's proximity precision settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_proximity_precision()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_proximity_precision(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's proximity precision settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_proximity_precision()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/proximity-precision\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_ranking_rules","title":"<code>reset_ranking_rules()</code>","text":"<p>Reset ranking rules of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_ranking_rules()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_ranking_rules(self) -&gt; TaskInfo:\n    \"\"\"Reset ranking rules of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_ranking_rules()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/ranking-rules\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_search_cutoff_ms","title":"<code>reset_search_cutoff_ms()</code>","text":"<p>Reset the search cutoff time to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_search_cutoff_ms()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_search_cutoff_ms(self) -&gt; TaskInfo:\n    \"\"\"Reset the search cutoff time to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_search_cutoff_ms()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/search-cutoff-ms\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_searchable_attributes","title":"<code>reset_searchable_attributes()</code>","text":"<p>Reset searchable attributes of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_searchable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_searchable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset searchable attributes of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_searchable_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/searchable-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_separator_tokens","title":"<code>reset_separator_tokens()</code>","text":"<p>Reset an index's separator tokens settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_separator_tokens()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_separator_tokens(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's separator tokens settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_separator_tokens()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/separator-tokens\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_settings","title":"<code>reset_settings()</code>","text":"<p>Reset settings of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_settings()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_settings(self) -&gt; TaskInfo:\n    \"\"\"Reset settings of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_settings()\n    \"\"\"\n    response = self._http_requests.delete(self._settings_url)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_sortable_attributes","title":"<code>reset_sortable_attributes()</code>","text":"<p>Reset sortable attributes of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_sortable_attributes()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_sortable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset sortable attributes of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_sortable_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/sortable-attributes\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_stop_words","title":"<code>reset_stop_words()</code>","text":"<p>Reset stop words of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_stop_words()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_stop_words(self) -&gt; TaskInfo:\n    \"\"\"Reset stop words of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_stop_words()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/stop-words\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_synonyms","title":"<code>reset_synonyms()</code>","text":"<p>Reset synonyms of the index to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_synonyms()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_synonyms(self) -&gt; TaskInfo:\n    \"\"\"Reset synonyms of the index to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_synonyms()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/synonyms\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_typo_tolerance","title":"<code>reset_typo_tolerance()</code>","text":"<p>Reset typo tolerance to default values.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_typo_tolerance()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_typo_tolerance(self) -&gt; TaskInfo:\n    \"\"\"Reset typo tolerance to default values.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_typo_tolerance()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/typo-tolerance\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_word_dictionary","title":"<code>reset_word_dictionary()</code>","text":"<p>Reset an index's word dictionary settings to the default value.</p> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_async_client import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.reset_word_dictionary()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def reset_word_dictionary(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's word dictionary settings to the default value.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.reset_word_dictionary()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/dictionary\")\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.search","title":"<code>search(query=None, *, offset=0, limit=20, filter=None, facets=None, attributes_to_retrieve=None, attributes_to_crop=None, crop_length=200, attributes_to_highlight=None, sort=None, show_matches_position=False, highlight_pre_tag='&lt;em&gt;', highlight_post_tag='&lt;/em&gt;', crop_marker='...', matching_strategy='last', hits_per_page=None, page=None, attributes_to_search_on=None, distinct=None, show_ranking_score=False, show_ranking_score_details=False, ranking_score_threshold=None, vector=None, hybrid=None, locales=None, retrieve_vectors=None, media=None, show_performance_details=False)</code>","text":"<p>Search the index.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>String containing the word(s) to search</p> <code>None</code> <code>offset</code> <code>int</code> <p>Number of documents to skip. Defaults to 0.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of documents returned. Defaults to 20.</p> <code>20</code> <code>filter</code> <code>Filter | None</code> <p>Filter queries by an attribute value. Defaults to None.</p> <code>None</code> <code>facets</code> <code>list[str] | None</code> <p>Facets for which to retrieve the matching count. Defaults to None.</p> <code>None</code> <code>attributes_to_retrieve</code> <code>list[str] | None</code> <p>Attributes to display in the returned documents. Defaults to [\"*\"].</p> <code>None</code> <code>attributes_to_crop</code> <code>list[str] | None</code> <p>Attributes whose values have to be cropped. Defaults to None.</p> <code>None</code> <code>crop_length</code> <code>int</code> <p>The maximum number of words to display. Defaults to 200.</p> <code>200</code> <code>attributes_to_highlight</code> <code>list[str] | None</code> <p>Attributes whose values will contain highlighted matching terms. Defaults to None.</p> <code>None</code> <code>sort</code> <code>list[str] | None</code> <p>Attributes by which to sort the results. Defaults to None.</p> <code>None</code> <code>show_matches_position</code> <code>bool</code> <p>Defines whether an object that contains information about the matches should be returned or not. Defaults to False.</p> <code>False</code> <code>highlight_pre_tag</code> <code>str</code> <p>The opening tag for highlighting text. Defaults to . <code>'&lt;em&gt;'</code> <code>highlight_post_tag</code> <code>str</code> <p>The closing tag for highlighting text. Defaults to </p> <code>'&lt;/em&gt;'</code> <code>crop_marker</code> <code>str</code> <p>Marker to display when the number of words exceeds the <code>crop_length</code>. Defaults to ...</p> <code>'...'</code> <code>matching_strategy</code> <code>Literal['all', 'last', 'frequency']</code> <p>Specifies the matching strategy Meilisearch should use. Defaults to <code>last</code>.</p> <code>'last'</code> <code>hits_per_page</code> <code>int | None</code> <p>Sets the number of results returned per page.</p> <code>None</code> <code>page</code> <code>int | None</code> <p>Sets the specific results page to fetch.</p> <code>None</code> <code>attributes_to_search_on</code> <code>list[str] | None</code> <p>List of field names. Allow search over a subset of searchable attributes without modifying the index settings. Defaults to None.</p> <code>None</code> <code>distinct</code> <code>str | None</code> <p>If set the distinct value will return at most one result for the filterable attribute. Note that a filterable attributes must be set for this work. Defaults to None.</p> <code>None</code> <code>show_ranking_score</code> <code>bool</code> <p>If set to True the ranking score will be returned with each document in the search. Defaults to False.</p> <code>False</code> <code>show_ranking_score_details</code> <code>bool</code> <p>If set to True the ranking details will be returned with each document in the search. Defaults to False. Note: This parameter can only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order to use this feature in Meilisearch v1.3.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"scoreDetails\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution. This feature became stable in Meiliseach v1.7.0.</p> <code>False</code> <code>ranking_score_threshold</code> <code>float | None</code> <p>If set, no document whose _rankingScore is under the rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults to None.</p> <code>None</code> <code>vector</code> <code>list[float] | None</code> <p>List of vectors for vector search. Defaults to None. Note: This parameter can only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order to use this feature in Meilisearch v1.3.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"vectorStore\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution.</p> <code>None</code> <code>hybrid</code> <code>Hybrid | None</code> <p>Hybrid search information. Defaults to None. Note: This parameter can only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0. In order to use this feature in Meilisearch v1.6.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"vectorStore\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution.</p> <code>None</code> <code>locales</code> <code>list[str] | None</code> <p>Specifies the languages for the search. This parameter can only be used with Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.</p> <code>None</code> <code>retrieve_vectors</code> <code>bool | None</code> <p>Return document vector data with search result.</p> <code>None</code> <code>media</code> <code>JsonMapping | None</code> <p>The content of media is used as if it were a document to generate request fragments from the searchFragments parameter. Defaults to None. This parameter can only be used with Meilisearch &gt;= v1.16.0. In order to use this feature in Meilisearch v1.16.0 you first need to enable the feature by sending a PATCH request to /experimental-features with { \"multimodal\": true }. Because this feature is experimental it may be removed or updated causing breaking changes in this library without a major version bump so use with caution.</p> <code>None</code> <code>show_performance_details</code> <code>bool</code> <p>When set to true, the search response contains a performance trace. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>SearchResults</code> <p>Results of the search</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     search_results = index.search(\"Tron\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def search(\n    self,\n    query: str | None = None,\n    *,\n    offset: int = 0,\n    limit: int = 20,\n    filter: Filter | None = None,\n    facets: list[str] | None = None,\n    attributes_to_retrieve: list[str] | None = None,\n    attributes_to_crop: list[str] | None = None,\n    crop_length: int = 200,\n    attributes_to_highlight: list[str] | None = None,\n    sort: list[str] | None = None,\n    show_matches_position: bool = False,\n    highlight_pre_tag: str = \"&lt;em&gt;\",\n    highlight_post_tag: str = \"&lt;/em&gt;\",\n    crop_marker: str = \"...\",\n    matching_strategy: Literal[\"all\", \"last\", \"frequency\"] = \"last\",\n    hits_per_page: int | None = None,\n    page: int | None = None,\n    attributes_to_search_on: list[str] | None = None,\n    distinct: str | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    ranking_score_threshold: float | None = None,\n    vector: list[float] | None = None,\n    hybrid: Hybrid | None = None,\n    locales: list[str] | None = None,\n    retrieve_vectors: bool | None = None,\n    media: JsonMapping | None = None,\n    show_performance_details: bool = False,\n) -&gt; SearchResults:\n    \"\"\"Search the index.\n\n    Args:\n        query: String containing the word(s) to search\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        facets: Facets for which to retrieve the matching count. Defaults to None.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n        crop_length: The maximum number of words to display. Defaults to 200.\n        attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n            Defaults to None.\n        sort: Attributes by which to sort the results. Defaults to None.\n        show_matches_position: Defines whether an object that contains information about the\n            matches should be returned or not. Defaults to False.\n        highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n        highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n        crop_marker: Marker to display when the number of words exceeds the `crop_length`.\n            Defaults to ...\n        matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to\n            `last`.\n        hits_per_page: Sets the number of results returned per page.\n        page: Sets the specific results page to fetch.\n        attributes_to_search_on: List of field names. Allow search over a subset of searchable\n            attributes without modifying the index settings. Defaults to None.\n        distinct: If set the distinct value will return at most one result for the\n            filterable attribute. Note that a filterable attributes must be set for this work.\n            Defaults to None.\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n            to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n            sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n            Because this feature is experimental it may be removed or updated causing breaking\n            changes in this library without a major version bump so use with caution. This\n            feature became stable in Meiliseach v1.7.0.\n        ranking_score_threshold: If set, no document whose _rankingScore is under the\n            rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n            to None.\n        vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n            In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n        hybrid: Hybrid search information. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n            In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n        locales: Specifies the languages for the search. This parameter can only be used with\n            Milisearch &gt;= v1.10.0. Defaults to None letting the Meilisearch pick.\n        retrieve_vectors: Return document vector data with search result.\n        media: The content of media is used as if it were a document to generate request\n            fragments from the searchFragments parameter. Defaults to None. This parameter can\n            only be used with Meilisearch &gt;= v1.16.0. In order to use this feature in\n            Meilisearch v1.16.0 you first need to enable the feature by sending a PATCH request\n            to /experimental-features with { \"multimodal\": true }. Because this feature is\n            experimental it may be removed or updated causing breaking changes in this library\n            without a major version bump so use with caution.\n        show_performance_details: When set to true, the search response contains a performance\n            trace. Default False.\n\n    Returns:\n        Results of the search\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_results = index.search(\"Tron\")\n    \"\"\"\n    if ranking_score_threshold:\n        validate_ranking_score_threshold(ranking_score_threshold)\n\n    body = process_search_parameters(\n        q=query,\n        offset=offset,\n        limit=limit,\n        filter=filter,\n        facets=facets,\n        attributes_to_retrieve=attributes_to_retrieve,\n        attributes_to_crop=attributes_to_crop,\n        crop_length=crop_length,\n        attributes_to_highlight=attributes_to_highlight,\n        sort=sort,\n        show_matches_position=show_matches_position,\n        highlight_pre_tag=highlight_pre_tag,\n        highlight_post_tag=highlight_post_tag,\n        crop_marker=crop_marker,\n        matching_strategy=matching_strategy,\n        hits_per_page=hits_per_page,\n        page=page,\n        attributes_to_search_on=attributes_to_search_on,\n        distinct=distinct,\n        show_ranking_score=show_ranking_score,\n        show_ranking_score_details=show_ranking_score_details,\n        vector=vector,\n        hybrid=hybrid,\n        ranking_score_threshold=ranking_score_threshold,\n        locales=locales,\n        retrieve_vectors=retrieve_vectors,\n        media=media,\n        show_performance_details=show_performance_details,\n    )\n\n    if self._pre_search_plugins:\n        _run_plugins(\n            self._pre_search_plugins,\n            Event.PRE,\n            query=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            distinct=distinct,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n            hybrid=hybrid,\n        )\n\n    response = self._http_requests.post(f\"{self._base_url_with_uid}/search\", body=body)\n    result = SearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n    if self._post_search_plugins:\n        post = _run_plugins(self._post_search_plugins, Event.POST, search_results=result)\n        if post.get(\"search_result\"):\n            result = post[\"search_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.search_similar_documents","title":"<code>search_similar_documents(id, *, offset=None, limit=None, filter=None, embedder='default', attributes_to_retrieve=None, show_ranking_score=False, show_ranking_score_details=False, ranking_score_threshold=None)</code>","text":"<p>Search the index.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id for the target document that is being used to find similar documents.</p> required <code>offset</code> <code>int | None</code> <p>Number of documents to skip. Defaults to 0.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of documents returned. Defaults to 20.</p> <code>None</code> <code>filter</code> <code>str | None</code> <p>Filter queries by an attribute value. Defaults to None.</p> <code>None</code> <code>embedder</code> <code>str</code> <p>The vector DB to use for the search.</p> <code>'default'</code> <code>attributes_to_retrieve</code> <code>list[str] | None</code> <p>Attributes to display in the returned documents. Defaults to [\"*\"].</p> <code>None</code> <code>show_ranking_score</code> <code>bool</code> <p>If set to True the ranking score will be returned with each document in the search. Defaults to False.</p> <code>False</code> <code>show_ranking_score_details</code> <code>bool</code> <p>If set to True the ranking details will be returned with each document in the search. Defaults to False.</p> <code>False</code> <code>ranking_score_threshold</code> <code>float | None</code> <p>If set, no document whose _rankingScore is under the rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>SimilarSearchResults</code> <p>Results of the search</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     search_results = index.search_similar_documents(\"123\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def search_similar_documents(\n    self,\n    id: str,\n    *,\n    offset: int | None = None,\n    limit: int | None = None,\n    filter: str | None = None,\n    embedder: str = \"default\",\n    attributes_to_retrieve: list[str] | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    ranking_score_threshold: float | None = None,\n) -&gt; SimilarSearchResults:\n    \"\"\"Search the index.\n\n    Args:\n        id: The id for the target document that is being used to find similar documents.\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        embedder: The vector DB to use for the search.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False.\n        ranking_score_threshold: If set, no document whose _rankingScore is under the\n            rankingScoreThreshold is returned. The value must be between 0.0 and 1.0. Defaults\n            to None.\n\n    Returns:\n        Results of the search\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_results = index.search_similar_documents(\"123\")\n    \"\"\"\n    payload = {\n        \"id\": id,\n        \"filter\": filter,\n        \"embedder\": embedder,\n        \"attributesToRetrieve\": attributes_to_retrieve,\n        \"showRankingScore\": show_ranking_score,\n        \"showRankingScoreDetails\": show_ranking_score_details,\n        \"rankingScoreThreshold\": ranking_score_threshold,\n    }\n\n    if offset:\n        payload[\"offset\"] = offset\n\n    if limit:\n        payload[\"limit\"] = limit\n\n    response = self._http_requests.post(f\"{self._base_url_with_uid}/similar\", body=payload)\n\n    return SimilarSearchResults[self.hits_type](**self._http_requests.parse_json(response))  # type: ignore[name-defined]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update","title":"<code>update(primary_key)</code>","text":"<p>Update the index primary key.</p> <p>Parameters:</p> Name Type Description Default <code>primary_key</code> <code>str</code> <p>The primary key of the documents.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the AsyncIndex with the updated information.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     updated_index = index.update()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update(self, primary_key: str) -&gt; Self:\n    \"\"\"Update the index primary key.\n\n    Args:\n        primary_key: The primary key of the documents.\n\n    Returns:\n        An instance of the AsyncIndex with the updated information.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     updated_index = index.update()\n    \"\"\"\n    payload = {\"primaryKey\": primary_key}\n    response = self._http_requests.patch(self._base_url_with_uid, payload)\n    wait_for_task(\n        self.http_client,\n        self._http_requests.parse_json(response)[\"taskUid\"],\n        timeout_in_ms=100000,\n    )\n    index_response = self._http_requests.get(self._base_url_with_uid)\n    self.primary_key = self._http_requests.parse_json(index_response)[\"primaryKey\"]\n    return self\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_displayed_attributes","title":"<code>update_displayed_attributes(body, *, compress=False)</code>","text":"<p>Update displayed attributes of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[str]</code> <p>List containing the displayed attributes.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_displayed_attributes(     &gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_displayed_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update displayed attributes of the index.\n\n    Args:\n        body: List containing the displayed attributes.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_displayed_attributes(\n        &gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]\n        &gt;&gt;&gt;     )\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/displayed-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_distinct_attribute","title":"<code>update_distinct_attribute(body, *, compress=False)</code>","text":"<p>Update distinct attribute of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>Distinct attribute.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_distinct_attribute(\"url\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_distinct_attribute(self, body: str, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update distinct attribute of the index.\n\n    Args:\n        body: Distinct attribute.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_distinct_attribute(\"url\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/distinct-attribute\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents","title":"<code>update_documents(documents, primary_key=None, *, custom_metadata=None, skip_creation=False, compress=False)</code>","text":"<p>Update documents in the index.</p> <p>Parameters:</p> Name Type Description Default <code>documents</code> <code>Sequence[JsonMapping]</code> <p>List of documents.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_documents(documents)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_documents(\n    self,\n    documents: Sequence[JsonMapping],\n    primary_key: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Update documents in the index.\n\n    Args:\n        documents: List of documents.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_documents(documents)\n    \"\"\"\n    params = {}\n\n    if primary_key:\n        params[\"primaryKey\"] = primary_key\n    if custom_metadata:\n        params[\"customMetadata\"] = custom_metadata\n    if skip_creation:\n        params[\"skipCreation\"] = \"true\"\n\n    if params:\n        url = build_encoded_url(self._documents_url, params)\n    else:\n        url = self._documents_url\n\n    if self._pre_update_documents_plugins:\n        pre = _run_plugins(\n            self._pre_update_documents_plugins,\n            Event.PRE,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if pre.get(\"document_result\"):\n            documents = pre[\"document_result\"]\n\n    response = self._http_requests.put(url, documents, compress=compress)\n    result = TaskInfo(**self._http_requests.parse_json(response))\n    if self._post_update_documents_plugins:\n        post = _run_plugins(self._post_update_documents_plugins, Event.POST, result=result)\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_directory","title":"<code>update_documents_from_directory(directory_path, *, primary_key=None, custom_metadata=None, document_type='json', csv_delimiter=None, combine_documents=True, skip_creation=False, compress=False)</code>","text":"<p>Load all json files from a directory and update the documents.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | str</code> <p>Path to the directory that contains the json files.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>document_type</code> <code>str</code> <p>The type of document being added. Accepted types are json, csv, and ndjson. For csv files the first row of the document should be a header row containing the field names, and ever for should have a title.</p> <code>'json'</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>combine_documents</code> <code>bool</code> <p>If set to True this will combine the documents from all the files before indexing them. Defaults to True.</p> <code>True</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_documents_from_directory(directory_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_documents_from_directory(\n    self,\n    directory_path: Path | str,\n    *,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and update the documents.\n\n    Args:\n        directory_path: Path to the directory that contains the json files.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row containing\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_documents_from_directory(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                all_documents.append(documents)\n\n        raise_on_no_documents(all_documents, document_type, directory_path)\n\n        combined = combine_documents_(all_documents)\n\n        response = self.update_documents(\n            combined,\n            primary_key,\n            custom_metadata=custom_metadata,\n            skip_creation=skip_creation,\n            compress=compress,\n        )\n        return [response]\n\n    responses = []\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = _load_documents_from_file(\n                path, csv_delimiter, json_handler=self._json_handler\n            )\n            responses.append(\n                self.update_documents(\n                    documents,\n                    primary_key,\n                    custom_metadata=custom_metadata,\n                    skip_creation=skip_creation,\n                    compress=compress,\n                )\n            )\n\n    raise_on_no_documents(responses, document_type, directory_path)\n\n    return responses\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_directory_in_batches","title":"<code>update_documents_from_directory_in_batches(directory_path, *, batch_size=1000, primary_key=None, custom_metadata=None, document_type='json', csv_delimiter=None, combine_documents=True, skip_creation=False, compress=False)</code>","text":"<p>Load all json files from a directory and update the documents.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | str</code> <p>Path to the directory that contains the json files.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>document_type</code> <code>str</code> <p>The type of document being added. Accepted types are json, csv, and ndjson. For csv files the first row of the document should be a header row containing the field names, and ever for should have a title.</p> <code>'json'</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>combine_documents</code> <code>bool</code> <p>If set to True this will combine the documents from all the files before indexing them. Defaults to True.</p> <code>True</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>InvalidDocumentError</code> <p>If the docucment is not a valid format for Meilisearch.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_documents_from_directory_in_batches(directory_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_documents_from_directory_in_batches(\n    self,\n    directory_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and update the documents.\n\n    Args:\n        directory_path: Path to the directory that contains the json files.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row\n            containing the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_documents_from_directory_in_batches(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(\n                    path, csv_delimiter, json_handler=self._json_handler\n                )\n                all_documents.append(documents)\n\n        raise_on_no_documents(all_documents, document_type, directory_path)\n\n        combined = combine_documents_(all_documents)\n\n        return self.update_documents_in_batches(\n            combined,\n            batch_size=batch_size,\n            primary_key=primary_key,\n            custom_metadata=custom_metadata,\n            skip_creation=skip_creation,\n            compress=compress,\n        )\n\n    responses: list[TaskInfo] = []\n\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = _load_documents_from_file(\n                path, csv_delimiter, json_handler=self._json_handler\n            )\n            responses.extend(\n                self.update_documents_in_batches(\n                    documents,\n                    batch_size=batch_size,\n                    primary_key=primary_key,\n                    custom_metadata=custom_metadata,\n                    skip_creation=skip_creation,\n                    compress=compress,\n                )\n            )\n\n    raise_on_no_documents(responses, document_type, directory_path)\n\n    return responses\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_file","title":"<code>update_documents_from_file(file_path, primary_key=None, csv_delimiter=None, *, custom_metadata=None, skip_creation=False, compress=False)</code>","text":"<p>Add documents in the index from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the json file.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_documents_from_file(file_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_documents_from_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents in the index from a json file.\n\n    Args:\n        file_path: Path to the json file.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_documents_from_file(file_path)\n    \"\"\"\n    documents = _load_documents_from_file(\n        file_path, csv_delimiter, json_handler=self._json_handler\n    )\n\n    return self.update_documents(\n        documents,\n        primary_key=primary_key,\n        custom_metadata=custom_metadata,\n        skip_creation=skip_creation,\n        compress=compress,\n    )\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_file_in_batches","title":"<code>update_documents_from_file_in_batches(file_path, *, batch_size=1000, primary_key=None, custom_metadata=None, skip_creation=False, compress=False)</code>","text":"<p>Updates documents form a json file in batches to reduce RAM usage with indexing.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path to the json file.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_documents_from_file_in_batches(file_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_documents_from_file_in_batches(\n    self,\n    file_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Updates documents form a json file in batches to reduce RAM usage with indexing.\n\n    Args:\n        file_path: Path to the json file.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_documents_from_file_in_batches(file_path)\n    \"\"\"\n    documents = _load_documents_from_file(file_path, json_handler=self._json_handler)\n\n    return self.update_documents_in_batches(\n        documents,\n        batch_size=batch_size,\n        primary_key=primary_key,\n        custom_metadata=custom_metadata,\n        skip_creation=skip_creation,\n        compress=compress,\n    )\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_raw_file","title":"<code>update_documents_from_raw_file(file_path, primary_key=None, csv_delimiter=None, *, custom_metadata=None, skip_creation=False, compress=False)</code>","text":"<p>Directly send csv or ndjson files to Meilisearch without pre-processing.</p> <p>The can reduce RAM usage from Meilisearch during indexing, but does not include the option for batching.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>The path to the file to send to Meilisearch. Only csv and ndjson files are allowed.</p> required <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>csv_delimiter</code> <code>str | None</code> <p>A single ASCII character to specify the delimiter for csv files. This can only be used if the file is a csv file. Defaults to comma.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is not a csv or ndjson file, or if a csv_delimiter is sent for a non-csv file.</p> <code>MeilisearchError</code> <p>If the file path is not valid</p> <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_documents_from_raw_file(file_path)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_documents_from_raw_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    *,\n    custom_metadata: str | None = None,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n    The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n    for batching.\n\n    Args:\n        file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n            allowed.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n            a non-csv file.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_documents_from_raw_file(file_path)\n    \"\"\"\n    upload_path, content_type = prepare_raw_file_upload(file_path, csv_delimiter)\n    parameters = {}\n\n    if primary_key:\n        parameters[\"primaryKey\"] = primary_key\n    if csv_delimiter:\n        parameters[\"csvDelimiter\"] = csv_delimiter\n    if custom_metadata:\n        parameters[\"customMetadata\"] = custom_metadata\n    if skip_creation:\n        parameters[\"skipCreation\"] = \"true\"\n\n    if parameters:\n        url = build_encoded_url(self._documents_url, parameters)\n    else:\n        url = self._documents_url\n\n    with open(upload_path) as f:\n        data = f.read()\n\n    response = self._http_requests.put(\n        url, body=data, content_type=content_type, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_in_batches","title":"<code>update_documents_in_batches(documents, *, batch_size=1000, primary_key=None, custom_metadata=None, skip_creation=False, compress=False)</code>","text":"<p>Update documents in batches to reduce RAM usage with indexing.</p> <p>Each batch tries to fill the max_payload_size</p> <p>Parameters:</p> Name Type Description Default <code>documents</code> <code>Sequence[JsonMapping]</code> <p>List of documents.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents that should be included in each batch. Defaults to 1000.</p> <code>1000</code> <code>primary_key</code> <code>str | None</code> <p>The primary key of the documents. This will be ignored if already set. Defaults to None.</p> <code>None</code> <code>custom_metadata</code> <code>str | None</code> <p>An arbitrary string accessible via the task. Defaults to None.</p> <code>None</code> <code>skip_creation</code> <code>bool</code> <p>When set to true, documents that don't exist in the index are silently ignored rather than created. Default = False.</p> <code>False</code> <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[TaskInfo]</code> <p>List of update ids to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; documents = [     &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},     &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},     &gt;&gt;&gt; ]     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_documents_in_batches(documents)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_documents_in_batches(\n    self,\n    documents: Sequence[JsonMapping],\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    custom_metadata: str | None = None,\n    skip_creation: bool = False,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Update documents in batches to reduce RAM usage with indexing.\n\n    Each batch tries to fill the max_payload_size\n\n    Args:\n        documents: List of documents.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        custom_metadata: An arbitrary string accessible via the task. Defaults to None.\n        skip_creation: When set to true, documents that don't exist in the index are silently\n            ignored rather than created. Default = False.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        List of update ids to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_documents_in_batches(documents)\n    \"\"\"\n    return [\n        self.update_documents(\n            x,\n            primary_key,\n            custom_metadata=custom_metadata,\n            skip_creation=skip_creation,\n            compress=compress,\n        )\n        for x in batch(documents, batch_size)\n    ]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_embedders","title":"<code>update_embedders(embedders, *, compress=False)</code>","text":"<p>Update the embedders settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>embedders</code> <code>Embedders</code> <p>The embedders value.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_embedders(     &gt;&gt;&gt;         Embedders(embedders={dimensions=512)})     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_embedders(self, embedders: Embedders, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update the embedders settings for an index.\n\n    Args:\n        embedders: The embedders value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_embedders(\n        &gt;&gt;&gt;         Embedders(embedders={dimensions=512)})\n        &gt;&gt;&gt;     )\n    \"\"\"\n    payload = {}\n    for key, embedder in embedders.embedders.items():\n        payload[key] = {\n            k: v\n            for k, v in embedder.model_dump(by_alias=True, exclude_none=True).items()\n            if v is not None\n        }\n\n    response = self._http_requests.patch(\n        f\"{self._settings_url}/embedders\", payload, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_facet_search","title":"<code>update_facet_search(facet_search, *, compress=False)</code>","text":"<p>Update setting for facet search opt-out.</p> <p>Parameters:</p> Name Type Description Default <code>facet_search</code> <code>bool</code> <p>Boolean indicating if facet search should be disabled.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_facet_search(True)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_facet_search(self, facet_search: bool, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update setting for facet search opt-out.\n\n    Args:\n        facet_search: Boolean indicating if facet search should be disabled.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_facet_search(True)\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/facet-search\",\n        facet_search,\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_faceting","title":"<code>update_faceting(faceting, *, compress=False)</code>","text":"<p>Partially update the faceting settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>faceting</code> <code>Faceting</code> <p>Faceting values.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_faceting(faceting=Faceting(max_values_per_facet=100))</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_faceting(self, faceting: Faceting, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Partially update the faceting settings for an index.\n\n    Args:\n        faceting: Faceting values.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n    \"\"\"\n    response = self._http_requests.patch(\n        f\"{self._settings_url}/faceting\",\n        faceting.model_dump(by_alias=True),\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_filterable_attributes","title":"<code>update_filterable_attributes(body, *, compress=False)</code>","text":"<p>Update filterable attributes of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[str | FilterableAttributes]</code> <p>List containing the filterable attributes of the index.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_filterable_attributes([\"genre\", \"director\"])</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_filterable_attributes(\n    self, body: list[str | FilterableAttributes], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update filterable attributes of the index.\n\n    Args:\n        body: List containing the filterable attributes of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_filterable_attributes([\"genre\", \"director\"])\n    \"\"\"\n    payload: list[str | JsonDict] = []\n\n    for b in body:\n        if isinstance(b, FilterableAttributes):\n            payload.append(b.model_dump(by_alias=True))\n        else:\n            payload.append(b)\n\n    response = self._http_requests.put(\n        f\"{self._settings_url}/filterable-attributes\", payload, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_localized_attributes","title":"<code>update_localized_attributes(localized_attributes, *, compress=False)</code>","text":"<p>Update the localized attributes settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>localized_attributes</code> <code>list[LocalizedAttributes]</code> <p>The localized attributes value.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient     &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import LocalizedAttributes     &gt;&gt;&gt;     &gt;&gt;&gt;     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_localized_attributes([     &gt;&gt;&gt;         LocalizedAttributes(locales=[\"eng\", \"spa\"], attribute_patterns=[\"\"]),     &gt;&gt;&gt;         LocalizedAttributes(locales=[\"ita\"], attribute_patterns=[\"_it\"]),     &gt;&gt;&gt;     ])</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_localized_attributes(\n    self, localized_attributes: list[LocalizedAttributes], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the localized attributes settings for an index.\n\n    Args:\n        localized_attributes: The localized attributes value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import LocalizedAttributes\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_localized_attributes([\n        &gt;&gt;&gt;         LocalizedAttributes(locales=[\"eng\", \"spa\"], attribute_patterns=[\"*\"]),\n        &gt;&gt;&gt;         LocalizedAttributes(locales=[\"ita\"], attribute_patterns=[\"*_it\"]),\n        &gt;&gt;&gt;     ])\n    \"\"\"\n    payload = [x.model_dump(by_alias=True) for x in localized_attributes]\n    response = self._http_requests.put(\n        f\"{self._settings_url}/localized-attributes\", payload, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_non_separator_tokens","title":"<code>update_non_separator_tokens(non_separator_tokens, *, compress=False)</code>","text":"<p>Update the non-separator tokens settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>non_separator_tokens</code> <code>list[str]</code> <p>List of non-separator tokens.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_non_separator_tokens(\n    self, non_separator_tokens: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the non-separator tokens settings for an index.\n\n    Args:\n        non_separator_tokens: List of non-separator tokens.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/non-separator-tokens\", non_separator_tokens, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_pagination","title":"<code>update_pagination(settings, *, compress=False)</code>","text":"<p>Partially update the pagination settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Pagination</code> <p>settings for pagination.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_pagination(settings=Pagination(max_total_hits=123))</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_pagination(self, settings: Pagination, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Partially update the pagination settings for an index.\n\n    Args:\n        settings: settings for pagination.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_pagination(settings=Pagination(max_total_hits=123))\n    \"\"\"\n    response = self._http_requests.patch(\n        f\"{self._settings_url}/pagination\",\n        settings.model_dump(by_alias=True),\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_prefix_search","title":"<code>update_prefix_search(prefix_search, *, compress=False)</code>","text":"<p>Update setting for prefix search opt-out.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_search</code> <code>Literal['disabled', 'indexingTime', 'searchTime']</code> <p>Value indicating prefix search setting.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_prefix_search(\"disabled\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_prefix_search(\n    self,\n    prefix_search: Literal[\"disabled\", \"indexingTime\", \"searchTime\"],\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Update setting for prefix search opt-out.\n\n    Args:\n        prefix_search: Value indicating prefix search setting.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_prefix_search(\"disabled\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/prefix-search\",\n        prefix_search,\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_proximity_precision","title":"<code>update_proximity_precision(proximity_precision, *, compress=False)</code>","text":"<p>Update the proximity precision settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>proximity_precision</code> <code>ProximityPrecision</code> <p>The proximity precision value.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_proximity_precision(\n    self, proximity_precision: ProximityPrecision, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the proximity precision settings for an index.\n\n    Args:\n        proximity_precision: The proximity precision value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/proximity-precision\",\n        proximity_precision.value,\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_ranking_rules","title":"<code>update_ranking_rules(ranking_rules, *, compress=False)</code>","text":"<p>Update ranking rules of the index.</p> <p>Parameters:</p> Name Type Description Default <code>ranking_rules</code> <code>list[str]</code> <p>List containing the ranking rules.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; ranking_rules=[     &gt;&gt;&gt;      \"words\",     &gt;&gt;&gt;      \"typo\",     &gt;&gt;&gt;      \"proximity\",     &gt;&gt;&gt;      \"attribute\",     &gt;&gt;&gt;      \"sort\",     &gt;&gt;&gt;      \"exactness\",     &gt;&gt;&gt;      \"release_date:desc\",     &gt;&gt;&gt;      \"rank:desc\",     &gt;&gt;&gt; ],     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_ranking_rules(ranking_rules)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_ranking_rules(self, ranking_rules: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update ranking rules of the index.\n\n    Args:\n        ranking_rules: List containing the ranking rules.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; ranking_rules=[\n        &gt;&gt;&gt;      \"words\",\n        &gt;&gt;&gt;      \"typo\",\n        &gt;&gt;&gt;      \"proximity\",\n        &gt;&gt;&gt;      \"attribute\",\n        &gt;&gt;&gt;      \"sort\",\n        &gt;&gt;&gt;      \"exactness\",\n        &gt;&gt;&gt;      \"release_date:desc\",\n        &gt;&gt;&gt;      \"rank:desc\",\n        &gt;&gt;&gt; ],\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_ranking_rules(ranking_rules)\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/ranking-rules\", ranking_rules, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_search_cutoff_ms","title":"<code>update_search_cutoff_ms(search_cutoff_ms, *, compress=False)</code>","text":"<p>Update the search cutoff for an index.</p> <p>Parameters:</p> Name Type Description Default <code>search_cutoff_ms</code> <code>int</code> <p>Integer value of the search cutoff time in ms.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_search_cutoff_ms(100)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_search_cutoff_ms(self, search_cutoff_ms: int, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update the search cutoff for an index.\n\n    Args:\n        search_cutoff_ms: Integer value of the search cutoff time in ms.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_search_cutoff_ms(100)\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/search-cutoff-ms\", search_cutoff_ms, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_searchable_attributes","title":"<code>update_searchable_attributes(body, *, compress=False)</code>","text":"<p>Update searchable attributes of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[str]</code> <p>List containing the searchable attributes.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_searchable_attributes([\"title\", \"description\", \"genre\"])</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_searchable_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update searchable attributes of the index.\n\n    Args:\n        body: List containing the searchable attributes.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/searchable-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_separator_tokens","title":"<code>update_separator_tokens(separator_tokens, *, compress=False)</code>","text":"<p>Update the separator tokens settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>separator_tokens</code> <code>list[str]</code> <p>List of separator tokens.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_separator_tokens(\n    self, separator_tokens: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the separator tokens settings for an index.\n\n    Args:\n        separator_tokens: List of separator tokens.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/separator-tokens\", separator_tokens, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_settings","title":"<code>update_settings(body, *, compress=False)</code>","text":"<p>Update settings of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>MeilisearchSettings</code> <p>Settings of the index.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings     &gt;&gt;&gt; new_settings = MeilisearchSettings(     &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},     &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],     &gt;&gt;&gt;     ranking_rules=[     &gt;&gt;&gt;         \"words\",     &gt;&gt;&gt;         \"typo\",     &gt;&gt;&gt;         \"proximity\",     &gt;&gt;&gt;         \"attribute\",     &gt;&gt;&gt;         \"sort\",     &gt;&gt;&gt;         \"exactness\",     &gt;&gt;&gt;         \"release_date:desc\",     &gt;&gt;&gt;         \"rank:desc\",     &gt;&gt;&gt;    ],     &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],     &gt;&gt;&gt;    distinct_attribute=\"url\",     &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],     &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],     &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],     &gt;&gt;&gt; )     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_settings(new_settings)</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_settings(self, body: MeilisearchSettings, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update settings of the index.\n\n    Args:\n        body: Settings of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n        &gt;&gt;&gt; new_settings = MeilisearchSettings(\n        &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n        &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n        &gt;&gt;&gt;     ranking_rules=[\n        &gt;&gt;&gt;         \"words\",\n        &gt;&gt;&gt;         \"typo\",\n        &gt;&gt;&gt;         \"proximity\",\n        &gt;&gt;&gt;         \"attribute\",\n        &gt;&gt;&gt;         \"sort\",\n        &gt;&gt;&gt;         \"exactness\",\n        &gt;&gt;&gt;         \"release_date:desc\",\n        &gt;&gt;&gt;         \"rank:desc\",\n        &gt;&gt;&gt;    ],\n        &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n        &gt;&gt;&gt;    distinct_attribute=\"url\",\n        &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n        &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n        &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_settings(new_settings)\n    \"\"\"\n    body_dict = {\n        k: v\n        for k, v in body.model_dump(by_alias=True, exclude_none=True).items()\n        if v is not None\n    }\n    response = self._http_requests.patch(self._settings_url, body_dict, compress=compress)\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_sortable_attributes","title":"<code>update_sortable_attributes(sortable_attributes, *, compress=False)</code>","text":"<p>Get sortable attributes of the AsyncIndex.</p> <p>Parameters:</p> Name Type Description Default <code>sortable_attributes</code> <code>list[str]</code> <p>List of attributes for searching.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_sortable_attributes([\"title\", \"release_date\"])</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_sortable_attributes(\n    self, sortable_attributes: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Get sortable attributes of the AsyncIndex.\n\n    Args:\n        sortable_attributes: List of attributes for searching.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_sortable_attributes([\"title\", \"release_date\"])\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/sortable-attributes\", sortable_attributes, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_stop_words","title":"<code>update_stop_words(body, *, compress=False)</code>","text":"<p>Update stop words of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[str]</code> <p>List containing the stop words of the index.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_stop_words([\"the\", \"a\", \"an\"])</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_stop_words(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update stop words of the index.\n\n    Args:\n        body: List containing the stop words of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_stop_words([\"the\", \"a\", \"an\"])\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/stop-words\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_synonyms","title":"<code>update_synonyms(body, *, compress=False)</code>","text":"<p>Update synonyms of the index.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>dict[str, list[str]]</code> <p>The synonyms of the index.</p> required <p>Returns:</p> Type Description <code>TaskInfo</code> <p>The details of the task status.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_synonyms(     &gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}     &gt;&gt;&gt;     )</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_synonyms(self, body: dict[str, list[str]], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update synonyms of the index.\n\n    Args:\n        body: The synonyms of the index.\n\n    Returns:\n        The details of the task status.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_synonyms(\n        &gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n        &gt;&gt;&gt;     )\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/synonyms\", body, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_typo_tolerance","title":"<code>update_typo_tolerance(typo_tolerance, *, compress=False)</code>","text":"<p>Update typo tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>typo_tolerance</code> <code>TypoTolerance</code> <p>Typo tolerance settings.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     TypoTolerance(enabled=False)     &gt;&gt;&gt;     index.update_typo_tolerance()</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_typo_tolerance(\n    self, typo_tolerance: TypoTolerance, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update typo tolerance.\n\n    Args:\n        typo_tolerance: Typo tolerance settings.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     TypoTolerance(enabled=False)\n        &gt;&gt;&gt;     index.update_typo_tolerance()\n    \"\"\"\n    response = self._http_requests.patch(\n        f\"{self._settings_url}/typo-tolerance\",\n        typo_tolerance.model_dump(by_alias=True, exclude_unset=True),\n        compress=compress,\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_word_dictionary","title":"<code>update_word_dictionary(dictionary, *, compress=False)</code>","text":"<p>Update the word dictionary settings for an index.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>list[str]</code> <p>List of dictionary values.</p> required <code>compress</code> <code>bool</code> <p>If set to True the data will be sent in gzip format. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TaskInfo</code> <p>Task to track the action.</p> <p>Raises:</p> Type Description <code>MeilisearchCommunicationError</code> <p>If there was an error communicating with the server.</p> <code>MeilisearchApiError</code> <p>If the Meilisearch API returned an error.</p> <p>Examples     &gt;&gt;&gt; from meilisearch_python_sdk import Client     &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:     &gt;&gt;&gt;     index = client.index(\"movies\")     &gt;&gt;&gt;     index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")</p> Source code in <code>meilisearch_python_sdk/index/index.py</code> <pre><code>def update_word_dictionary(self, dictionary: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update the word dictionary settings for an index.\n\n    Args:\n        dictionary: List of dictionary values.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n        Task to track the action.\n\n    Raises:\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/dictionary\", dictionary, compress=compress\n    )\n\n    return TaskInfo(**self._http_requests.parse_json(response))\n</code></pre>"},{"location":"json_handler/","title":"JSON Handler","text":"<p>For json loads and dumps you have the option to use the <code>json</code> module from the standard library, or orjson. This done by setting the <code>json_handler</code> when creating the <code>AsyncClient</code> or <code>Client</code>. By default the standard library <code>json</code> module will be used. The examples below use <code>Client</code>, and the same options are available for <code>AsyncClient</code>.</p>"},{"location":"json_handler/#standard-library-json-module","title":"Standard Library <code>json</code> Module","text":""},{"location":"json_handler/#custom-serializer","title":"Custom Serializer","text":"<p>In some cases your documents will contain types that the Python JSON serializer does not know how to handle. When this happens you can provide your own custom serializer when using the <code>json</code> module.</p>"},{"location":"json_handler/#example","title":"Example","text":"<pre><code>from datetime import datetime\nfrom json import JSONEncoder\nfrom uuid import uuid4\n\nfrom meilisearch_python_sdk import Client\nfrom meilisearch_python_sdk.json_handler import BuiltinHandler\n\n\nclass CustomEncoder(JSONEncoder):\n    def default(self, o):\n        if isinstance(o, (UUID, datetime)):\n            return str(o)\n\n        # Let the base class default method raise the TypeError\n        return super().default(o)\n\n\ndocuments = [\n    {\"id\": uuid4(), \"title\": \"test 1\", \"when\": datetime.now()},\n    {\"id\": uuid4(), \"title\": \"Test 2\", \"when\": datetime.now()},\n]\nwith Client(\"http://127.0.0.1:7700\", json_handler=BuiltinHandler(serializer=CustomEncoder)) as client:\n    index = client.index(\"movies\", primary_key=\"id\")\n    index.add_documents(documents)\n</code></pre>"},{"location":"json_handler/#orjson","title":"orjson","text":""},{"location":"json_handler/#example_1","title":"Example","text":"<pre><code>from uuid import uuid4\n\nfrom meilisearch_python_sdk import Client\nfrom meilisearch_python_sdk.json_handler import OrjsonHandler\n\n\ndocuments = [\n    {\"id\": uuid4(), \"title\": \"test 1\"},\n    {\"id\": uuid4(), \"title\": \"Test 2\"},\n]\nwith Client(\"http://127.0.0.1:7700\", json_handler=OrjsonHandler()) as client:\n    index = client.index(\"movies\", primary_key=\"id\")\n    index.add_documents(documents)\n</code></pre>"},{"location":"plugins/","title":"Plugins","text":"<p>Plugins can be used to extend the functionality of certain methods, currently plugins are only supported for indexes. To create plugins you creat a class that implements the Protocol for the plugin, then add an instance of your class to the plugins when creating an index. Passing protocols is done through a named tuple that specifies where the plugin should run. The options are:</p> <ul> <li>add_documents_plugins: Runs the plugins when adding documents. This runs for all the add documents   methods, i.e. <code>add_documents_in_batches</code>.</li> <li>delete_all_documents_plugins: Run on the <code>delete_all_documents</code> method.</li> <li>delete_document_plugins: Run on the <code>delete_document</code> method.</li> <li>delete_documents_plugins: Run on the <code>delete_documents</code> method.</li> <li>delete_documents_by_filter_plugins: Run on the <code>delete_documents_by_filter</code> method.</li> <li>search_plugins: Run on the <code>search</code> and <code>facet_search</code> methods.</li> <li>update_documents_plugins: Run on the <code>update_document</code> method.</li> </ul> <p>When creating your plugin you specify if you want it to run before or after the default functionality. Additionally plugins for async indexes can be run concurrently with the default functionality.</p>"},{"location":"plugins/#examples","title":"Examples","text":""},{"location":"plugins/#search-metrics","title":"Search metrics","text":"<p>It is common to want to know what users are searching for, however Meilisearch doesn't provide a way to track this out of the box. A search plugin could be used to implement this functionality yourself.</p> <p>Note that in these examples the protocol is satisfied by providing the <code>CONNECURRENT_EVENT</code>, <code>POST_EVENT</code>, and <code>PRE_EVENT</code> variables and the <code>async def run_plugin(self, event: AsyncEvent, **kwargs: Any) -&gt; None:</code> method for an async index, or the <code>POST_EVENT</code> and <code>PRE_EVENT</code> variables , and <code>def run_plugin(self, event: Event, **kwargs: Any) -&gt; None:</code> method for a non-async index. You class can contain any additional methods/variables needed as long as the protocol requirements have been satisfied.</p>"},{"location":"plugins/#async-index","title":"Async index","text":"<pre><code>import asyncio\nimport json\nimport sqlite3\nfrom typing import Any\n\nfrom meilisearch_python_sdk import AsyncClient\nfrom meilisearch_python_sdk.plugins import AsyncEvent, AsyncIndexPlugins\n\n\nclass SearchTrackerPlugin:\n    CONCURRENT_EVENT = True  # Specifies the plugin should be run concurrently with the search\n    POST_EVENT = False\n    PRE_EVENT = False\n\n    def __init__(self) -&gt; None:\n        self.conn = sqlite3.Connection(\"examples/search_tracker.db\")\n        self.create_table()\n\n    def create_table(self) -&gt; None:\n        try:\n            cursor = self.conn.cursor()\n            cursor.execute(\"CREATE TABLE IF NOT EXISTS searches(query STRING)\")\n        finally:\n            cursor.close()\n\n    async def run_plugin(self, event: AsyncEvent, **kwargs: Any) -&gt; None:\n        \"\"\"Note that this example uses sqlite which does not provide an async driver.\n\n        Typically if you are using the AsyncClient you would also be using an async driver for the\n        database. sqlite is used in this example for simplicity.\n        \"\"\"\n        if kwargs.get(\"query\"):\n            self.save_search_query(kwargs[\"query\"])\n\n    def save_search_query(self, query: str) -&gt; None:\n        try:\n            cursor = self.conn.cursor()\n            cursor.execute(\"INSERT INTO searches VALUES(?)\", (query,))\n            self.conn.commit()\n        finally:\n            cursor.close()\n\n\nasync def main() -&gt; int:\n    with open(\"datasets/small_movies.json\") as f:\n        documents = json.load(f)\n\n    async with AsyncClient(\"http://127.0.0.1:7700\", \"masterKey\") as client:\n        plugins = AsyncIndexPlugins(search_plugins=(SearchTrackerPlugin(),))\n        index = await client.create_index(\"movies\", primary_key=\"id\", plugins=plugins)\n        task = await index.add_documents(documents)\n        await client.wait_for_task(task.task_uid)\n        result = await index.search(\"Cars\")\n        print(result)  # noqa: T201\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(asyncio.run(main()))\n</code></pre>"},{"location":"plugins/#index","title":"Index","text":"<pre><code>import json\nimport sqlite3\nfrom typing import Any\n\nfrom meilisearch_python_sdk import Client\nfrom meilisearch_python_sdk.plugins import Event, IndexPlugins\n\n\nclass SearchTrackerPlugin:\n    POST_EVENT = False\n    PRE_EVENT = True  # Specifies the plugin should be run before the search\n\n    def __init__(self) -&gt; None:\n        self.conn = sqlite3.Connection(\"examples/search_tracker.db\")\n        self.create_table()\n\n    def create_table(self) -&gt; None:\n        try:\n            cursor = self.conn.cursor()\n            cursor.execute(\"CREATE TABLE IF NOT EXISTS searches(query STRING)\")\n        finally:\n            cursor.close()\n\n    def run_plugin(self, event: Event, **kwargs: Any) -&gt; None:\n        if kwargs.get(\"query\"):\n            self.save_search_query(kwargs[\"query\"])\n\n    def save_search_query(self, query: str) -&gt; None:\n        try:\n            cursor = self.conn.cursor()\n            cursor.execute(\"INSERT INTO searches VALUES(?)\", (query,))\n            self.conn.commit()\n        finally:\n            cursor.close()\n\n\ndef main() -&gt; int:\n    with open(\"datasets/small_movies.json\") as f:\n        documents = json.load(f)\n\n    with Client(\"http://127.0.0.1:7700\", \"masterKey\") as client:\n        plugins = IndexPlugins(search_plugins=(SearchTrackerPlugin(),))\n        index = client.create_index(\"movies\", primary_key=\"id\", plugins=plugins)\n        task = index.add_documents(documents)\n        client.wait_for_task(task.task_uid)\n        result = index.search(\"Cars\")\n        print(result)  # noqa: T201\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n</code></pre>"},{"location":"plugins/#modify-documents-and-search-results","title":"Modify documents and search results","text":"<p>A pre event plugin can be used to modify the documents before sending for indexing. In this example a new <code>access</code> field will be added to the documents before they are added or updated. The example will set every other record to <code>admin</code> access with the other records being set to <code>read</code>. This will illustrate the idea of modifying documents even it if doesn't make real world sense.</p> <p>A post search plugin, this type of search plugin can only be used post search because it requires the result of the search, will be used to remove records marked as <code>admin</code> before returning the result. In the real world this filtering would probably be done with a filterable field in Meilisearch,but again, this is just used here to illustrate the idea.</p>"},{"location":"plugins/#async-index_1","title":"Async Index","text":"<pre><code>import asyncio\nimport json\nfrom typing import Any, Sequence\n\nfrom meilisearch_python_sdk import AsyncClient\nfrom meilisearch_python_sdk.models.search import SearchResults\nfrom meilisearch_python_sdk.plugins import AsyncEvent, AsyncIndexPlugins\nfrom meilisearch_python_sdk.types import JsonMapping\n\n\nclass ModifyDocumentPlugin:\n    CONCURRENT_EVENT = False\n    POST_EVENT = False\n    PRE_EVENT = True  # Specifies the plugin should be run before adding documents\n\n    async def run_document_plugin(\n        self, event: AsyncEvent, *, documents: Sequence[JsonMapping], **kwargs: Any\n    ) -&gt; Sequence[JsonMapping]:\n        updated = []\n        for i, document in enumerate(documents):\n            if i % 2 == 0:\n                document[\"access\"] = \"admin\"\n            else:\n                document[\"access\"] = \"read\"\n\n            updated.append(document)\n\n        return updated\n\n\nclass FilterSearchResultsPlugin:\n    CONCURRENT_EVENT = False\n    POST_EVENT = True  # Specifies the plugin should be run after the search\n    PRE_EVENT = False\n\n    async def run_post_search_plugin(\n        self, event: AsyncEvent, *, search_results: SearchResults, **kwargs: Any\n    ) -&gt; SearchResults:\n        filtered_hits = []\n        for hit in search_results.hits:\n            if hit[\"access\"] != \"admin\":\n                filtered_hits.append(hit)\n\n        search_results.hits = filtered_hits\n\n        return search_results\n\n\nasync def main() -&gt; int:\n    with open(\"datasets/small_movies.json\") as f:\n        documents = json.load(f)\n\n    async with AsyncClient(\"http://127.0.0.1:7700\", \"masterKey\") as client:\n        plugins = AsyncIndexPlugins(\n            add_documents_plugins=(ModifyDocumentPlugin(),),\n            update_documents_plugins=(ModifyDocumentPlugin(),),\n            search_plugins=(FilterSearchResultsPlugin(),),\n        )\n        index = await client.create_index(\"movies\", primary_key=\"id\", plugins=plugins)\n        task = await index.add_documents(documents)\n        await client.wait_for_task(task.task_uid)\n        result = await index.search(\"cars\")\n        print(result)  # noqa: T201\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(asyncio.run(main()))\n</code></pre>"},{"location":"plugins/#index_1","title":"Index","text":"<pre><code>import json\nfrom typing import Any, Sequence\n\nfrom meilisearch_python_sdk import Client\nfrom meilisearch_python_sdk.models.search import SearchResults\nfrom meilisearch_python_sdk.plugins import Event, IndexPlugins\nfrom meilisearch_python_sdk.types import JsonMapping\n\n\nclass ModifyDocumentPlugin:\n    POST_EVENT = False\n    PRE_EVENT = True  # Specifies the plugin should be run before adding documents\n\n    def run_document_plugin(\n        self, event: Event, *, documents: Sequence[JsonMapping], **kwargs: Any\n    ) -&gt; Sequence[JsonMapping]:\n        updated = []\n        for i, document in enumerate(documents):\n            if i % 2 == 0:\n                document[\"access\"] = \"admin\"\n            else:\n                document[\"access\"] = \"read\"\n\n            updated.append(document)\n\n        return updated\n\n\nclass FilterSearchResultsPlugin:\n    POST_EVENT = True  # Specifies the plugin should be run after the search\n    PRE_EVENT = False\n\n    def run_post_search_plugin(\n        self, event: Event, *, search_results: SearchResults, **kwargs: Any\n    ) -&gt; SearchResults:\n        filtered_hits = []\n        for hit in search_results.hits:\n            if hit[\"access\"] != \"admin\":\n                filtered_hits.append(hit)\n\n        search_results.hits = filtered_hits\n\n        return search_results\n\n\ndef main() -&gt; int:\n    with open(\"datasets/small_movies.json\") as f:\n        documents = json.load(f)\n\n    with Client(\"http://127.0.0.1:7700\", \"masterKey\") as client:\n        plugins = IndexPlugins(\n            add_documents_plugins=(ModifyDocumentPlugin(),),\n            update_documents_plugins=(ModifyDocumentPlugin(),),\n            search_plugins=(FilterSearchResultsPlugin(),),\n        )\n        index = client.create_index(\"movies\", primary_key=\"id\", plugins=plugins)\n        task = index.add_documents(documents)\n        client.wait_for_task(task.task_uid)\n        result = index.search(\"cars\")\n        print(result)  # noqa: T201\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n</code></pre>"},{"location":"pydantic/","title":"Pydantic usage","text":"<p>This package uses Pydantic to serialize/deserialize the JSON from Meilisearch into Python objects wherever possible, and in the process uses <code>CamelBase</code> from camel-converter to convert the camelCaseNames from JSON into more Pythonic snake_case_names.</p> <p>In some instances it is not possible to return the data as an object because the structure will be dependant on your particular dataset and can't be known ahead of time. In these instances you can either work with the data in the dictionary that is returned, or because you will know the structure you can generate your own Pydantic models.</p> <p>As an example, if you want to get a movie from the small movies example you could put the results into an object with the following:</p> <pre><code>from datetime import datetime\nfrom typing import Optional\n\nfrom camel_converter.pydantic_base import CamelBase\nfrom meilisearch_python_sdk import Client\n\n\nclass Movie(CamelBase):\n    \"\"\"\n    Inheriting from CamelBase will allow your class to automatically convert variables returned\n    from the server in camelCase into snake_case. It will also make it a Pydantic Model.\n    \"\"\"\n    id: int\n    title: str\n    poster: str\n    overview: str\n    release_date: datetime\n    genre: Optional[str] = None\n\n\nasync with Client(\"http://127.0.0.1:7700\", \"masterKey\") as client:\n    index = client.index(\"movies\")\n    movie_dict = await index.get_document(287947)\n    movie = Movie(**movie_dict)\n</code></pre> <p>And then the movie variable would contain the movie object with the following information</p> <pre><code>Movie(\n    id = 287947,\n    title = \"Shazam!\",\n    poster = \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n    overview = \"A boy is given the ability to become an adult superhero with a single magic word.\",\n    release_date = datetime.datetime(2019, 3, 23, 0, 0, tzinfo=datetime.timezone.utc),\n    genre = \"action\",\n)\n</code></pre> <p>By inheriting from CamelBase, or any of the other provided models you will be inheriting Pydantic models and therefore have access to the functionality Pydantic provides such as validators and Fields. Pydantic will also automatically deserialized the data into the correct data type based on the type hint provided.</p> <p>For <code>SearchResults</code>, the <code>hits</code> field is generic so you can specify a model that matches your data. If no type is specified it will default to <code>JsonDict</code> (<code>dict[str, Any]</code>).</p> <pre><code>from datetime import datetime\nfrom typing import Optional\n\nfrom camel_converter.pydantic_base import CamelBase\nfrom meilisearch_python_sdk import Client\n\n\nclass Movie(CamelBase):\n    \"\"\"\n    Inheriting from CamelBase will allow your class to automatically convert\n    variables returned from the server in camelCase into snake_case. It will\n    also make it a Pydantic Model.\n    \"\"\"\n    id: int\n    title: str\n    poster: str\n    overview: str\n    release_date: datetime\n    genre: Optional[str] = None\n\n\nasync with Client(\"http://127.0.0.1:7700\", \"masterKey\") as client:\n    index = client.index(\"movies\", hits_type=Movie)\n    movies = await index.search(\"Spiderman\")\n</code></pre> <p><code>movies.hits</code> will now have items of type <code>Movie</code> instead of <code>JsonDict</code>.</p>"}]}